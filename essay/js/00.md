


## 使用 new 的时候发生了什么

----

使用 ```new``` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作

1. 创建（或者说构造）一个全新的对象，可以简单的理解为一个空对象 `{}`

2. 这个新对象会被执行 [[原型]] 连接

3. 这个新对象会绑定到函数调用的 ```this```（简单来说就是将自己的上下文设置为这个 `{}`，即 this 表示为这个对象）

4. 如果函数没有返回其他对象，那么 ```new``` 表达式中的函数调用会自动返回这个新对象

```js
function foo(a) {
    this.a = a;
}
 
var bar = new foo(2);
console.log(bar.a); // 2
```

使用 ```new``` 来调用 ```foo(..)``` 时，我们会构造一个新对象并把它绑定到 ```foo(..)``` 调用中的 ```this``` 上


#### 关于函数的返回值

如果一个构造函数不写 `return` 语句，则系统会自动帮你返回一个对象，但是如果写了 `return` 语句，则

* 如果 `return` 的是一个基本类型的值（比如 `string`，`number`），则会忽略这个 `return`，该返回什么还是返回什么，但是会阻止构造函数接下来的执行

* 如果 `return` 了一个引用类型，则原有的 `return` 会被覆盖





## 浏览器中的各种长度

#### JavaScript

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变

document.body.clientHeight     // 返回对象内容的可视区的高度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变

document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变

document.body.offsetHeight     // 对象整体的实际高度（包括边框和填充），会随对象显示大小的变化而改变

document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大

document.body.scrollHeight     // 对象的实际内容的高度（不包括边线宽度），会随对象中内容超过可视区后而变大

----

document.body.scrollTop        // 页面滚动条向下拉动的距离

document.body.scrollLeft       // 页面滚动条向左拉动的距离

obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变

obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同

----

// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度

window.screen.height           // 屏幕分辨率的高度

window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）

window.screen.availHeight      // 显示器工作区高度（除去任务栏的距离）
```



#### jQuery

```js
width();                       // 设置或返回被选元素的宽度
 
height();                      // 设置或返回被选元素的高度

$(window).height()             // 浏览器当前窗口可视区域高度

$(document).height()           // 浏览器当前窗口文档对象高度也就是页面整体高度

$(document.body).width()       // 浏览器当前窗口文档 body 的宽度
 
$(window).scrollTop()          // 垂直滚动的距离 即当前滚动的地方的窗口顶端到整个页面顶端的距离
                               // 与 $(document).scrollTop() 一致，但是 $(window).scrollTop() 被所有浏览器支持
 
$(window).scrollLeft()         // 这是获取水平滚动条的距离

----

// 返回偏移坐标
$(selector).offset();

top: $(selector).offset().top;

left: $(selector).offset().left;

----

// 两个用的较少的方法 
$(document.body).outerHeight(true)   // 浏览器当前窗口文档 body 的总高度 包括 border padding margin（对可见和隐藏元素均有效）

$(document.body).outerWidth(true)    // 浏览器当前窗口文档 body 的总宽度 包括 border padding margin（对可见和隐藏元素均有效）
```




#### 一些比较常用的方法

#### 可视区高度

获取元素到浏览器顶端的距离，根据页面滚动，这个值是一直在变化的

```js
obj.offsetTop - document.body.scrollTop
```


#### 判断页面是否在顶部

```js
document.body.scrollTop == 0
```

#### 判断页面是否在底部

```js
$(document).height() == $(window).height() + $(window).scrollTop()

即

$(window).scrollTop() >= $(document).height() - $(window).height()
```


#### innerHeight(value)

![img](https://raw.githubusercontent.com/heptaluan/blog/master/essay/js/innerheight.jpg)

```js
innerHeight  // 高度＋补白

outerHeight  // 高度＋补白＋边框，参数为 true 时为 高度＋补白＋边框＋边距
```

`value` 参数可以是一个字符串（数字加单位）或者是一个数字，如果这个 `value` 参数只提供一个数字，`jQuery` 会自动加上像素单位（`px`）

如果只提供一个字符串，任何有效的 `CSS` 尺寸都可以为高度赋值（就像 `100px`，`50%`，或者 `auto`）

注意在现代浏览器中，`CSS` 高度属性不包含 `padding`，`border` 或者 `margin`， 除非 `box-sizing` 属性被应用



#### 兼容问题

`document.body.scrollTop` 有兼容问题，可以使用

```js
var top = document.body.scrollTop || document.documentElement.scrollTop;
```



#### scrollWidth，clientWidth 和 offsetWidth 区别

分为两种情况

#### 第一种情况

元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下

* `scrollWidth = clientWidth`，两者皆为内容可视区的宽度

* `offsetWidth` 为元素的实际宽度

![img](http://images.cnitblog.com/blog/166781/201412/291654504031651.png)

#### 第二种情况

元素的内容超过可视区，滚动条出现和可用的情况下

* `scrollWidth > clientWidth`

* `scrollWidth` 为实际内容的宽度

* `clientWidth` 是内容可视区的宽度

* `offsetWidth` 是元素的实际宽度

![img](http://images.cnitblog.com/blog/166781/201412/291655026226285.png)



#### Event 对象的五种坐标


```js
clientX 和 clientY    // 相对于浏览器（可视区，左上角0，0）的坐标

screenX 和 screenY    // 相对于设备屏幕左上角（0，0）的坐标

offsetX 和 offsetY    // 相对于事件源左上角（0，0）的坐标
 
pageX 和 pageY        // 相对于整个网页左上角（0，0）的坐标，但它不会随着滚动条而变动

X 和 Y                // 本来是 IE 属性，相对于用 CSS 动态定位的最内层包容元素
```




## parseInt

使用的时候建议始终添加**第二个参数**来指定进制，比如

```js
parseInt(123, 10)  // 返回 123
```

#### 如果是整数，返回其本身

```js
parseInt(123, 10)  // 返回 123
```

#### 如果是浮点数，返回整数部分

```js
parseInt(123.123, 10)   // 返回 123
```


#### 如果是字符串

* 如果字符串第一个非空字符前面含有空格，则忽略空格，直接从第一个非空字符开始解析

```js
parseInt(" 1234", 10)   // 返回 1234
```

* 如果第一个非空字符不是数字或者符号，则返回 ```NaN```

```js
parseInt("df2bc", 10)  // 返回 NaN
```

* 如果第一个非空字符是数字，则继续解析直至解析完毕或者**遇到第一个非数字符号**为止

```js
parseInt("123abc", 10)  // 返回 123
```



## sessionStorage，localStorage 和 cookie 的区别

`sessionStorage`、`localStorage`、`cookie` 都是在浏览器端存储的数据

其中 `sessionStorage` 的概念很特别，引入了一个 "浏览器窗口" 的概念，`sessionStorage` 是在同源的同窗口（或 `tab`）中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在

关闭窗口后，`sessionStorage` 即被销毁，同时 "独立" 打开的不同窗口，即使是同一页面，`sessionStorage` 对象也是不同的

----

**两者的共同点**：都是保存在浏览器端，且同源的

**区别如下**：

* `cookie` 数据始终在同源的 `http` 请求中携带（即使不需要），即 `cookie` 在浏览器和服务器间来回传递，而 `sessionStorage` 和 `localStorage` 不会自动把数据发给服务器，仅在本地保存

* `cookie` 数据还有路径（`path`）的概念，可以限制 `cookie` 只属于某个路径下，存储大小限制也不同，`cookie` 数据不能超过 4k，同时因为每次 `http` 请求都会携带 `cookie`，所以 `cookie` 只适合保存很小的数据，如会话标识，`sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比 `cookie` 大得多，可以达到 5M 或更大，数据有效期不同

* `sessionStorage`：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持

* `localStorage`：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

* `cookie` 只在设置的 `cookie` 过期时间之前一直有效，即使窗口或浏览器关闭，作用域不同，`sessionStorage` 不在不同的浏览器窗口中共享，即使是同一个页面

* `localStorage` 在所有同源窗口中都是共享的

* `cookie` 也是在所有同源窗口中都是共享的，`Web Storage` 支持事件通知机制，可以将数据更新的通知发送给监听者，`Web Storage` 的 `api` 接口使用更方便



## call 和 apply 哪个速度更快一些

通常来说，`call` 是要比 `apply` 快一些的，至于为什么，这就要看它们在被调用之后发生了什么

#### Function.prototype.apply (thisArg, argArray)

1. 如果 `IsCallable（Function）` 为 `false`，即 `Function` 不可以被调用，则抛出一个 `TypeError` 异常

2. 如果 `argArray` 为 `null` 或未定义，则返回调用 `Function` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 和一个空数组作为参数

3. 如果 `Type（argArray）` 不是 `Object`，则抛出 `TypeError` 异常

4. 获取 `argArray` 的长度，调用 `argArray` 的 `[[Get]]` 内部方法，找到属性 `length`， 赋值给 `len`

5. 定义 `n` 为 `ToUint32（len）`

6. 初始化 `argList` 为一个空列表

7. 初始化 `index` 为 `0`

8. 循环迭代取出 `argArray`，重复循环 `while（index < n）`

  * 将下标转换成 `String` 类型，初始化 `indexName` 为 `ToString(index)`

  * 定义 `nextArg` 为 使用 `indexName` 作为参数调用 `argArray` 的 `[[Get]]` 内部方法的结果

  * 将 `nextArg` 添加到 `argList` 中，作为最后一个元素

  * 设置 `index ＝ index＋1`

9. 返回调用 `Function` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 作为该值，`argList` 作为参数列表


#### Function.prototype.call (thisArg [ , arg1 [ , arg2, .. ] ] )

* 如果 `IsCallable（Function）` 为 `false`，即 `Function` 不可以被调用，则抛出一个 `TypeError` 异常

* 定义 `argList` 为一个空列表

* 如果使用超过一个参数调用此方法，则以从 `arg1` 开始的从左到右的顺序将每个参数附加为 `argList` 的最后一个元素

* 返回调用 `func` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 作为该值，`argList` 作为参数列表


#### 总结

由于 `apply` 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤 `8` 中所示）， 同时也有一些对参数的检查（步骤 `2`），而在 `call` 中却是不必要的

另外在 `apply` 中不管有多少个参数，都会执行循环，也就是步骤 `6 - 8`，而在 `call` 中也就是对应步骤 `3` ，是有需要才会被执行



## JavaScript 中的事件模型

简单来说，即一个类或是一个模块，有两个函数，一个 `bind` 一个 `trigger`，分别实现绑定事件和触发事件

核心需求就是可以对某一个事件名称绑定多个事件响应函数，然后触发这个事件名称时，依次按绑定顺序触发相应的响应函数

```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName];

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例对象
var emitter = new Emitter();

emitter.on("event2", function (arg1, arg2) {
  console.log("get event2", arg1, arg2);
})

emitter.on("event1", function (arg1, arg2) {
  console.log("get event1", arg1, arg2);
})

console.log("emit event");

emitter.emit("event2", "arg1", "arg2");
emitter.emit("event1", "arg1", "arg2");
```

也可以使用 `WeakMap`，原理是一样的

```js
var listeners = new WeakMap();

// 监听事件
function on(object, event, fn) {
  var _listeners = listeners.get(object) || {};
  if (!_listeners[event]) _listeners[event] = [];
  _listeners[event].push(fn);
  listeners.set(object, _listeners);
}

// 触发事件
function emit(object, event) {
  var _listeners = listeners.get(object) || {};
  if (!_listeners[event]) _listeners[event] = [];
  _listeners[event].forEach(function (fn) {
    fn.call(object, event);
  });
}

// 使用
var obj = {};
on(obj, 'hello', function () {
  console.log('hello');
});

emit(obj, 'hello');


```



## JavaScript 中常用的设计模式

#### 单例模式

简单来说，任意对象都是单例，无须特别处理

```js
var obj = { name: "zhangsan", age: 20 };
```

一个通用的惰性单例

```js
var getSingle = function (fn) {
  var result;
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}
```


#### 工厂模式

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型

```js
var Car = (function () {
  var Car = function (name, age) {
    this.name = name;
    this.age = age;
  };
  return function (name, age) {
    return new Car(name, age);
  };
})();


var zhangsan = new Car("zhangsan", 20);
var lisi = new Car("lisi", 22);
```

即

```js
var productManager = {};

productManager.createProductA = function () {
  console.log('ProductA');
}

productManager.createProductB = function () {
  console.log('ProductB');
}

productManager.factory = function (typeType) {
  return new productManager[typeType];
}

productManager.factory('createProductA');
```


#### 代理模式

简单来说，就是新建个类调用老类的接口，包装一下

```js
function Person() { }

Person.prototype.sayName = function () {
  console.log('zhangsan');
}

Person.prototype.sayAge = function () {
  console.log(20);
}

function PersonProxy() {

  this.person = new Person();
  var that = this;

  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName);
    // 代理
    that.person[functionName]();
    console.log('after proxy:', functionName);
  }

}

var p = new PersonProxy();

p.callMethod('sayName');  // 代理调用 Person 的方法 sayName()
p.callMethod('sayAge');  // 代理调用 Person 的方法 sayAge()
```


#### 观察者模式

简单来说就是事件模式，比如按钮的 `onclick` 的应用

```js
function Publisher() {
  this.listeners = [];
}

// 发布者
Publisher.prototype = {

  'addListener': function (listener) {
    this.listeners.push(listener);
  },

  'removeListener': function (listener) {
    delete this.listeners[listener];
  },

  'notify': function (obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  }

};

function Subscriber() { }

// 订阅者
Subscriber.prototype = {
  'process': function (obj) {
    console.log(obj);
  }
};

var publisher = new Publisher();

publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());

// 发布一个对象到所有订阅者
publisher.notify({ name: 'zhangsan', ageo: 30 });

// 发布一个字符串到所有订阅者
publisher.notify('2 subscribers will both perform process');
```



## 常见函数 once/bind/debouce/throttle 的实现原理

#### once

原理是利用闭包的特性，传递参数，执行完一次以后就自动解除绑定

```js
function once(dom, event, callback) {
  var handle = function () {
    callback();
    dom.removeEventListener(event, handle);
  }
  dom.addEventListener(event, handle)
}
```

第二种方式

```js
const once = (fn) => {
  let done = false;
  return function () {
    done ? undefined : ((done = true), fn.apply(this, arguments));
  }
}

const test = once(() => {
  console.log(`test`);
})

test();  // test
test();  // undefined
```

#### bind

简单的实现方式为

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function () {
    var self = this,                        // 保存原函数
      context = [].shift.call(arguments),   // 保存需要绑定的 this 上下文
      args = [].slice.call(arguments);      // 剩余的参数转为数组
    return function () {                    // 返回一个新函数
      self.apply(context, [].concat.call(args, [].slice.call(arguments)));
    }
  }
}
```

`MDN` 上 `bind` 的实现为下面这种，详细解释可见 [bind 的定义与实现](https://github.com/heptaluan/blog/issues/48)

```js
if (!Function.prototype.bind) {

  Function.prototype.bind = function (oThis) {

    if (typeof this !== 'function') {
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP
          ? this
          : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}
```


#### debounce

在某些场景下，比如拖拽（`mousemove`），窗口大小调整（`resize`）等事件，触发频率比较高，若稍处理函数很复杂的话，就需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，导致假死或者卡顿感

这种情况下就出现了函数节流（`throttle`），和其类似的就是 `debounce` 函数，这两个函数的目的都是为了解决上述问题

#### 原理

比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 `throttle` 和 `debounce` ，超时设定为 `15` 秒，不考虑容量限制

* `throttle` 策略的电梯，保证如果电梯第一个人进来后，`15` 秒后准时运送一次，不等待，如果没有人，则待机

* `debounce` 策略的电梯，如果电梯里有人进来，等待 `15` 秒，如果有人进来，`15` 秒等待重新计时，直到 `15` 秒超时，开始运送


#### debounce

```js
// 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 time，handle 才会执行
var deBounce = function (fn, wait = 300) {
  let timer
  return function () {
    if (timer) {
      clearTimeOut(timer)
    }
    timer = setTimeOut(() => {
      fn.apply(this, arguments)
    }, wait)
  }
}
```


#### throttle

```js
// 频率控制 返回函数连续调用时，handle 执行频率限定为 次/time
// throttle(time, handle)
var throttle = function (fn, wait = 300) {
  let prev = +new Date();
  return function () {
    const args = argument, now = +new Date();
    if (now > prev + wait) {
      prev = now;
      fn.apply(this, args)
    }
  }
}
```



## 拖拽功能

#### PC 端拖拽功能

```js
var div = document.getElementById('div');

div.onmousedown = function (e) {
  var e = e || event;
  var disX = e.clientX - div.offsetLeft;
  var disY = e.clientY - div.offsetTop;

  document.onmousemove = function (e) {
    var e = e || event;
    div.style.left = e.clientX - disX + 'px';
    div.style.top = e.clientY - disY + 'px';
  }

  document.onmouseup = function () {
    document.onmousemove = null;
    document.onmouseup = null;
  }
}
```

#### 面向对象版本

```js
window.onload = function () {
  new Drag('div1');
  new Drag('div2');
};

function Drag(id) {
  var disX = 0;
  var disY = 0;
  var _this = this;

  this.oDiv = document.getElementById(id);
  this.oDiv.onmousedown = function (ev) {
    _this.fnDown(ev);

    return false;
  };
}

Drag.prototype.fnDown = function (ev) {
  var oEvent = ev || event;
  var _this = this;

  this.disX = oEvent.clientX - this.oDiv.offsetLeft;
  this.disY = oEvent.clientY - this.oDiv.offsetTop;

  document.onmousemove = function (ev) {
    _this.fnMove(ev);
  };

  document.onmouseup = function () {
    _this.fnUp();
  };
}

Drag.prototype.fnMove = function (ev) {
  var oEvent = ev || event;
  this.oDiv.style.left = oEvent.clientX - this.disX + 'px';
  this.oDiv.style.top = oEvent.clientY - this.disY + 'px';
}

Drag.prototype.fnUp = function () {
  document.onmousemove = null;
  document.onmouseup = null;
}
```

#### 移动端拖拽功能

与 ```PC``` 端实现类似，只是事件不太一样，一般用到的事件如下：

```js
touchstart:       // 手指放到屏幕上时触发

touchmove:        // 手指在屏幕上滑动式触发

touchend:         // 手指离开屏幕时触发


// 每个触摸事件被触发后，会生成一个 event 对象，event 对象里额外包括以下三个触摸列表:

touches:          // 当前屏幕上所有手指的列表

targetTouches:    // 当前 dom 元素上手指的列表，尽量使用这个代替 touches

changedTouches:   // 涉及当前事件的手指的列表，尽量使用这个代替 touches
```

```js
var div = document.getElementById('div');
var disX, disY;

div.addEventListener('touchstart', function (e) {
  var touches = e.targetTouches[0];
  disX = touches.clientX - div.offsetLeft;
  disY = touches.clientY - div.offsetTop;

  document.addEventListener('touchmove', function (e) {
    var touches = e.targetTouches[0];
    div.style.left = touches.clientX - disX + 'px';
    div.style.top = touches.clientY - disY + 'px';
  })

  document.addEventListener('touchend', function () {
    document.removeEventListener('touchmove', false)
  })

}, false);
```


## 如何监听 对象/数组 属性改变

#### 监听对象属性改变

在 ```ES5``` 中新增了一个 ```Object.defineProperty``` 的方法，可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象

```js
Object.defineProperty(obj, prop, descriptor)
```

其接受的第三个参数可以取 ```get/set``` 并各自对应一个 ```getter/setter``` 的方法

```js
var a = { obj: 0 };

Object.defineProperty(a, 'obj', {

  get: function () {
    console.log('get：' + obj);
    return obj;
  },

  set: function (value) {
    obj = value;
    console.log('set:' + obj);
  }

});

a.obj = 2; // set: 2
console.log(a.obj); // get：2
```

有个缺点就是在 ```IE8``` 及更低版本 IE 是无法使用的，因为这个特性是没有 ```polyfill``` 的，所以无法在不支持的平台实现


#### Proxy

另外还可以使用 ```ES6``` 提供的 ```Proxy``` 代理来处理

```js
var user = {}

var proxy = new Proxy(user, {

  get(target, property) {
    console.log(`get prop ${property}`)
    return `[${target[property]}]`
  },

  set(target, property, value) {
    console.log(`set prop ${property}`)
    target[property] = btoa(value)
  }
})

proxy.name = "admin"  // set prop name
                      // "admin"
```

#### 监听数组的变化

简单来说，就是定义一个新数组，然后继承原生的 ```Array```，然后重写其中我们需要监听的方法（```pop```，```push``` 等）

```js
class NewArray extends Array {
  constructor(...args) {
    // 调用父类 Array 的 constructor
    super(...args)
  }

  push(...args) {
    console.log(`监听到数组变化`)
    // 调用父类方法
    return super.push(...args);
  }
}

let arr = [1, 2];
let newArr = new NewArray(...arr);
console.log(newArr)  // [1, 2]

newArr.push(3);      // 监听到数组变化
console.log(newArr)  // [1, 2, 3]
```

#### 关于 ES5 以下实现

在 ```ES5``` 及以下的 ```JS``` 无法完美继承数组，因为 ```Array``` 构造函数执行时不会对传进去的 ```this``` 做任何处理，不止 ```Array```，```String```，```Number```，```Regexp```，```Object``` 等等 ```JS``` 的内置类都不行

数组其响应式的 ```length``` 属性以及内部的 ```[[class]]``` 属性我们无法再 ```JS``` 层面实现，这就导致我们无法去用任何一个对象来 "模仿" 一个数组

但是可以使用非标准属性 ```__proto__``` 来实现







## JavaScript 中的几种遍历对象的方式

`JS` 中遍历对象的方法，小小的总结一下，大致有以下几种

```js

Object.keys(obj)                  // 返回所有可枚举属性（不包括原型中属性，不含 Symbol 属性）
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组）

for...in                          // 返回所有可枚举属性（包括原型中的属性，不含 Symbol 属性）
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）

Object.getOwnPropertyNames(obj)   // 返回所有的自身属性（不包括原型中属性，不含 Symbol 属性，包括不可枚举（length））
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组）

Reflect.ownKeys(obj)              // 返回所有的自身属性（不管是否可枚举，不管是不是 Symbol，一律返回）
                                  // （如果参数不是一个对象，报错）（返回数组）

for...of                          // 返回当前对象上的每一个属性（不包括原型中的属性，包括 Symbol 属性）
                                  // （对于普通的对象，for...of 不能直接使用，否则会报错，必须部署了 iterator 接口才能使用）

```

#### Object.keys(obj)

返回一个表示给定对象的所有可枚举**属性**的**字符串数组**，包括对象自身的（不含继承的）所有可枚举属性（不含 `Symbol` 属性）

```js
var arr = ['a', 'b', 'c'];

console.log(Object.keys(arr));  // ['0', '1', '2']

// -------------------------------

var an_obj = { 100: 'a', 2: 'b', 7: 'c' };

console.log(Object.keys(an_obj));  // ['2', '7', '100']
```

几个注意点：

* 返回所有可枚举属性（不包括原型中属性，不含 `Symbol` 属性）（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）（返回数组）

* 返回的是一个表示给定对象的所有可枚举**属性**的**字符串数组**（但不包括原型中的属性）

* 数组中属性名的排列顺序和使用 `for...in` 循环遍历该对象时返回的顺序一致

* 因为 `for...in` 语句无法保证遍历顺序，故 `Object.keys(obj)` 顺序也是无法保证的，原因如下

  * `Chrome`，`Opera` 的 `JavaScript` 解析引擎遵循的是新版 `ECMA-262` 第五版规范，因此，使用 `for...in` 语句遍历对象属性时遍历书序并非属性构建顺序

  * 而 `IE6`，`IE7`，`IE8`，`Firefox`，`Safari` 的 `JavaScript` 解析引擎遵循的是较老的 `ECMA-262` 第三版规范，属性遍历顺序由属性构建的顺序决定




#### for...in

`for...in` 语句以任意顺序遍历一个对象的可枚举属性，对于每个不同的属性，语句都会被执行

```js
var obj = { a: 1, b: 2, c: 3 };

for (var prop in obj) {
  console.log(prop);  // a b c
}
```

几个注意点：

* 返回所有可枚举属性（包括原型中的属性，不含 `Symbol` 属性）（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）

* `for...in` 循环只遍历**可枚举**属性，循环将迭代对象的所有可枚举属性和从它的构造函数的 `prototype` **继承**而来的（包括被覆盖的内建属性）（即包括原型中的属性）

* `for...in` 不应该被用来迭代一个下标顺序很重要的 `Array`

* `for...in` 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的

* 如果仅迭代自身的属性，而不是它的原型，可以使用：

  * `getOwnPropertyNames()`  ==> 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组

  * `hasOwnProperty()`  ==> 来确定某属性是否是对象本身的属性（一般使用这个来过滤）

  * `propertyIsEnumerable()`  ==> 返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性



#### Object.getOwnPropertyNames(obj)

`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的属性名（**包括**不可枚举属性）组成的数组（但不会获取原型链上的属性）

```js
var arr = ['a', 'b', 'c'];

console.log(Object.getOwnPropertyNames(arr).sort()); // ['0', '1', '2', 'length']
```

几个注意点：

* 返回所有的自身属性（不包括原型中属性，不含 `Symbol` 属性，包括不可枚举（`length`））（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）（返回数组）

* 返回指定对象的所有自身属性的属性名**包括不可枚举属性**组成的数组

* 不会获取原型链上的属性

* 枚举属性的顺序与通过 `for...in` 循环（或 `Object.keys`）迭代该对象属性时一致

* 如果只获取到可枚举属性，使用 `Object.keys` 或用 `for...in` 循环（配合 `hasOwnProperty()`）


#### Reflect.ownKeys

静态方法 `Reflect.ownKeys()` 返回一个由目标对象自身的属性键组成的数组

```js
Reflect.ownKeys({ z: 3, y: 2, x: 1 }); // [ 'z', 'y', 'x' ]

Reflect.ownKeys([]); // ['length']
```

几个注意点：

* 返回所有的自身属性（不管是否可枚举，不管是不是 `Symbol`，一律返回）（如果参数不是一个对象，报错）（返回数组）

* 返回值等同于 `Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`



#### for...of

`for...of` 语句在可迭代对象（包括 `Array`, `Map`, `Set`, `String`, `TypedArray`（描述一个底层的二进制数据缓存区的一个类似数组（`array-like`）视图），`arguments` 对象等）上创建一个迭代循环，对每个不同属性的属性值，调用一个自定义的有执行语句的迭代挂钩

```js
let iterable = [10, 20, 30];

for (let value of iterable) {
  console.log(value);
}
// 10
// 20
// 30

//-----------------------------

let iterable = 'foo';

for (let value of iterable) {
  console.log(value);
}
// 'f'
// 'o'
// 'o'
```

几个注意点：

* 返回当前对象上的每一个属性（对于普通的对象，`for...of` 不能直接使用，否则会报错，必须部署了 `iterator` 接口才能使用）（不包括原型中的属性，包括 `Symbol` 属性）

* 并不适用于所有的 `object`，可以迭代出任何拥有 `iterator` 的对象

* `for...of` 遍历的是**当前对象上**的每一个属性值（不包括原型上的）





## 一些数组常用的方法和其返回值

#### 会改变调用它们的对象自身的值（不会返回新数组）

```js
Array.prototype.copyWithin()  // 在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值

Array.prototype.fill()        // 将数组中指定区间的所有元素的值，都替换成某个固定的值

Array.prototype.pop()         // 删除数组的最后一个元素，并返回这个元素

Array.prototype.push()        // 在数组的末尾增加一个或多个元素，并返回数组的新长度

Array.prototype.reverse()     // 颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个

Array.prototype.shift()       // 删除数组的第一个元素，并返回这个元素

Array.prototype.sort()        // 对数组元素进行排序，并返回当前数组

Array.prototype.splice()      // 在任意的位置给数组添加或删除任意个元素

Array.prototype.unshift()     // 在数组的开头增加一个或多个元素，并返回数组的新长度
```

#### 不会改变调用它们的对象的值（返回一个新的数组或者返回一个其它的期望值）

```js
Array.prototype.concat()          // 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组

Array.prototype.includes()        // 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false

Array.prototype.join()            // 连接所有数组元素组成一个字符串

Array.prototype.slice()           // 抽取当前数组中的一段元素组合成一个新数组

Array.prototype.toString()        // 返回一个由所有数组元素组合而成的字符串，遮蔽了原型链上的 Object.prototype.toString() 方法

Array.prototype.toLocaleString()  // 返回一个由所有数组元素组合而成的本地化后的字符串，遮蔽了原型链上的 Object.prototype.toLocaleString() 方法

Array.prototype.indexOf()         // 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1

Array.prototype.lastIndexOf()     // 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1

// 一个非标准的
Array.prototype.toSource()        // 返回一个表示当前数组字面量的字符串，遮蔽了原型链上的 Object.prototype.toSource() 方法

// 还有两个方法可以返回新数组

Array.from()    // 从类数组或者迭代对象（iterable object）中创建一个新的数组实例

Array.of()      // 创建一个有可变数量的参数的新的数组实例，无论参数有多少数量，而且可以是任意类型
```








## ajax，formData，同源策略，跨域

一些相关知识点：

```IE7+``` 已经内建 ```XMLHttpRequest``` 对象

老版本 ```IE``` 可以使用 ```ActiveX``` 对象（```new ActiveXObject('Microsoft.XMLHTTP')```）

在以下情况中，请使用 ```POST``` 请求：

* 无法使用缓存文件（更新服务器上的文件或数据库）

* 向服务器发送大量数据（```POST``` 没有数据量限制）

* 发送包含未知字符的用户输入时，```POST``` 比 ```GET``` 更稳定也更可靠

```open()``` 方法第三个参数表示 异步 操作（```true```）


#### 原生 ajax

```js
var xhr = new xhrRequest();

if (xhr) {

  xhr.open('GET', url);

  // 每当 readyState 值改变时，就会触发 onreadystatechange 事件
  // 注意：onreadystatechange 事件会被触发 5 次（0 - 4），对应着 readyState 的每个变化
  xhr.onreadystatechange = function () {

    // readyState 值说明  
    // 0 -- 初始化，xhr 对象已经创建，还未执行 open  
    // 1 -- 载入，已经调用 open 方法，但是还没发送请求  
    // 2 -- 载入完成，请求已经发送完成  
    // 3 -- 交互，可以接收到部分数据  
    // 4 -- OK

    // status 值说明  
    // 200: 成功  
    // 404: Not Found
    // 500: 服务器产生内部错误  
    if (xhr.readyState == 4 && xhr.status == 200) {
      // 响应分为两种
      // responseText -- 获得字符串形式的响应数据（通常是这个）
      // responseXML -- 获得 XML 形式的响应数据
      console.log(xhr.responseText);
    }
  };

  xhr.send();

}

// ---------------------------------------------------

// 如果需要使用 POST 请求发送表单数据，使用 setRequestHeader() 来添加 HTTP 头
// 然后在 send() 方法中添加需要发送的数据

// 在 Form 元素的语法中，EncType 表明提交数据的格式，用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型

// 下面是三种常用的设置方式
// application/x-www-form-urlencoded   -- 窗体数据被编码为 名称/值 对，这是标准的编码格式
// multipart/form-data                 -- 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分
// text/plain                          -- 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符 

xhr.open('POST', url, true);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(data);
```

如果 ```ajax``` 指定为 ```post``` 但是未设置 ```content-type``` 或未指定键时，由于 ```content-type``` 为 ```text/plain```，动态页并未帮你处理成键值对的形式，所以你得自己使用 ```2``` 进制流数据生成对应的 ```string``` 类型的数据

所以如果要生成键值对形式，你得指定 ```content-type``` 为 ```'application/x-www-form-urlencoded'```


#### ajax 改为 Promise

```js
function getJSON(url) {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(this.responseText, this)
        } else {
          var resJson = { code: this.status, response: this.response }
          reject(resJson, this)
        }
      }
    }
    xhr.send()
  })
}

// 使用
getJSON(url).then(function (data) {
  console.log(data)
}).catch(function (status) {
  console.log(`Error: ${status}`)
})
```

----

#### xhr2

```xhr2``` 于 ```xhr``` 最大的区别在于 ```xhr``` 只支持字符串类型的数据，而 ```xhr2``` 支持任意类型的数据，比如使用 ```xhr2``` 向服务器请求一张图片

```js
var xhr = new XMLHttpRequest();
xhr.open('get', url, true)

// 处理返回内容的类型
xhr.responseType = 'bold';

xhr.onload = function (e) {
  if (this.status == 200) {
    var url = window.URL.createObjectURL(this.responseType);
    var img = new Image();
    img.src = url;
    document.body.appendChild(img);
  }
}

xhr.send();
```

#### FormData 接口

简单来说，比起普通的 ```ajax```, 使用 ```FormData``` 的最大优点就是我们可以异步上传一个二进制文件

```js
// 如果带参数使用，比如 new FormData(someForm)，FormData 对象的作用就类似于 jQuery 中的的 serialize() 方法
// 得到的对象就是这个表单元素中所有键值对数据了
function sendForm(form) {
  var data = new FormData(form);

  // 在已知的表单后添加
  data.append({ 'user': '123' })
  xhr.send(data);
}

// 不带参数使用的话，可以使用 append 来添加我们想要的数据，比如常见的表单提交
var data = new FormData();
data.append({ 'user': '123' });

var xhr = new XMLHttpRequest();
xhr.open('POST', url, true);
xhr.send(data);
```

#### upload 属性

```xhr2``` 新增了一个 ```upload``` 属性，并可以为之绑定一个 ```onprogress``` 事件，检测上传的速度

```js
var xhr = new XMLHttpRequest();
xhr.open('POST', url, true);

var body = new FormData();
body.append(data);

xhr.upload.onprogress = function (e) {
  if (e.lengthComputable) {
    document.getElementById('test').innerHTML = (e.loaded / e.total * 100) + '%';
  }
};

xhr.send(body)
```


#### 同源策略

```JavaScript``` 出于安全方面的考虑，不允许跨域调用其他页面的对象

即 同协议，同端口，同域名

#### CORS

```xhr``` 不能跨越，但 ```xhr2``` 新增了跨源资源共享的能力

在服务器设置一些标头实现真正的跨域 ```ajax``` 请求 可以跨某个域的 ```http``` 标头

```js
Access-Control-Allow-Origin: *
```

可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的 ```Access-Control-Allow-Origin```，决定权始终在对方手中

假设本域是 ```my.com```，外域是 ```sina.com```，只要响应头 ```Access-Control-Allow-Origin``` 为 ```http://my.com```，或者是 ```*```，本次请求就可以成功

这种跨域请求，称之为'简单请求'。简单请求包括 ```GET```、 ```HEAD``` 和 ```POST```（```POST``` 的 ```Content-Type``` 类型，仅限 ```application/x-www-form-urlencoded```、 ```multipart/form-data``` 和 ```text/plain```），并且不能出现任何自定义头（例如， ```X-Custom: 12345``` ），通常能满足 ```90%``` 的需求

对于 ```PUT```、```DELETE``` 以及其他类型如 ```application/json``` 的 ```POST``` 请求，在发送 ```ajax``` 请求之前，浏览器会先发送一个 ```OPTIONS``` 请求（称为 ```preflighted``` 请求）到这个 ```URL``` 上，询问目标服务器是否接受：

```js
OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST
```

服务器必须响应并明确指出允许的 ```Method```：

```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400
```

浏览器确认服务器响应的 ```Access-Control-Allow-Methods``` 头确实包含将要发送的 ```ajax``` 请求的 ```Method```，才会继续发送 ```ajax```，否则，抛出一个错误


#### document.domain

对于主域相同而子域不同的例子，可以通过设置 ```document.domain``` 的办法来解决。具体的做法是可以在 ```http://www.a.com/a.htm``` l和 ```http://script.a.com/b.html``` 两个文件中分别加上 ```document.domain = 'a.com'```

#### window.name

`window` 对象有个 `name` 属性，该属性有个特征：即在一个窗口（`window`）的生命周期内,窗口载入的所有的页面都是共享一个 `window.name` 的，每个页面对 `window.name` 都有读写的权限，`window.name` 是持久存在一个窗口载入过的所有页面中的

#### jsonp

实质上和 ```xhr``` 对象没有太大关系，其是借助了 ```script``` 标签节点可以跨域去访问，去获取的一个特性

```jsonp``` 只能对 ```GET``` 请求起到效果，即 ```jsonp``` 的方式是不支持 ```POST``` 请求的，这也是 ```jsonp``` 这种方式的局限性

原理是：动态插入 `script` 标签，通过 `script` 标签引入一个 `js` 文件，这个 `js` 文件载入成功后会执行我们在 `url` 参数中指定的函数，并且会把我们需要的 `json` 数据作为参数传入

```js
// JSONP 即 json+padding（内填充，就是把 JSON 填充到一个盒子里）
function createJs(sUrl) {
  var oScript = document.createElement('script');
  oScript.type = 'text/javascript';
  oScript.src = sUrl;
  document.getElementsByTagName('head')[0].appendChild(oScript);
}

createJs('jsonp.js');

box({
  'name': 'test'
});

function box(json) {
  alert(json.name);
}
```

#### GET 与 POST 区别

* 在客户端，```GET``` 方式在通过 ```URL``` 提交数据，数据在 ```URL``` 中可以看到，```POST``` 方式，数据放在 ```HTTP``` 包的 ```body``` 中

* ```GET``` 方式提交的数据大小有限制（因为浏览器对 ```URL``` 的长度有限制），而 ```POST``` 则没有此限制

* 安全性问题，使用 ```GET``` 的时候，参数会显示在地址栏上，而 ```POST``` 不会，所以如果这些数据是中文数据而且是非敏感数据，那么使用 ```GET```，如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 ```POST``` 为好

![GETPOST](GETPOST.png)


#### xhr 的 withCredentials 属性

默认情况下，```ajax``` 跨源请求不提供凭据（```cookie```、```HTTP``` 认证及客户端 ```SSL``` 证明等），通过将设置 ```ajax``` 的 ```withCredentials``` 属性设置为 ```true```，可以指定某个请求应该发送凭据，如果服务器接收带凭据的请求，会用下面的 ```HTTP``` 头部来响应

```js
Access-Control-Allow-Credentials: true
```

需要注意：永远不会影响到同源请求

简单来说，在平常开发的时候，身份验证是经常遇到的问题，在**跨域请求**中，默认情况下是不发送验证信息的，要想发送验证信息，需要设置 ```withCredentials``` 属性

```js
var xhr = new XMLHttpRequest();

xhr.open('GET', url, true);
xhr.withCredentials = true;

xhr.send(null);
```



## IOS 移动端 click 事件 300ms 的延迟响应

移动设备上的 ```web``` 网页是有 ```300ms``` 延迟的，玩玩会造成按钮点击延迟甚至是点击失效，这是由于区分单击事件和双击屏幕缩放的历史原因造成的

双击缩放是指用手指在屏幕上快速点击两次，```iOS``` 自带的 ```Safari``` 浏览器会将网页缩放至原始比例

原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接 ```<a href="#"></a>```，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作

所以，捕获第一次单击后，浏览器会先等待一段时间 ```t```，如果在 ```t``` 时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果 ```t``` 时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作

这个 ```t``` 在 ```IOS safari``` 下，大概为 ```300``` 毫秒，这就是延迟的由来，造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于 ```web``` 开发者来说是，页面 ```js``` 捕获 ```click``` 事件的回调函数处理，需要 ```300ms``` 后才生效，也就间接导致影响其他业务逻辑的处理

一般常见的有以下几种解决方案：

* 使用 ```fastclick.js``` 库可以解决在手机上点击事件的 ```300ms``` 延迟

* ```zepto``` 的 ```touch``` 模块，```tap``` 事件也是为了解决在 ```click``` 的延迟问题

* 触摸事件的响应顺序为 ```touchstart``` --> ```touchmove``` --> ```touchend``` --> ```click```，也可以通过绑定 ```ontouchstart``` 事件，加快对事件的响应，解决 ```300ms``` 延迟问题


#### 从上面引申出来的 Zepto 点透问题

问题如下：

![点透](http://images.cnitblog.com/blog/546511/201503/011850313937285.png)

在点击弹出来的选择组件的右上角完成后会让完成后面的 ```input``` 输入框聚焦，弹出输入键盘，也就是点透了

这是因为 ```zepto``` 的 ```tap``` 是通过兼听绑定在 ```document``` 上的 ```touch``` 事件来完成 ```tap``` 事件的模拟的，及 ```tap``` 事件是冒泡到 ```document``` 上触发的

在点击完成时的 ```tap``` 事件（```touchstart/touchend```）需要冒泡到 ```document``` 上才会触发，而在冒泡到 ```document``` 之前，用户手的接触屏幕（```touchstart```）和离开屏幕（```touchend```）是会触发 ```click``` 事件的

因为 ```click``` 事件有延迟触发（就是上面的 ```300ms```，这也就是为什么移动端不用 ```click``` 而用 ```tap``` 的原因），所以在执行完 ```tap``` 事件之后，弹出来的选择组件马上就隐藏了

此时 ```click``` 事件还在延迟的 ```300ms``` 之中，当 ```300ms``` 到来的时候，```click``` 到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有 ```click``` 事件此时便会触发，如果没有绑定 ```click``` 事件的话就当没 ```click```，但是正下方的是 ```input``` 输入框（或者 ```select``` 选择框或者单选复选框等其他组件），点击默认聚焦而弹出输入键盘，也就出现了上面的点透现象

几种解决方案：

方案一：引入 ``````fastclick.js``````，因为 ``````fastclick`````` 源码不依赖其他库所以你可以在原生的 ```js``` 前直接加上

```js
window.addEventListener("load", function () {
  FastClick.attach(document.body);
}, false);
```

方案二：用 ```touchend``` 代替 ```tap``` 事件并阻止掉 ```touchend``` 的默认行为 ```preventDefault()```

```js
$("#cbFinish").on("touchend", function (event) {
  // ...
  event.preventDefault();
});
```

方案三：延迟一定的时间（```300ms+```）来处理事件

```js
$("#cbFinish").on("tap", function (event) {
  setTimeout(function () {
    // ...
  }, 320);
}); 
```   

如果实在不行，那还是用 ```click``` 吧




## JavaScript 中的命名空间，变量声明提升，作用域和预编译

#### 命名空间

`JavaScript` 中没有命名空间这个概念的，只能模拟实现，命名空间的使用可以显著减少命名冲突，并很好的组织代码，如下一个简单的示例

```js
var namespace = namespace || {};

namespace.AModule = {};
namespace.AModule.name = 'abc';
namespace.BModule = {};
```


#### 变量声明提升

声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已

定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义

```js
var a;      // 这是声明
a = 1;      // 这是定义（赋值）
var a = 1;  // 合二为一：声明变量的存在并赋值给它
```

当你以为你只做了一件事情的时候（`var a = 1`），实际上解释器把这件事情分解成了两个步骤

一个是声明（`var a`），另一个是定义（`a = 1`）

#### 两个示例

```js
var a = 1;
 
function foo () {
  if (!a) {
    var a = 2;
  }
  alert(a);
};
 
foo();  // 输出 2
```

简单的调整一下

```js
var a;
a = 1;
 
function foo() {
  var a;  // 关键在这里
  if (!a) {
    a = 2;
  }
  alert(a);  // 此时的 a 并非函数体外的那个全局变量
}

foo()
```

如代码所示，在进入函数体后解释器声明了新的变量 `a`，而无论 `if` 语句的条件如何，都将为新的变量 `a` 赋值为 `2`



#### 作用域

`JavaScript` 在 `ES6` 之前是没有块级作用域的（`Block Scoping`），只有函数作用域（`Function Scoping`）

当解析器读到 `if` 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 `Hoisting`

> `JavaScript` 只有函数作用域！

若是想要 `alert(a)` 弹出那个 `1` 则可以创建有一个新的作用域，可以使用立即执行函数

```js
var a = 1;
 
function foo() {
  // 这个就是 IIFE，它会创建一个新的函数作用域
  // 并且该作用域在 foo() 的内部，所以 alert 访问不到
  // 不过这个作用域可以访问上层作用域，这就叫：闭包
  if (!a) {
    (function() {  
      var a = 2; 
    }());               
  };
  alert(a);
};
 
foo();
```

> '请始终保持作用域内所有变量的声明放置在作用域的顶部' 不是没有道理的

因为这样可以避免 `Hoisting` 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问

但是，变量声明的提升并非 `Hoisting` 的全部

在 `JavaScript` 中，有四种方式可以让命名进入到作用域中（按优先级）

* 语言定义的命名：比如 `this` 或者 `arguments`，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 `this` 之类的，这样是没有意义的

* 形式参数：函数定义时声明的形式参数会作为变量被 `hoisting` 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

* 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

* 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的




#### 预编译

`JavaScript` 引擎并不是读一句执行一句，而是读取一段、解释执行一段，而一段一段执行，`JavaScript` 会对读取的这段 `JavaScript` 代码整体有个预处理，这个预处理就是所谓的预编译

预编译阶段，`JavaScript` 引擎会进行变量提升，这里就会涉及到变量对象

`JavaScript` 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（`Variable Object`，缩写为 `VO`）是一个抽象概念中的"对象"，它用于存储执行上下文中

1. 变量

2. 函数声明

3. 函数参数

`VO` 按照如下顺序填充：

1. 函数参数（若为传入，初始化该参数值为 `undefined`）

2. 函数声明（若发生命名冲突，会覆盖）

3. 变量声明（初始化变量值为 `undefined`，若发生命名冲突，会忽略）


看以下几个实例

```js
function foo (x, y, z) {
  function x () {};
  alert(x);   // function x () {}
}

 
foo(100);
```

在初始化阶段，先初始化函数的参数，参数 `x` 即为传进来的参数，为 `100`，但是在处理函数声明的时候，发生冲突，`x` 会被覆盖，所以返回的是一个函数对象

```js
// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略
function foo (x, y, z) {
  function fn () {};
  var fn;
  console.log(fn);    // function fn () {}
}
 
foo(100);
 
// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作
function foo (x, y, z) {
  function fn () {};
  var fn = 1;
  console.log(fn);    // 1
}
 
foo(100);
 
// 在看一个容易出错的，最终会输出 100 和 0
var num = 0;
 
function a (num) {
  num = 100;
  console.log(num);
}
 
a();
console.log(num);
```

函数表达式不会影响 `VO`，比如 `var a = function foo(){}`

这里的 `foo` 是函数表达式的名称，这个是不会记录到 `AO` 中的，这也是为什么我们不能在外部通过 `foo` 来获取到这个函数对象

## clientWidth, offsetWidth, scrollWidth

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变
 
document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变
 
document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大
 
----
 
document.body.scrollTop        // 页面滚动条向下拉动的距离
 
document.body.scrollLeft       // 页面滚动条向左拉动的距离
 
obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变
 
obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同
 
----
 
// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度
 
window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）
```

两个兼容函数

```js
// 返回视口的大小，部分移动设备浏览器对 innerWidth 的兼容性不好
// 需要使用 document.documentElement.clientWidth 或者 document.body.clientWidth 来兼容（混杂模式下对 document.documentElement.clientWidth 不支持）
// 使用方法 getViewPort().width
function getViewPort () {
  // 浏览器嗅探，混杂模式
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.clientWidth,
      height: document.body.clientHeight
    };
  } else {
    return {
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    };
  }
}


// 获得文档的大小（区别与视口），与上面类似
function getDocumentPort () {
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.scrollWidth,
      height: document.body.scrollHeight
    };
  } else {
    return {
      width: Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth),
      height: Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight)
    }
  }
}
```



## 自由变量 到 作用域链

所谓自由变量，指的是在当前作用域中未声明的变量，会去到**创建这个函数的作用域中去取值，而不是简简单单的上一级（注意，是创建，不是调用）**，这就是所谓的静态作用域

```js
var x = 100;

function foo() {
  console.log(x);
}

function bar(fn) {
  var x = 200;

  (function () {
    fn();  // 100
  })()
}

bar(foo);
```

如果没有找到，则继续往上找，一直到全局作用域为止，如果还没有找到，那就是不存在了，这个过程可以称之为**作用域链**


#### 上下文环境和作用域的关系

* 上下文环境：可以理解为一个抽象的东西，程序执行前，会生成全局上下文环境，函数在调用的时候会创建函数上下文环境

* 作用域：**除了全局作用域，只有函数才能创建作用域（ES6 之前）**，创建一个函数就创建了一个作用域，无论你调不调用，函数只要创建了，它就有独立的作用域

* 两者的区别在于：一个作用域可能没有（函数没被调用），也可能存在过（调用完成，上下文环境被摧毁），也有可能同时存在多个（闭包）上下文环境

一个简单的小例子：

```js
var x = 100;

function fn (x) {
    return function () {
        console.log(x);
    }
}

var f1 = fn(5);
var f2 = fn(10);

f1();  // 5
f2();  // 10
```





## 闭包

只需要记住应用的两种情况即可

#### 第一种 函数作为返回值

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

`bar` 函数作为返回值，赋值给 `f1` 变量，执行 `f1(15)` 时，用到了 `fn` 作用域下的 `max` 变量的值

#### 第二种 函数作为参数传递

```js
var max = 10,
  fn = function (x) {
    if (x > max) {
      console.log(x)
    }
  };

(function (f) {
  var max = 100;
  f(11);  // 11
})(fn)
```

`fn` 作为一个参数传递进入另一个函数，赋值给 `f` 参数，执行 `f(11)` 的时候，`max` 取值是 `10`，而不是 `100`

之前提到过，当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁，但是在有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁，这里指的就是闭包，以上面第一种代码为例

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

* 代码执行前的全局上下文环境，并在执行时对其中的变量进行赋值，此时全局上下文环境（活动状态）中的 `max` 为 `undefined`

* 当调用 `fn()` 时会产生 `fn()` 执行上下文环境（活动状态），此时 全局中的 `max` 仍为 `undefined`，`fn()` 上下文环境中的 `max` 为 `10`

* 当 `fn()` 调用完成，按理说应该销毁掉 `fn()` 的执行上下文环境，但是**返回的是一个函数，函数的特别之处在于可以创建一个独立的作用域**

  * 而返回的这个函数体中，还有一个自由变量 `max` 要引用 `fn` 作用域下的 `fn()` 上下文环境中的 `max`

  * 因此，这个 `max` 不能被销毁，销毁了之后 `bar` 函数中的 `max` 就找不到值了

  * 所以这里的 `fn()` 上下文环境不能被销毁，还依然存在与执行上下文栈中

* 当执行到 ```var max = 100``` 的时候，`fn()` 上下文环境依然会在执行上下文栈中，当执行完成后，全局中的 `max` 为 `100`，而 `fn()` 上下文环境中的 `max` 仍为 `10`

* 当执行最后的 `f1(5)` 的时候，即执行返回的函数 `bar(5)`，此时，`bar()` 上下文环境中的 `x` 为 `5`，而 `max` 变量是自由变量，需要向创建 `bar` 函数的作用域中查找，找到了 `max` 的值为 `10`

这里的重点就在于，创建 `bar` 函数是在执行 `fn()` 时创建的，`fn()` 早就执行结束了，但是 `fn()` 执行上下文环境还存在与栈中，因此 `bar(5)` 时，`max` 可以查找到，如果 `fn()` 上下文环境销毁了，那么 `max` 就找不到了，这也是为什么使用闭包会增加内容开销



#### 使用场景

一般有下面几种使用方式

* 给对象设置私有变量并且利用特权方法去访问私有属性

* 采用函数引用方式的 `setTimeout` 调用

* 封装相关功能集



## ES6 的一些新方法

#### let 命令

* 只要块级作用域内存在 `let` 命令，它所声明的变量就 "绑定"（`binding`）这个区域，不再受外部的影响

* `typeof` 不再是一个百分比安全的操作（如果一个变量根本没有被声明，使用 `typeof` 反而不会报错）

* `function bar(x = y, y = 2) {}` （`y` 没有声明，所以会报错）

* 不允许重复声明

* 块级作用域的出现，使得立即执行函数表达式（`IIFE`）不再必要了

* 建议避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

* 允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错

* 在 `ES6` 浏览器中（只对 `ES6` 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 `let` 处理）

 * 允许在块级作用域内声明函数

 * 函数声明类似于 `var`，即会提升到全局作用域或函数作用域的头部

 * 同时，函数声明还会提升到所在的块级作用域的头部

```js
// 不报错
"use strict";
if (true) {
  function f() { }
}

// 报错
"use strict";
if (true)
  function f() { }
```




#### const 命令

* 声明一个只读常量，一旦声明，常量的值就不能改变，而且必须立即初始化，不能留到以后在赋值

* `const foo = {};`

 * 常量 `foo` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 `foo` 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

* 与 `let` 命令相似之处：

 * 只能在声明所在的块级作用域内有效

 * 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用

 * 不可重复声明



#### 字符串的扩展

* 添加了遍历器接口，使得字符串可以被 `for...of` 循环遍历

* 添加了三个用于查询字符串位置的函数：

 * `includes()`： 返回布尔值，表示是否找到了参数字符串

 * `startsWith()`： 返回布尔值，表示参数字符串是否在源字符串的头部

 * `endsWith()`： 返回布尔值，表示参数字符串是否在源字符串的尾部

以上三个方法都支持第二个参数，表示开始搜索的位置，不同之处在于 `endsWith` 针对前 `n` 个字符，而其他两个方法针对从第 `n` 个位置直到字符串结束。

* `repeat()` 方法返回一个新字符串，表示将原字符串重复 `n` 次

 * 如果是小数，则会被取整（`2.2 => 2`, `2.9 => 2`）

 * 如果是负数（小于-1）或者 `Infinity`，则会报错

 * 如果是 `0` 到 `-1` 之间的小数，则等同于 `0`，因为会先进行取整运算（`NaN` 也等同于 `0`）

 * 如果参数是字符串，则会先转换为数字（`"3" => 3`, `"na" => ""`）

* 新增了模版字符串

```js
$("#result").append(`
    There are <b> ${basket.count} </b> items
    in your basket, <em> ${basket.onSale} </em>
    are on sale!`
);
```

 * 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义（``\`Hello\` World!``）

 * 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中

 * 如果想去掉模版字符串开头和结尾处的换行，可以使用 `trim` 方法消除它

 * 如果大括号内部是一个字符串，将会原样输出（`Hello ${"World}` => "Hello World"）

 * 模板字符串中也可以嵌入变量以及调用函数，比如 `${user.name}`，`${fn()}`




#### 对象的扩展

* 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = "bar";
var baz = {foo};
baz;  // {foo: "bar"}
```

* 方法也可以简写 `method () {return "hello"}`

* 可以用于函数的返回值：

```js
function getPoint () {
  var x = 1;
  var y = 2;
  return {x, y};
}

getPoint();  // {x: 1, y: 2}
```

* 新增属性名表达式 `obj["a" + "bc"] = 123;`

 * 表达式也可以用于定义方法名

* 属性名表达式与简洁表示法，不能同时使用，否则会报错

* 特别注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 `[object, Object]`

```js
const myObject = {
  [keyA]: "valueA",
  [keyB]: "valueB"
};

// [keyB] 会把 [keyA] 覆盖掉，而 myObject 最后只有一个 [object Object] 属性
```



#### 数值的扩展

* `parseInt()` 和 `parseFloat()` 移植到了 `Number` 对象上面 （`Number.parseInt("1*34")  // 12`）

* `Number.isInteger()` 用来判断一个值是否为整数（在 `JavaScript` 内部，整数和浮点数是同样的储存方法，所以 `3` 和 `3.0` 被视为同一个值）

`Math` 对象扩展：

* `Math.trunc()` 方法用于去除一个数的小数部分，返回整数部分

 * 对于非数值，内部会先使用 `Number` 方法将其先转为数值

 * 对于空值和无法截取整数的值，返回 `NaN`

* `Math.sign()` 方法用来判断一个数到底是正数，负数，还是零，会返回五种值：

 * 参数为正数，返回 `+1`

 * 参数为负数，返回 `-1`

 * 参数为 `0`，返回 `0`

 * 参数为 `-0`，返回 `-0`

 * 其他值，返回 `NaN`

* `Math.cbrt()` 方法用于计算一个数的立方根

* `Math.hypot()` 返回所有参数的 平方和 的 平方根 

```js 
Math.hypot(3, 4);  // 5（3 的平方 + 4 的平方 等于 5 的平方）
```




#### 数组的扩展

* `Array.from()` 将 类似数组的对象（`array-like-object`） 和 可遍历（`iterable`）的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）转为 **真正的数组**

 * 接受的第二个参数，作用类似于数组的 `map` 方法，用来对每个元素进行处理，将处理后的结果放入返回的数组

 * 如果 `Array.from()` 没有参数，就返回一个**空数组**

* `Array.of()` 用于将一组值，转换为数组（因为在 `ES5` 中，参数个数的不同，会导致 `Array()` 的行为有差异）

* `find()` 方法，用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 `true` 的成员，并返回，如果没有找到符合条件的成员，则返回 `undefined`

 * 回调函数可以接受三个参数，依次为 当前的值、当前的位置 和 原数组

* `findIndex()` 方法的用法与 `find()` 方法非常相似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 `-1`

 * `find()` 方法和 `findIndex()` 方法都可以发现 `NaN`，弥补了数组的 `indexOf` 方法的不足

* `fill()` 方法使用给定值，填充一个数组

 * 需要注意的是，数组中已有的元素，会被全部抹去

 * 可以指定第二个和第三个参数，用于指定填充的起始位置和结束位置

* 提供了三个新的方法来用于遍历数组，它们都返回一个遍历器对象，可以用 `for...of` 循环进行遍历（如果不使用 `for...of` 循环，可以手动调用遍历器对象的 `next()` 方法，进行遍历）

 * `keys()` 是对**键名**的遍历

 * `values()` 是对**键值**的遍历

 * `entries()` 是对**键值对**的遍历

* `Array.prototype.includes` 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 `includes` 方法类似

 * 第二个参数表示搜索的起始位置，默认为 `0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 `-4`，但数组长度为 `3`），则会重置为从 `0` 开始

`Map` 和 `Set` 数据结构有一个 `has` 方法，需要注意与 `includes` 区分

* `Map` 结构的 `has` 方法，是用来查找**键名**的，比如 `Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`

* `Set` 结构的 `has` 方法，是用来查找**值**的，比如 `Set.prototype.has(value)`、`WeakSet.prototype.has(value)`





#### 解构

```js
// 属于"模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值
var [a, b, c] = [1, 2, 3]
```

* 如果解构不成功，变量的值就等于 `undefined`

* 如果等号右边不是数组（不是可遍历的解构，不具有 `Iterator` 接口），那么将会报错（`number`，`string`，`false`，`NaN`，`undefined`，`null`，`{ }` 等）

* 只要某种数据具有 `Iterator` 接口，都可以采用数组形式的解构赋值

* 解构赋值允许指定默认值（内部使用的是严格相等运算符 `===`）

* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

* 对象的解构

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" }
```

* 对象的属性没有次序，变量必须与属性同名，才能取到正确的值

```js
let foo;
({ foo } = { foo: 1 }); // success

let baz;
({ bar: baz } = { bar: 1 }); // success
```

上例中的圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句




#### 字符串的解构

字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象



#### 数值和布尔值的解构

解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象

规则是，只要等号右边的值不是对象，就先将其转为对象，由于 `undefined` 和 `null` 无法转为对象，所以对它们进行解构赋值，都会报错



#### 函数相关

* 在 `ES6` 中，允许函数的参数设置默认值，即直接写在参数定义的后面（函数参数的默认值）

 * 参数变量是默认声明的，所以不能使用 `let` 或者 `const` 再次声明

 * 指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值以后，`length` 属性将失效（length属性的含义是，该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了）

* 如果设置了默认值的参数不是尾参数（即设置默认值的不是最后一个参数），那么 `length` 属性也不再计入后面的参数了

* 如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域

* 用于将一个数组转为用都好分隔的参数序列（`console.log(...[1, 2, 3])`）

* 在 ES5 中，如果将一个匿名函数赋值给一个变量，其 `name` 属性，会返回空字符串，而 ES6 中修正了这个问题，会返回实际的函数名

 * `Function` 构造函数返回的函数实例，`name` 属性的值为 `anonymous`

 * `bind` 返回的函数，`name` 属性会加上 `bound` 前缀

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 `return` 语句返回

```js
var sum = (num1, num2) => { return num1 + num2; }
```

* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号

```js
var getTempItem = id => ({ id: id, name: "Temp" });
```

* 箭头函数的使用注意点

 * 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象（例如在 `Vue` 的实例属性或回调函数中就不建议使用箭头函数，因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是对应方法未被定义）

 * 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误

 * 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `Rest` 参数代替

 * 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数

 * 需要特别注意的是：`this` 对象的指向是可变的，但是在箭头函数中，它是固定的

 * 箭头函数中的 `this` 指向的固定化，并不是因为箭头函数内部有绑定 `this` 的机制，实际原因是箭头函数根本没有自己的 `this`，导致内部的 `this` 就是外层代码块的 `this`（正式因为它没有 `this`，所以也就不能用作构造函数）



#### Symbol

`ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值，它是 `JavaScript` 第七种数据类型

```js
// 变量 s 就是一个独一无二的值
let s = Symbol();

// typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型
typeof s
// "symbol"
```








## Object.assign()

`Object.assign()` 方法可以把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象

需要注意的是

* 对于访问器属性，该方法会执行所属访问器的 `getter` 函数，然后把得到的值拷贝给目标对象

  * 如果想拷贝访问器属性本身，可以使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperties()` 方法

* 字符串类型和 `symbol` 类型的属性都会被拷贝

* 在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 `TypeError` 异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性则不会再被拷贝



#### 利用 JSON 进行忽略原型链的深拷贝

```js
var dest = JSON.parse(JSON.stringify(target));
```

同样有缺点，它会忽略掉值为 `undefuned` 的属性以及函数表达式，但不会忽略值为 `null` 的属性


#### 规避原型链属性上的拷贝

#### 使用 hasOwnProperty

```js
for (let key in targetObj) {
  if (targetObj.hasOwnProperty(key)) {
    // ...
  }
}
```

也有一些缺点，就是会遍历了原型链上所有的属性，效率不高

#### Object.keys()

```js
const keys = Object.keys(targetObj);

keys.map((key) => {
  // ...
})
```

这个需要注意的是，只会返回参数对象自身的（不含继承的）所有可遍历（`enumerable`）属性的键名所组成的数组


#### 另辟蹊径

```js
const obj = Object.create(null);
target.__proto__ = Object.create(null);

for (let key in target) {
  // 相关操作
}
```




## call 和 apply 的第一个参数

`call` 和 `apply` 用来改变函数的执行上下文（`this`），它们的第一个参数 `thisArg` 是个对象，即作为函数内的 `this`

在多数时候你传递什么给函数，那么它就是什么

```js
function fun() {
  alert(this);
}

fun.call(1);                // 1

fun.call('a');              // a

fun.call(true);             // true

fun.call({name: 'aaa'});    // [object Object]
```

有两种情况需要注意，传递 `null` 或 `undefined` 时，执行环境会是全局的（`window/global`）

可以参考[规范 15.3.4.4](http://lzw.me/pages/ecmascript/#323)

```js
fun.call(null);       // window
fun.call(undefined);  // window
```

但是在严格模式下，给 `call` 和 `apply` 传入的任何参数不再会转换

```js
'use strict'
function fun() {
  alert(this);
}

fun.call(null);        // null
fun.call(undefined);   // undefined
```

另外一个例子

```js
function foo(x, y) {
  'use strict';
  console.log(x, y, this);
}

foo.apply(null);        // undefined undefined null
foo.apply(undefined);   // undefined undefined undefined
```






































## 从请求的异步回调函数中取值的解决办法

问题如下

```js
function load_val() {
  $.get('url', function (data) {
    // 如何把这里取到的 data 通过 load_val 函数返回出去？
  });
}
```

如果通过一个全局变量来获取，自然也不是不可以，不过这里就涉及到一点：如果使用了全局变量来获取后，该怎么使用呢？

还是上面这个例子，我们稍微改造一下

```js

var obj = '';

function load_val() {
  $.get('url', function (data) {
    // 在此处将 data 赋予全局变量
    obj = data;
  });
}

// 调用函数获取数据
load_val();

function use_val() {
  obj += 1;
  console.log(obj);
}

use_val();
```

上面这个例子很好理解，我们想通过 `obj` 这个全局变量获取 `ajax` 异步过来的 `data` 数据，然后在 `use_val` 这个函数中使用 `obj` 这个变量

看似没问题，实际上问题很严重

在 `use_val()` 中的 `obj` 真的是 `data` 的值么？答案是否定的，而是 `''`

因为就这段代码而言，`obj = data` 是在 `use_val()` 执行完才在异步回调函数内实现的，在此之前，`obj`一直是 `''`

于是又有人说，那我写个延时函数，等待 `obj = data` 后再执行呗，那样就太不优雅了，那么该如何解决呢？

```js
// 定义一个回调函数
function load_val(callback) {
  $.get('url', function (data) {
    // 将返回结果当作参数通过回调函数返回
    callback(data); 
  });
}

load_val(function (data) {
  // 这里可以得到值
  obj = data; 
  use_val();
});

function use_val() {
  obj += 1;
  console.log(obj);
}
```

也就是在所需要调用的回调函数外加一个函数，这个函数包含一个参数，该参数是个函数，然而这个函数有着依赖于回调函数给出的值的参数，所以经过这两层，就能将原本回调函数里的值给取出来












## JavaScript 异步加载方案

最常见的莫过于 `defer` 与 `async`

#### defer

`HTML4` 为 `script` 标签定义了一个扩展属性 `defer`

`defer` 指明本元素所含的脚本不会修改 `dom`，因此代码能安全地延迟执行，但是该属性并不是一个理想的跨浏览器解决方案，该属性只有 `IE4+` 和 `firefox3.5+` 的浏览器支持，用法如下

```js
<script type='text/javascript' src='test.js' defer></script>
```

带有 `defer` 属性的 `script` 标签可以放置在文档的任何位置，当一个带有 `defer` 属性 `js` 文件下载时，它不会阻塞浏览器的其他进程

因此这类文件可以与页面中的其他资源并行下载，带有 `defer` 属性的 `script` 标签在 `dom` 加载完成（`onload` 事件触发前执行）

#### async 

`HTML5` 规范引入了 `async` 属性，用于异步加载脚本

```js
<script type='text/javascript' src='test.js' async></script>
```

`async` 与 `defer` 的相同点是采用并行下载，在下载的过程中不会产生阻塞，区别在于 `async` 是加载完成后自动执行，而 `defer` 需要等待页面完成后执行

#### 动态创建 script

主要原理 `javascript` 可以动态创建 `HTML` 中几乎所有的内容，所以我们可以利用 `javascript` 动态地创建 `script` 标签并添加到 `HTML` 中

```js
var script = document.createElement('script');

script.type = 'text/javasctipt';
script.src = 'file.js';

document.getElementByTagName('head')[0].appendChild(script)
```

我们可以使用如下方法跟踪并确保脚本下载完成并准备就绪

```js
function loadScript(url, callback) {

  // 创建标签
  var script = document.createElement("script");
  script.type = "text/javasctipt";

  // 如果是 IE
  if (script.readyState) {
    script.onreadystatechange = function () {
      if (script.readyState == 'loaded' || script.readyState == 'complete') {
        script.onreadystatechange = null;
        callback()
      }
    }
  } else {
    script.onload = function () {
      callback();
    }
  }

  // 赋值
  script.src = url;
  document.getElementByTagName("head")[0].appendChild(script)
}
```

调用方法

```js
loadScript('files.js',function(){
  console.log(`file is loaded`);
})
```

#### XMLHttpRequest 脚本注入

还可以通过 `XHR` 对象获取脚本并注入到页面

```js
// 获取 XMLHttpRequest 对象（考虑兼容性）
var getXmlHttp = function () {
  var obj;
  if (window.XMLHttpRequest)
    obj = new XMLHttpRequest();
  else
    obj = new ActiveXObject('Microsoft.XMLHTTP');
  return obj;
};

// 采用 Http 请求 get 方式，open() 方法的第三个参数表示采用异步（true）还是同步（false）来进行处理
var xmlHttp = getXmlHttp();
xmlHttp.open('GET', 'file3.js', true);

xmlHttp.onreadystatechange = function () {
  if (xmlHttp.readyState == 4) {
    if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 304) {
      var script = document.createElement('script');
      script.text = xmlHttp.responseText;
      document.body.appendChild(script);
    }
  }
}

xmlHttp.send(null);
```







## 简易事件模型

简单来说就是一个定顺序触发相应的响应函数

大致实现思路就是创建一个类或是匿名函数，在 `bind` 和 `trigger` 函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表

`bind` 时，如果字典没有则创建一个，`key` 是事件名称，`value` 是数组，里面放着当前注册的响应函数

如果字段中有，那么就直接 `push` 到数组即可，`trigger` 时调出来依次触发事件响应函数即可

不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用 `trigger` 的参数列表都传到响应函数中还要考虑到把 `arguments` 对象转化为纯数组才行等等


```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName];

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例
var emitter = new Emitter();

emitter.on('event', function (arg1, arg2) {
  console.log('get event', arg1, arg2);
})

console.log('emit event');
emitter.emit('event', 'arg1', 'arg2');
```




## 关于 'use strict'

严格模式是 `ECMAScript 5` 中的一项新特征，允许你把一段程序或功能放置在 `'strict'` 工作环境中，这种严格上下文环境防止某些行为被采取并引发更多的异常

严格的模式有助于几个方面

* 它捕获了一些常见的编码错误，抛出异常

* 它阻止，或抛出错误，当相对'不安全'的行为被采用（例如获取全局对象）

* 它禁用那些混淆的或者考虑不周的特征

```js
// 非严格的代码...

(function () {
  'use strict';

  // 严格定义你的库...
})();

// 非严格的代码
```



## 检测是否有元素被隐藏

```js
// 检查 display: [none | block], 忽略 visible: [true | false]
$(element).is(":visible");

// 匹配的是隐藏的所有元素
$('element:hidden')

// 匹配所有可见的元素
$('element:visible')
```



## 鼠标长按事件

只要长按时间到达 `1000` 毫秒，无论是否弹起鼠标，都会触发，反之如果不到 `1000` 毫秒，鼠标弹起的时候会结束

```js
// 申明全局变量
var timeStart, timeEnd, time;

// 获取此刻时间
function getTimeNow() {
  var now = new Date();
  return now.getTime();
}

// 鼠标按下时触发
function holdDown() {
  // 获取鼠标按下时的时间
  timeStart = getTimeNow();

  // setInterval 会每 100 毫秒执行一次，也就是每 100 毫秒获取一次时间
  time = setInterval(function () {
    timeEnd = getTimeNow();

    // 如果此时检测到的时间与第一次获取的时间差有 1000 毫秒
    if (timeEnd - timeStart > 1000) {
      // 便不再继续重复此函数 （clearInterval 取消周期性执行）
      clearInterval(time);
      // 字体变红
      // 一些逻辑
    }
  }, 100);
}

function holdUp() {
  // 如果按下时间不到 1000 毫秒便弹起
  clearInterval(time);
}
```



## 如何快速判断 DOM 元素位于 viewport 以外

```js
ele.getBoundingClientRect().top > window.innerHeight  // 元素在当前屏下面

ele.getBoundingClientRect().bottom < 0                // 元素在当前屏上面
```





## 检测对象改变的几种方式

方法一，可以通过 getter 和 setter 实现

```js
var obj = {
  get foo() {
    console.log({ name: 'foo', object: obj, type: 'get' });
    return obj._foo;
  },
  set bar(val) {
    console.log({ name: 'bar', object: obj, type: 'set', oldValue: obj._bar });
    return obj._bar = val;
  }
};

obj.bar = 2;
// {name: "bar", object: {_bar: 2}, type: "set", oldValue: undefined}

obj.foo;
// {name: "foo", object: <_bar: 2>, type: 'get'}
```

方法二，在支持 Proxies（代理）的浏览器中更为通用的方法

```js
var obj = {
  foo: 1,
  bar: 2
}

var proxied = new Proxy(obj, {
  get: function (target, prop) {
    console.log({ type: 'get', target, prop });
    return Reflect.get(target, prop);
  },
  set: function (target, prop, value) {
    console.log({ type: 'set', target, prop, value });
    return Reflect.set(target, prop, value);
  }
})

proxied.bar = 2;
// {type: "set", target: { foo: 1, bar: 2 }, prop: "bar", value: 2}

proxied.foo;
// {type: "get", target: { foo: 1, bar: 2 }, prop: "foo"}
```

方法三，使用 Object.defineProperties

```js
var obj = Object.defineProperties({}, {
  'foo': {
    get: function () {
      console.log('Get Foo: ' + this.value);
    },
    set: function (val) {
      console.log('Set Foo: ' + val);
      this.value = val;
    }
  },

  'bar': {
    get: function () {
      console.log('Get Bar: ' + this.value);
    },
    set: function (val) {
      console.log('Set Bar: ' + val);
      this.value = val;
    }
  }
});

obj.foo = 2;
// Set Foo: 2

obj.bar;
// Get Bar: undefined
```












## Property 'style' does not exist on type 'Element'

这个问题一般会在 `TS` 当中使用 `document.querySelector` 去获取元素的时候发生

根据规范可知（[MDN Element 规范](https://developer.mozilla.org/en-US/docs/Web/API/Element)），`Element` 接口确实没有 `style` 属性

如果不是用来操作 `SVG` 元素，而是仅仅使用 `TS` 的话，可以像下面这样操作

```js
(document.querySelector('xxx') as HTMLElement).style.color = 'red';
```





## table 表单中的 .rows 属性

如下

```js
var tr = cartTable.children[1].rows;
```

为表单元素特有的属性，存放节点所有的 `tr` 元素，操作的话可以使用如下方式

```js
price += tr[i].cells[4].innerHTML
```

> `cells` 也是 表单元素特有的属性，里面存放的是这个表格没一行下面的所有的单元格，也就是 `td` 元素，也就是说这一行下面所有的 `td`





## offsetLeft 与 style.left 的区别

`offsetLeft` 获取的是相对于父对象的左边距

`left` 获取或设置相对于 具有定位属性（`position` 定义为 `relative`）的父对象的左边距

如果父 `div` 的 `position` 定义为 `relative`，子 `div` 的 `position` 定义为 `absolute`

那么子 `div` 的 `style.left` 的值是相对于父 `div` 的值，这同 `offsetLeft` 是相同的，区别在于

* `style.left` 返回的是字符串，如 `28px`，`offsetLeft` 返回的是数值 `28`，如果需要对取得的值进行计算，还用 `offsetLeft` 比较方便

* `style.left` 是读写的，`offsetLeft` 是只读的，所以要改变 `div` 的位置，只能修改 `style.left`

* `style.left` 的值需要事先定义，否则取到的值为空，而且必须要定义在 `html` 里,如果定义在 `css` 里，`style.left` 的值仍然为空

`offsetLeft` 则仍然能够取到，无需事先定义 `div` 的位置



## Reflect 对象

`Reflect` 对象与 `Proxy` 对象一样，也是 `ES6` 为了操作对象而提供的新 `API`

简单来说两点，一个就是将 `Object` 对象的一些明显属于语言内部的方法（比如 `Object.defineProperty`），放到 `Reflect` 对象上

另一个就是让 `Object` 操作都变成函数行为，因为 `ES5` 很多 `Object` 操作都是命令式的（另外一个原因就是这些方法可能是全局的，或者要通过原型来调用，统一起来）

这里只简单的介绍几个常用的方法，详细的可见 [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/reflect) 和 [Reflect - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)


#### Reflect.apply(target, thisArgument, argumentsList)

与 `ES5` 的 `Function.prototype.apply` 方法是类似的

比如查找数组中最大数

```js
// ES6 
Reflect.apply(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5

// ES5
Math.max.apply(undefined, [1, 2, 3, 4, 5]);  // 5

Function.prototype.apply.call(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5
```

切割字符串

```js
// ES6 
Reflect.apply(String.prototype.slice, 'hello world', [2, 8]);  // "llo wo"

// ES5 
'hello world'.slice(2, 8);  // "llo wo"

String.prototype.slice.apply('hello world', [2, 8]);  // "llo wo"
```



#### Reflect.construct(target, argumentsList[, newTarget])

与使用 ·new target(...args)· 方法类似，相当于提供了一种新的不使用 ·new· 来调用构造函数的方法

* `target` 表示被运行的目标函数

* `argumentsList` 调用构造函数传递的参数数组或者伪数组

* `newTarget` 参数为构造函数，表示使用 `Reflect.construct` 后生成的对象是谁的实例

* 如果没有传递第三个参数，默认和 `target` 一样

如果没有传递第三个参数，那么 `target` 就是唯一的构造函数，但是如果传递了第三个参数，那就表示实例将由两部分组成，实力的属性部分（constructor）由第一个参数部分生成，实例的方法部分由第三个参数生成

```js
class A1 {
  constructor(name) {
    console.log('Class A1 is invoked!');
    this.name = name;
  }
  getName() {
    console.log(this.name);
    return this.name;
  }
}

class B1 {
  constructor(age) {
    console.log('Class B1 is invoked!');
    this.age = age;
  }
  getAge() {
    console.log(this.age);
    return this.age;
  }
}

// 使用 A1 类作为构造函数
let a1 = Reflect.construct(A1, ['happy']);

// 使用 B1 类作为构造函数
let b1 = Reflect.construct(A1, ['happy'], B1);

console.log(a1);
console.log(b1);

// A1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class A1
//     getName: ƒ getName()
//     __proto__: Object

// B1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class B1
//     getAge: ƒ getAge()
//     __proto__: Object
```



#### Reflect.defineProperty(target, propertyKey, attributes)

与 `Object.defineProperty` 相似，不过如果 `Object.defineProperty` 的属性定义失败了，就会抛出一个错误，而 `Reflect.defineProperty` 如果定义属性失败的话就会返回 `false`

```js
let obj = {};

let result = Reflect.defineProperty(obj, 'name', {
  configurable: true,
  enumerable: true,
  value: 'happy'
});

console.log(result)  // true
```



#### Reflect.getPrototypeOf(target)

与 `Object.getPrototypeOf` 方法是一样的，都是返回一个对象的原型，也就是内部的 `[[Prototype]]` 属性的值

如果要获取原型的那个值不是一个对象，那么函数 `Reflect.getPrototypeOf` 会抛出一个异常

对于给定对象的原型，如果没有继承的属性，则返回 `null`



#### Reflect.ownKeys(target)

返回由目标对象自身的属性键组成的数组，包括 `symbol` 的值

```js
let a = Symbol.for('a');
let b = Symbol.for('b');

let obj = {
  [a]: 10,
  [b]: 20,
  key1: 30,
  key2: 40
};

let arr1 = Object.getOwnPropertyNames(obj);
console.log(arr1); // [ 'key1', 'key2' ]

let arr2 = Object.getOwnPropertySymbols(obj);
console.log(arr2); // [ Symbol(a), Symbol(b) ]

let arr3 = Reflect.ownKeys(obj);
console.log(arr3); // [ 'key1', 'key2', Symbol(a), Symbol(b) ]
```














## 如何判断鼠标滚动方向和绑定鼠标滚轮事件

#### 绑定鼠标滚轮事件

`js` 事件有很多需要兼容的地方，鼠标滚轮事件也有额外的差异吗，包括 `IE6` 浏览器在内的都适用 `mouseWheel`，而只有火狐浏览器使用`DOMMouseScroll`

#### 如何判断鼠标滚动方向

其他浏览器通过 `wheeldalta` 属性来判断，但是火狐浏览器没有这个属性，可以通过`detal`这个属性来判断

开发中发现每次向下滚动的时候，`wheeldalta`都是`-120`，但是`detail`却是`3`，火狐浏览器方向判断的数值正负与其他浏览器是相反的

```js
div.on('mousewheel DOMMouseScroll', function(e){
  var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail;
  // do someing
});
```

关于火狐浏览器： [firefox的event.detail](https://segmentfault.com/q/1010000003986369)


## JavaScript 判断滚动条方向

```js
$(document).ready(function () {

  // 设置参照物与比较物
  var p = 0,t = 0;

  $(window).scroll(function (e) {

    // 默认相对滚动条顶部的偏移
    p = $(this).scrollTop();
    
    // 下滚
    if( t <= p ){  
      $('.header').hide();
    }
                
    // 上滚
    else{  
      $('.header').show();
    }

    // 关于这句的解释 见下方
    setTimeout(function(){t = p;}, 0);    
  });

});
```


## setTimeout(function(){}, 0) 

`JavaScript` 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 "阻塞式执行"

假如当前 `JavaScript` 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行

如果代码中设定了一个 `setTimeout` 那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 `0`，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕，所以 `setTimeout` 并不能保证执行的时间，是否及时执行取决于 `JavaScript` 线程是拥挤还是空闲

更多见 [JavaScript 下的 setTimeout(fn, 0) 意味着什么？](http://www.cnblogs.com/silin6/p/4333999.html)

## 为什么 0.2 + 0.1 === 0.3 返回 false

在展开这个问题之前，我们需要先了解计算机内部是如何表示数的

在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数

看下面两个例子

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|13|	10|	13|	1x10^1 + 3x10^0 = 10 + 3|
|13|	2	|1101|	1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1|
|上面是整数，下面则是小数||||
|0.625|	10|	0.625|	6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005|
|0.625|	2|	0.101|	1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8|

简单来说

* 十进制整数转二进制方法 -- 除 `2` 取余

* 十进制小数转二进制方法 -- 乘 `2` 除整

在这里就不得不提 `0.1` 这个比较特殊的小数了，`0.1` 的二进制格式是 `0.0001100011....`

这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数

这里就会存在一个**在某个精度点直接舍弃**的操作，当然，代价就是，`0.1` 在计算机内部根本就不是精确的 `0.1`，而是一个有舍入误差的 `0.1`

当代码被编译或解释后，`0.1` 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 `0.1 + 0.2` 不等于 `0.3` 的原因

这里就会引申出另外一个问题，如下

#### 为什么 0.1 + 0.1 却等于 0.2

结果是，两个有舍入误差的值在求和时，相互抵消了，但这种 "负负得正，相互抵消" 不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消

另一个需要注意的是，二进制能精确地表示位数有限且分母是 `2` 的倍数的小数，比如 `0.5`，`0.5` 在计算机内部就没有舍入误差，所以 `0.5 + 0.5 === 1`

在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在

虽然允许误差存在，但是**永远不要直接比较两个浮点的大小**

一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差

如果非要计算一些浮点数，可以采用第三方库，比如 [bignumber](https://github.com/MikeMcl/bignumber.js) 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望

```js
{
  let x = new BigNumber(0.1);
  let y = new BigNumber(0.2)
  let z = new BigNumber(0.3)

  console.log(z.equals(x.add(y)))   // 0.3 === 0.1 + 0.2, true
  console.log(z.minus(x).equals(y)) // true
  console.log(z.minus(y).equals(x)) // true
}

{
  let x = 0.2
  console.log(x * x === 0.04) // false
  let y = new BigNumber(0.2)
  let r = y.mul(y)            // 0.04
  console.log(r.equals(new BigNumber(0.04))) // true
}
```


#### 小小总结

* 为什么 `0.1 + 0.2` 不等于 `0.3`，因为计算机不能精确表示 `0.1`， `0.2` 这样的浮点数，计算时使用的是带有舍入误差的数

* 并不是所有的浮点数在计算机内部都存在舍入误差，比如 `0.5` 就没有舍入误差

* 具有舍入误差的运算结可能会符合我们的期望，原因可能是 "负负得正"

* 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 `bignumber.js` 这样的浮点数运算库

