


## 使用 new 的时候发生了什么

----

使用 ```new``` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作

1. 创建（或者说构造）一个全新的对象，可以简单的理解为一个空对象 `{}`

2. 这个新对象会被执行 [[原型]] 连接

3. 这个新对象会绑定到函数调用的 ```this```（简单来说就是将自己的上下文设置为这个 `{}`，即 this 表示为这个对象）

4. 如果函数没有返回其他对象，那么 ```new``` 表达式中的函数调用会自动返回这个新对象

```js
function foo(a) {
    this.a = a;
}
 
var bar = new foo(2);
console.log(bar.a); // 2
```

使用 ```new``` 来调用 ```foo(..)``` 时，我们会构造一个新对象并把它绑定到 ```foo(..)``` 调用中的 ```this``` 上


#### 关于函数的返回值

如果一个构造函数不写 `return` 语句，则系统会自动帮你返回一个对象，但是如果写了 `return` 语句，则

* 如果 `return` 的是一个基本类型的值（比如 `string`，`number`），则会忽略这个 `return`，该返回什么还是返回什么，但是会阻止构造函数接下来的执行

* 如果 `return` 了一个引用类型，则原有的 `return` 会被覆盖





## 浏览器中的各种长度

#### JavaScript

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变

document.body.clientHeight     // 返回对象内容的可视区的高度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变

document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变

document.body.offsetHeight     // 对象整体的实际高度（包括边框和填充），会随对象显示大小的变化而改变

document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大

document.body.scrollHeight     // 对象的实际内容的高度（不包括边线宽度），会随对象中内容超过可视区后而变大

----

document.body.scrollTop        // 页面滚动条向下拉动的距离

document.body.scrollLeft       // 页面滚动条向左拉动的距离

obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变

obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同

----

// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度

window.screen.height           // 屏幕分辨率的高度

window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）

window.screen.availHeight      // 显示器工作区高度（除去任务栏的距离）
```



#### jQuery

```js
width();                       // 设置或返回被选元素的宽度
 
height();                      // 设置或返回被选元素的高度

$(window).height()             // 浏览器当前窗口可视区域高度

$(document).height()           // 浏览器当前窗口文档对象高度也就是页面整体高度

$(document.body).width()       // 浏览器当前窗口文档 body 的宽度
 
$(window).scrollTop()          // 垂直滚动的距离 即当前滚动的地方的窗口顶端到整个页面顶端的距离
                               // 与 $(document).scrollTop() 一致，但是 $(window).scrollTop() 被所有浏览器支持
 
$(window).scrollLeft()         // 这是获取水平滚动条的距离

----

// 返回偏移坐标
$(selector).offset();

top: $(selector).offset().top;

left: $(selector).offset().left;

----

// 两个用的较少的方法 
$(document.body).outerHeight(true)   // 浏览器当前窗口文档 body 的总高度 包括 border padding margin（对可见和隐藏元素均有效）

$(document.body).outerWidth(true)    // 浏览器当前窗口文档 body 的总宽度 包括 border padding margin（对可见和隐藏元素均有效）
```




#### 一些比较常用的方法

#### 可视区高度

获取元素到浏览器顶端的距离，根据页面滚动，这个值是一直在变化的

```js
obj.offsetTop - document.body.scrollTop
```


#### 判断页面是否在顶部

```js
document.body.scrollTop == 0
```

#### 判断页面是否在底部

```js
$(document).height() == $(window).height() + $(window).scrollTop()

即

$(window).scrollTop() >= $(document).height() - $(window).height()
```


#### innerHeight(value)

![img](https://raw.githubusercontent.com/heptaluan/blog/master/essay/js/innerheight.jpg)

```js
innerHeight  // 高度＋补白

outerHeight  // 高度＋补白＋边框，参数为 true 时为 高度＋补白＋边框＋边距
```

`value` 参数可以是一个字符串（数字加单位）或者是一个数字，如果这个 `value` 参数只提供一个数字，`jQuery` 会自动加上像素单位（`px`）

如果只提供一个字符串，任何有效的 `CSS` 尺寸都可以为高度赋值（就像 `100px`，`50%`，或者 `auto`）

注意在现代浏览器中，`CSS` 高度属性不包含 `padding`，`border` 或者 `margin`， 除非 `box-sizing` 属性被应用



#### 兼容问题

`document.body.scrollTop` 有兼容问题，可以使用

```js
var top = document.body.scrollTop || document.documentElement.scrollTop;
```



#### scrollWidth，clientWidth 和 offsetWidth 区别

分为两种情况

#### 第一种情况

元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下

* `scrollWidth = clientWidth`，两者皆为内容可视区的宽度

* `offsetWidth` 为元素的实际宽度

![img](http://images.cnitblog.com/blog/166781/201412/291654504031651.png)

#### 第二种情况

元素的内容超过可视区，滚动条出现和可用的情况下

* `scrollWidth > clientWidth`

* `scrollWidth` 为实际内容的宽度

* `clientWidth` 是内容可视区的宽度

* `offsetWidth` 是元素的实际宽度

![img](http://images.cnitblog.com/blog/166781/201412/291655026226285.png)



#### Event 对象的五种坐标


```js
clientX 和 clientY    // 相对于浏览器（可视区，左上角0，0）的坐标

screenX 和 screenY    // 相对于设备屏幕左上角（0，0）的坐标

offsetX 和 offsetY    // 相对于事件源左上角（0，0）的坐标
 
pageX 和 pageY        // 相对于整个网页左上角（0，0）的坐标，但它不会随着滚动条而变动

X 和 Y                // 本来是 IE 属性，相对于用 CSS 动态定位的最内层包容元素
```




## parseInt

使用的时候建议始终添加**第二个参数**来指定进制，比如

```js
parseInt(123, 10)  // 返回 123
```

#### 如果是整数，返回其本身

```js
parseInt(123, 10)  // 返回 123
```

#### 如果是浮点数，返回整数部分

```js
parseInt(123.123, 10)   // 返回 123
```


#### 如果是字符串

* 如果字符串第一个非空字符前面含有空格，则忽略空格，直接从第一个非空字符开始解析

```js
parseInt(" 1234", 10)   // 返回 1234
```

* 如果第一个非空字符不是数字或者符号，则返回 ```NaN```

```js
parseInt("df2bc", 10)  // 返回 NaN
```

* 如果第一个非空字符是数字，则继续解析直至解析完毕或者**遇到第一个非数字符号**为止

```js
parseInt("123abc", 10)  // 返回 123
```



## sessionStorage，localStorage 和 cookie 的区别

`sessionStorage`、`localStorage`、`cookie` 都是在浏览器端存储的数据

其中 `sessionStorage` 的概念很特别，引入了一个 "浏览器窗口" 的概念，`sessionStorage` 是在同源的同窗口（或 `tab`）中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在

关闭窗口后，`sessionStorage` 即被销毁，同时 "独立" 打开的不同窗口，即使是同一页面，`sessionStorage` 对象也是不同的

----

**两者的共同点**：都是保存在浏览器端，且同源的

**区别如下**：

* `cookie` 数据始终在同源的 `http` 请求中携带（即使不需要），即 `cookie` 在浏览器和服务器间来回传递，而 `sessionStorage` 和 `localStorage` 不会自动把数据发给服务器，仅在本地保存

* `cookie` 数据还有路径（`path`）的概念，可以限制 `cookie` 只属于某个路径下，存储大小限制也不同，`cookie` 数据不能超过 4k，同时因为每次 `http` 请求都会携带 `cookie`，所以 `cookie` 只适合保存很小的数据，如会话标识，`sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比 `cookie` 大得多，可以达到 5M 或更大，数据有效期不同

* `sessionStorage`：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持

* `localStorage`：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

* `cookie` 只在设置的 `cookie` 过期时间之前一直有效，即使窗口或浏览器关闭，作用域不同，`sessionStorage` 不在不同的浏览器窗口中共享，即使是同一个页面

* `localStorage` 在所有同源窗口中都是共享的

* `cookie` 也是在所有同源窗口中都是共享的，`Web Storage` 支持事件通知机制，可以将数据更新的通知发送给监听者，`Web Storage` 的 `api` 接口使用更方便



## call 和 apply 哪个速度更快一些

通常来说，`call` 是要比 `apply` 快一些的，至于为什么，这就要看它们在被调用之后发生了什么

#### Function.prototype.apply (thisArg, argArray)

1. 如果 `IsCallable（Function）` 为 `false`，即 `Function` 不可以被调用，则抛出一个 `TypeError` 异常

2. 如果 `argArray` 为 `null` 或未定义，则返回调用 `Function` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 和一个空数组作为参数

3. 如果 `Type（argArray）` 不是 `Object`，则抛出 `TypeError` 异常

4. 获取 `argArray` 的长度，调用 `argArray` 的 `[[Get]]` 内部方法，找到属性 `length`， 赋值给 `len`

5. 定义 `n` 为 `ToUint32（len）`

6. 初始化 `argList` 为一个空列表

7. 初始化 `index` 为 `0`

8. 循环迭代取出 `argArray`，重复循环 `while（index < n）`

  * 将下标转换成 `String` 类型，初始化 `indexName` 为 `ToString(index)`

  * 定义 `nextArg` 为 使用 `indexName` 作为参数调用 `argArray` 的 `[[Get]]` 内部方法的结果

  * 将 `nextArg` 添加到 `argList` 中，作为最后一个元素

  * 设置 `index ＝ index＋1`

9. 返回调用 `Function` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 作为该值，`argList` 作为参数列表


#### Function.prototype.call (thisArg [ , arg1 [ , arg2, .. ] ] )

* 如果 `IsCallable（Function）` 为 `false`，即 `Function` 不可以被调用，则抛出一个 `TypeError` 异常

* 定义 `argList` 为一个空列表

* 如果使用超过一个参数调用此方法，则以从 `arg1` 开始的从左到右的顺序将每个参数附加为 `argList` 的最后一个元素

* 返回调用 `func` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 作为该值，`argList` 作为参数列表


#### 总结

由于 `apply` 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤 `8` 中所示）， 同时也有一些对参数的检查（步骤 `2`），而在 `call` 中却是不必要的

另外在 `apply` 中不管有多少个参数，都会执行循环，也就是步骤 `6 - 8`，而在 `call` 中也就是对应步骤 `3` ，是有需要才会被执行



## JavaScript 中的事件模型

简单来说，即一个类或是一个模块，有两个函数，一个 `bind` 一个 `trigger`，分别实现绑定事件和触发事件

核心需求就是可以对某一个事件名称绑定多个事件响应函数，然后触发这个事件名称时，依次按绑定顺序触发相应的响应函数

```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName];

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例对象
var emitter = new Emitter();

emitter.on("event2", function (arg1, arg2) {
  console.log("get event2", arg1, arg2);
})

emitter.on("event1", function (arg1, arg2) {
  console.log("get event1", arg1, arg2);
})

console.log("emit event");

emitter.emit("event2", "arg1", "arg2");
emitter.emit("event1", "arg1", "arg2");
```

也可以使用 `WeakMap`，原理是一样的

```js
var listeners = new WeakMap();

// 监听事件
function on(object, event, fn) {
  var _listeners = listeners.get(object) || {};
  if (!_listeners[event]) _listeners[event] = [];
  _listeners[event].push(fn);
  listeners.set(object, _listeners);
}

// 触发事件
function emit(object, event) {
  var _listeners = listeners.get(object) || {};
  if (!_listeners[event]) _listeners[event] = [];
  _listeners[event].forEach(function (fn) {
    fn.call(object, event);
  });
}

// 使用
var obj = {};
on(obj, 'hello', function () {
  console.log('hello');
});

emit(obj, 'hello');


```



## JavaScript 中常用的设计模式

#### 单例模式

简单来说，任意对象都是单例，无须特别处理

```js
var obj = { name: "zhangsan", age: 20 };
```

一个通用的惰性单例

```js
var getSingle = function (fn) {
  var result;
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}
```


#### 工厂模式

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型

```js
var Car = (function () {
  var Car = function (name, age) {
    this.name = name;
    this.age = age;
  };
  return function (name, age) {
    return new Car(name, age);
  };
})();


var zhangsan = new Car("zhangsan", 20);
var lisi = new Car("lisi", 22);
```

即

```js
var productManager = {};

productManager.createProductA = function () {
  console.log('ProductA');
}

productManager.createProductB = function () {
  console.log('ProductB');
}

productManager.factory = function (typeType) {
  return new productManager[typeType];
}

productManager.factory('createProductA');
```


#### 代理模式

简单来说，就是新建个类调用老类的接口，包装一下

```js
function Person() { }

Person.prototype.sayName = function () {
  console.log('zhangsan');
}

Person.prototype.sayAge = function () {
  console.log(20);
}

function PersonProxy() {

  this.person = new Person();
  var that = this;

  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName);
    // 代理
    that.person[functionName]();
    console.log('after proxy:', functionName);
  }

}

var p = new PersonProxy();

p.callMethod('sayName');  // 代理调用 Person 的方法 sayName()
p.callMethod('sayAge');  // 代理调用 Person 的方法 sayAge()
```


#### 观察者模式

简单来说就是事件模式，比如按钮的 `onclick` 的应用

```js
function Publisher() {
  this.listeners = [];
}

// 发布者
Publisher.prototype = {

  'addListener': function (listener) {
    this.listeners.push(listener);
  },

  'removeListener': function (listener) {
    delete this.listeners[listener];
  },

  'notify': function (obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  }

};

function Subscriber() { }

// 订阅者
Subscriber.prototype = {
  'process': function (obj) {
    console.log(obj);
  }
};

var publisher = new Publisher();

publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());

// 发布一个对象到所有订阅者
publisher.notify({ name: 'zhangsan', ageo: 30 });

// 发布一个字符串到所有订阅者
publisher.notify('2 subscribers will both perform process');
```



## 常见函数 once/bind/debouce/throttle 的实现原理

#### once

原理是利用闭包的特性，传递参数，执行完一次以后就自动解除绑定

```js
function once(dom, event, callback) {
  var handle = function () {
    callback();
    dom.removeEventListener(event, handle);
  }
  dom.addEventListener(event, handle)
}
```

第二种方式

```js
const once = (fn) => {
  let done = false;
  return function () {
    done ? undefined : ((done = true), fn.apply(this, arguments));
  }
}

const test = once(() => {
  console.log(`test`);
})

test();  // test
test();  // undefined
```

#### bind

简单的实现方式为

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function () {
    var self = this,                        // 保存原函数
      context = [].shift.call(arguments),   // 保存需要绑定的 this 上下文
      args = [].slice.call(arguments);      // 剩余的参数转为数组
    return function () {                    // 返回一个新函数
      self.apply(context, [].concat.call(args, [].slice.call(arguments)));
    }
  }
}
```

`MDN` 上 `bind` 的实现为下面这种

```js
if (!Function.prototype.bind) {

  Function.prototype.bind = function (oThis) {

    if (typeof this !== "function") {
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP
          ? this
          : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;

  };
}
```


#### debounce

在某些场景下，比如拖拽（```mousemove```），窗口大小调整（```resize```）等事件，触发频率比较高，若稍处理函数很复杂的话，就需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，导致假死或者卡顿感

这种情况下就出现了函数节流（```throttle```），和其类似的就是 ```debounce``` 函数，这两个函数的目的都是为了解决上述问题

#### 原理

比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 ```throttle``` 和 ```debounce``` ，超时设定为 ```15``` 秒，不考虑容量限制

* ```throttle``` 策略的电梯，保证如果电梯第一个人进来后，```15``` 秒后准时运送一次，不等待，如果没有人，则待机

* ```debounce``` 策略的电梯，如果电梯里有人进来，等待 ```15``` 秒，如果有人进来，```15``` 秒等待重新计时，直到 ```15``` 秒超时，开始运送

#### debounce

```js
// 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 time，handle 才会执行
// debounce(time, handle)
var debounce = function (time, handle) {
  var last
  return function () {
    var ctx = this, args = arguments
    clearTimeout(last)
    last = setTimeout(function () {
      handle.apply(ctx, args)
    }, time)
  }
}
```


#### throttle

```js
// 频率控制 返回函数连续调用时，handle 执行频率限定为 次/time
// throttle(time, handle)

var throttle = function (time, handle) {
  var last = 0;
  return function () {
    var curr = +new Date();
    if (curr - last > time) {
      handle.apply(this, arguments)
    }
    last = curr;
  }
}
```



## 拖拽功能

#### PC 端拖拽功能

```js
var div = document.getElementById('div');

div.onmousedown = function (e) {
  var e = e || event;
  var disX = e.clientX - div.offsetLeft;
  var disY = e.clientY - div.offsetTop;

  document.onmousemove = function (e) {
    var e = e || event;
    div.style.left = e.clientX - disX + 'px';
    div.style.top = e.clientY - disY + 'px';
  }

  document.onmouseup = function () {
    document.onmousemove = null;
    document.onmouseup = null;
  }
}
```

#### 面向对象版本

```js
window.onload = function () {
  new Drag('div1');
  new Drag('div2');
};

function Drag(id) {
  var disX = 0;
  var disY = 0;
  var _this = this;

  this.oDiv = document.getElementById(id);
  this.oDiv.onmousedown = function (ev) {
    _this.fnDown(ev);

    return false;
  };
}

Drag.prototype.fnDown = function (ev) {
  var oEvent = ev || event;
  var _this = this;

  this.disX = oEvent.clientX - this.oDiv.offsetLeft;
  this.disY = oEvent.clientY - this.oDiv.offsetTop;

  document.onmousemove = function (ev) {
    _this.fnMove(ev);
  };

  document.onmouseup = function () {
    _this.fnUp();
  };
}

Drag.prototype.fnMove = function (ev) {
  var oEvent = ev || event;
  this.oDiv.style.left = oEvent.clientX - this.disX + 'px';
  this.oDiv.style.top = oEvent.clientY - this.disY + 'px';
}

Drag.prototype.fnUp = function () {
  document.onmousemove = null;
  document.onmouseup = null;
}
```

#### 移动端拖拽功能

与 ```PC``` 端实现类似，只是事件不太一样，一般用到的事件如下：

```js
touchstart:       // 手指放到屏幕上时触发

touchmove:        // 手指在屏幕上滑动式触发

touchend:         // 手指离开屏幕时触发


// 每个触摸事件被触发后，会生成一个 event 对象，event 对象里额外包括以下三个触摸列表:

touches:          // 当前屏幕上所有手指的列表

targetTouches:    // 当前 dom 元素上手指的列表，尽量使用这个代替 touches

changedTouches:   // 涉及当前事件的手指的列表，尽量使用这个代替 touches
```

```js
var div = document.getElementById('div');
var disX, disY;

div.addEventListener('touchstart', function (e) {
  var touches = e.targetTouches[0];
  disX = touches.clientX - div.offsetLeft;
  disY = touches.clientY - div.offsetTop;

  document.addEventListener('touchmove', function (e) {
    var touches = e.targetTouches[0];
    div.style.left = touches.clientX - disX + 'px';
    div.style.top = touches.clientY - disY + 'px';
  })

  document.addEventListener('touchend', function () {
    document.removeEventListener('touchmove', false)
  })

}, false);
```


## 如何监听 对象/数组 属性改变

#### 监听对象属性改变

在 ```ES5``` 中新增了一个 ```Object.defineProperty``` 的方法，可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象

```js
Object.defineProperty(obj, prop, descriptor)
```

其接受的第三个参数可以取 ```get/set``` 并各自对应一个 ```getter/setter``` 的方法

```js
var a = { obj: 0 };

Object.defineProperty(a, 'obj', {

  get: function () {
    console.log('get：' + obj);
    return obj;
  },

  set: function (value) {
    obj = value;
    console.log('set:' + obj);
  }

});

a.obj = 2; // set: 2
console.log(a.obj); // get：2
```

有个缺点就是在 ```IE8``` 及更低版本 IE 是无法使用的，因为这个特性是没有 ```polyfill``` 的，所以无法在不支持的平台实现


#### Proxy

另外还可以使用 ```ES6``` 提供的 ```Proxy``` 代理来处理

```js
var user = {}

var proxy = new Proxy(user, {

  get(target, property) {
    console.log(`get prop ${property}`)
    return `[${target[property]}]`
  },

  set(target, property, value) {
    console.log(`set prop ${property}`)
    target[property] = btoa(value)
  }
})

proxy.name = "admin"  // set prop name
                      // "admin"
```

#### 监听数组的变化

简单来说，就是定义一个新数组，然后继承原生的 ```Array```，然后重写其中我们需要监听的方法（```pop```，```push``` 等）

```js
class NewArray extends Array {
  constructor(...args) {
    // 调用父类 Array 的 constructor
    super(...args)
  }

  push(...args) {
    console.log(`监听到数组变化`)
    // 调用父类方法
    return super.push(...args);
  }
}

let arr = [1, 2];
let newArr = new NewArray(...arr);
console.log(newArr)  // [1, 2]

newArr.push(3);      // 监听到数组变化
console.log(newArr)  // [1, 2, 3]
```

#### 关于 ES5 以下实现

在 ```ES5``` 及以下的 ```JS``` 无法完美继承数组，因为 ```Array``` 构造函数执行时不会对传进去的 ```this``` 做任何处理，不止 ```Array```，```String```，```Number```，```Regexp```，```Object``` 等等 ```JS``` 的内置类都不行

数组其响应式的 ```length``` 属性以及内部的 ```[[class]]``` 属性我们无法再 ```JS``` 层面实现，这就导致我们无法去用任何一个对象来 "模仿" 一个数组

但是可以使用非标准属性 ```__proto__``` 来实现















## 判断变量类型，如何判断变量是函数

#### 原始值

在 `JS` 中有 `5` 种原始类型：字符串，数字，布尔值，`null` 和 `undefined`，如果你希望检测一个值是否为原始类型，最佳选择是使用 `typeof` 运算符

```js
对于字符串，typeof 返回 'string'

对于数字，typeof 返回 'number'

对于布尔值，typeof 返回 'boolean'

对于undefined，typeof 返回 'undefined'
```

还有一个原始值 `null`，一般不用于检测语句，但有一个例外，如果所期望的值真的是 `null`，则可以直接和 `null` 进行比较，这时应当使用 `'==='` 或者 `'!=='` 来和 `null` 进行比较

```js
var element = document.getElementById('myDiv');
 
if (element !== null) {
  element.classList.add('found');
}
```


#### 引用值

在 `JS` 中除了原始值之外的值都是引用，有这几种内置的引用的类型：`Object`, `Array`, `Error`, `Date`

`typeof` 运算符在判断这些引用类型的时候就显得力不从心，因为所有的对象都会返回 `'object'`

```js
console.log(typeof {});  // 'object'
 
console.log(typeof []);  // 'object'
 
console.log(typeof new Date());  // 'object'
 
console.log(typeof new RegExp());  // 'object'
```

所以，在检测某个引用值的类型的最好的方法是使用 `instanceof` 运算符：

```js
// 检测日期
if (value instanceof Date) {
  console.log(value.getFullYear());
}
 
// 检测正则表达式
if (value instanceof RegExp) {
  if (value.test(anotherValue)) {
    console.log('Matches');
  }
}
 
// 检测 Error
if (value instanceof Error) {
  throw value;
}
```

默认情况下，每个对象都继承自 `Object`，因此每个对象的 `value instanceof Object` 都会返回 `true`

```js
var now = new Date();
 
console.log(now instanceof Date);    // true
console.log(now instanceof Object);    // true
```

正因为这个原因，使用 `value instanceof Object` 来判断对象是否属于某个特定类型的做法并非最佳

在 `JS` 中检测自定义类型的时候，最好的做法就是使用 `instanceof` 运算符，这也是唯一的方法，但是也有例外（跨 `frame`）


#### 函数检测

检测函数最好的方法是使用 `typeof` ，因为它可以跨 `frame` 使用

```js
function myFunc () {}
 
// 推荐，返回的是 function
console.log( typeof myFunc === 'function' );  // true
```


#### 数组检测

`ES5` 中将 `Array.isArray()` 正式的引入，唯一的目的就是检测一个值是否为数组

```js
function isArray (value) {
  if (typeof Array.isArray === 'function') {
    return Array.isArray(value);
  } else {
    return Object.prototype.toString.call(value) === '[object Array]';
  }
}
```


#### 属性检测

判断属性是否存在的最好的方法是使用 `in` 运算符，`in` 运算符仅仅会简单的判断属性是否存在，而不会去读属性的值，如果实例对象的属性存在，或者继承自对象的原型，`in` 运算符都会返回 `true`

```js
var object = {
  count: 0,
  related: null
};
 
// 推荐
if ('count' in object) {
  // ...
}
 
// 不推荐
if (object['count']) {
  // ...
}
```

如果你只想检查实例对象的某个属性是否存在，则使用 `hasOwnProperty()` 方法

所以在判断实例对象是否存在的时候，推荐使用 `in` 运算符，只有在需要判断实例属性的时候才会用到 `hasOwnProperty()`



#### 总结

* 原始值（字符串，数字，布尔值，`undefined`）  --  `typeof`

* 引用值（`Date`，`RegExp`，`Error`）  --  `instanceof`

* 函数  --  `typeof`

* 数组  --  `isArray`

* 属性检测（是否存在）  --  `in` / `hasOwnProperty()`






## JavaScript 中的几种遍历对象的方式

`JS` 中遍历对象的方法，小小的总结一下，大致有以下几种

```js

Object.keys(obj)                  // 返回所有可枚举属性（不包括原型中属性，不含 Symbol 属性）
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组）

for...in                          // 返回所有可枚举属性（包括原型中的属性，不含 Symbol 属性）
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）

Object.getOwnPropertyNames(obj)   // 返回所有的自身属性（不包括原型中属性，不含 Symbol 属性，包括不可枚举（length））
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组）

Reflect.ownKeys(obj)              // 返回所有的自身属性（不管是否可枚举，不管是不是 Symbol，一律返回）
                                  // （如果参数不是一个对象，报错）（返回数组）

for...of                          // 返回当前对象上的每一个属性（不包括原型中的属性，包括 Symbol 属性）
                                  // （对于普通的对象，for...of 不能直接使用，否则会报错，必须部署了 iterator 接口才能使用）

```

#### Object.keys(obj)

返回一个表示给定对象的所有可枚举**属性**的**字符串数组**，包括对象自身的（不含继承的）所有可枚举属性（不含 `Symbol` 属性）

```js
var arr = ['a', 'b', 'c'];

console.log(Object.keys(arr));  // ['0', '1', '2']

// -------------------------------

var an_obj = { 100: 'a', 2: 'b', 7: 'c' };

console.log(Object.keys(an_obj));  // ['2', '7', '100']
```

几个注意点：

* 返回所有可枚举属性（不包括原型中属性，不含 `Symbol` 属性）（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）（返回数组）

* 返回的是一个表示给定对象的所有可枚举**属性**的**字符串数组**（但不包括原型中的属性）

* 数组中属性名的排列顺序和使用 `for...in` 循环遍历该对象时返回的顺序一致

* 因为 `for...in` 语句无法保证遍历顺序，故 `Object.keys(obj)` 顺序也是无法保证的，原因如下

  * `Chrome`，`Opera` 的 `JavaScript` 解析引擎遵循的是新版 `ECMA-262` 第五版规范，因此，使用 `for...in` 语句遍历对象属性时遍历书序并非属性构建顺序

  * 而 `IE6`，`IE7`，`IE8`，`Firefox`，`Safari` 的 `JavaScript` 解析引擎遵循的是较老的 `ECMA-262` 第三版规范，属性遍历顺序由属性构建的顺序决定




#### for...in

`for...in` 语句以任意顺序遍历一个对象的可枚举属性，对于每个不同的属性，语句都会被执行

```js
var obj = { a: 1, b: 2, c: 3 };

for (var prop in obj) {
  console.log(prop);  // a b c
}
```

几个注意点：

* 返回所有可枚举属性（包括原型中的属性，不含 `Symbol` 属性）（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）

* `for...in` 循环只遍历**可枚举**属性，循环将迭代对象的所有可枚举属性和从它的构造函数的 `prototype` **继承**而来的（包括被覆盖的内建属性）（即包括原型中的属性）

* `for...in` 不应该被用来迭代一个下标顺序很重要的 `Array`

* `for...in` 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的

* 如果仅迭代自身的属性，而不是它的原型，可以使用：

  * `getOwnPropertyNames()`  ==> 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组

  * `hasOwnProperty()`  ==> 来确定某属性是否是对象本身的属性（一般使用这个来过滤）

  * `propertyIsEnumerable()`  ==> 返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性



#### Object.getOwnPropertyNames(obj)

`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的属性名（**包括**不可枚举属性）组成的数组（但不会获取原型链上的属性）

```js
var arr = ['a', 'b', 'c'];

console.log(Object.getOwnPropertyNames(arr).sort()); // ['0', '1', '2', 'length']
```

几个注意点：

* 返回所有的自身属性（不包括原型中属性，不含 `Symbol` 属性，包括不可枚举（`length`））（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）（返回数组）

* 返回指定对象的所有自身属性的属性名**包括不可枚举属性**组成的数组

* 不会获取原型链上的属性

* 枚举属性的顺序与通过 `for...in` 循环（或 `Object.keys`）迭代该对象属性时一致

* 如果只获取到可枚举属性，使用 `Object.keys` 或用 `for...in` 循环（配合 `hasOwnProperty()`）


#### Reflect.ownKeys

静态方法 `Reflect.ownKeys()` 返回一个由目标对象自身的属性键组成的数组

```js
Reflect.ownKeys({ z: 3, y: 2, x: 1 }); // [ 'z', 'y', 'x' ]

Reflect.ownKeys([]); // ['length']
```

几个注意点：

* 返回所有的自身属性（不管是否可枚举，不管是不是 `Symbol`，一律返回）（如果参数不是一个对象，报错）（返回数组）

* 返回值等同于 `Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`



#### for...of

`for...of` 语句在可迭代对象（包括 `Array`, `Map`, `Set`, `String`, `TypedArray`（描述一个底层的二进制数据缓存区的一个类似数组（`array-like`）视图），`arguments` 对象等）上创建一个迭代循环，对每个不同属性的属性值，调用一个自定义的有执行语句的迭代挂钩

```js
let iterable = [10, 20, 30];

for (let value of iterable) {
  console.log(value);
}
// 10
// 20
// 30

//-----------------------------

let iterable = 'foo';

for (let value of iterable) {
  console.log(value);
}
// 'f'
// 'o'
// 'o'
```

几个注意点：

* 返回当前对象上的每一个属性（对于普通的对象，`for...of` 不能直接使用，否则会报错，必须部署了 `iterator` 接口才能使用）（不包括原型中的属性，包括 `Symbol` 属性）

* 并不适用于所有的 `object`，可以迭代出任何拥有 `iterator` 的对象

* `for...of` 遍历的是**当前对象上**的每一个属性值（不包括原型上的）





## 一些数组常用的方法和其返回值

#### 会改变调用它们的对象自身的值（不会返回新数组）

```js
Array.prototype.copyWithin()  // 在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值

Array.prototype.fill()        // 将数组中指定区间的所有元素的值，都替换成某个固定的值

Array.prototype.pop()         // 删除数组的最后一个元素，并返回这个元素

Array.prototype.push()        // 在数组的末尾增加一个或多个元素，并返回数组的新长度

Array.prototype.reverse()     // 颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个

Array.prototype.shift()       // 删除数组的第一个元素，并返回这个元素

Array.prototype.sort()        // 对数组元素进行排序，并返回当前数组

Array.prototype.splice()      // 在任意的位置给数组添加或删除任意个元素

Array.prototype.unshift()     // 在数组的开头增加一个或多个元素，并返回数组的新长度
```

#### 不会改变调用它们的对象的值（返回一个新的数组或者返回一个其它的期望值）

```js
Array.prototype.concat()          // 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组

Array.prototype.includes()        // 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false

Array.prototype.join()            // 连接所有数组元素组成一个字符串

Array.prototype.slice()           // 抽取当前数组中的一段元素组合成一个新数组

Array.prototype.toString()        // 返回一个由所有数组元素组合而成的字符串，遮蔽了原型链上的 Object.prototype.toString() 方法

Array.prototype.toLocaleString()  // 返回一个由所有数组元素组合而成的本地化后的字符串，遮蔽了原型链上的 Object.prototype.toLocaleString() 方法

Array.prototype.indexOf()         // 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1

Array.prototype.lastIndexOf()     // 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1

// 一个非标准的
Array.prototype.toSource()        // 返回一个表示当前数组字面量的字符串，遮蔽了原型链上的 Object.prototype.toSource() 方法

// 还有两个方法可以返回新数组

Array.from()    // 从类数组或者迭代对象（iterable object）中创建一个新的数组实例

Array.of()      // 创建一个有可变数量的参数的新的数组实例，无论参数有多少数量，而且可以是任意类型
```








## ajax，formData，同源策略，跨域

一些相关知识点：

```IE7+``` 已经内建 ```XMLHttpRequest``` 对象

老版本 ```IE``` 可以使用 ```ActiveX``` 对象（```new ActiveXObject('Microsoft.XMLHTTP')```）

在以下情况中，请使用 ```POST``` 请求：

* 无法使用缓存文件（更新服务器上的文件或数据库）

* 向服务器发送大量数据（```POST``` 没有数据量限制）

* 发送包含未知字符的用户输入时，```POST``` 比 ```GET``` 更稳定也更可靠

```open()``` 方法第三个参数表示 异步 操作（```true```）


#### 原生 ajax

```js
var xhr = new xhrRequest();

if (xhr) {

  xhr.open('GET', url);

  // 每当 readyState 值改变时，就会触发 onreadystatechange 事件
  // 注意：onreadystatechange 事件会被触发 5 次（0 - 4），对应着 readyState 的每个变化
  xhr.onreadystatechange = function () {

    // readyState 值说明  
    // 0 -- 初始化，xhr 对象已经创建，还未执行 open  
    // 1 -- 载入，已经调用 open 方法，但是还没发送请求  
    // 2 -- 载入完成，请求已经发送完成  
    // 3 -- 交互，可以接收到部分数据  
    // 4 -- OK

    // status 值说明  
    // 200: 成功  
    // 404: Not Found
    // 500: 服务器产生内部错误  
    if (xhr.readyState == 4 && xhr.status == 200) {
      // 响应分为两种
      // responseText -- 获得字符串形式的响应数据（通常是这个）
      // responseXML -- 获得 XML 形式的响应数据
      console.log(xhr.responseText);
    }
  };

  xhr.send();

}

// ---------------------------------------------------

// 如果需要使用 POST 请求发送表单数据，使用 setRequestHeader() 来添加 HTTP 头
// 然后在 send() 方法中添加需要发送的数据

// 在 Form 元素的语法中，EncType 表明提交数据的格式，用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型

// 下面是三种常用的设置方式
// application/x-www-form-urlencoded   -- 窗体数据被编码为 名称/值 对，这是标准的编码格式
// multipart/form-data                 -- 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分
// text/plain                          -- 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符 

xhr.open('POST', url, true);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(data);
```

如果 ```ajax``` 指定为 ```post``` 但是未设置 ```content-type``` 或未指定键时，由于 ```content-type``` 为 ```text/plain```，动态页并未帮你处理成键值对的形式，所以你得自己使用 ```2``` 进制流数据生成对应的 ```string``` 类型的数据

所以如果要生成键值对形式，你得指定 ```content-type``` 为 ```'application/x-www-form-urlencoded'```


#### ajax 改为 Promise

```js
function getJSON(url) {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url, true)
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(this.responseText, this)
        } else {
          var resJson = { code: this.status, response: this.response }
          reject(resJson, this)
        }
      }
    }
    xhr.send()
  })
}

// 使用
getJSON(url).then(function (data) {
  console.log(data)
}).catch(function (status) {
  console.log(`Error: ${status}`)
})
```

----

#### xhr2

```xhr2``` 于 ```xhr``` 最大的区别在于 ```xhr``` 只支持字符串类型的数据，而 ```xhr2``` 支持任意类型的数据，比如使用 ```xhr2``` 向服务器请求一张图片

```js
var xhr = new XMLHttpRequest();
xhr.open('get', url, true)

// 处理返回内容的类型
xhr.responseType = 'bold';

xhr.onload = function (e) {
  if (this.status == 200) {
    var url = window.URL.createObjectURL(this.responseType);
    var img = new Image();
    img.src = url;
    document.body.appendChild(img);
  }
}

xhr.send();
```

#### FormData 接口

简单来说，比起普通的 ```ajax```, 使用 ```FormData``` 的最大优点就是我们可以异步上传一个二进制文件

```js
// 如果带参数使用，比如 new FormData(someForm)，FormData 对象的作用就类似于 jQuery 中的的 serialize() 方法
// 得到的对象就是这个表单元素中所有键值对数据了
function sendForm(form) {
  var data = new FormData(form);

  // 在已知的表单后添加
  data.append({ 'user': '123' })
  xhr.send(data);
}

// 不带参数使用的话，可以使用 append 来添加我们想要的数据，比如常见的表单提交
var data = new FormData();
data.append({ 'user': '123' });

var xhr = new XMLHttpRequest();
xhr.open('POST', url, true);
xhr.send(data);
```

#### upload 属性

```xhr2``` 新增了一个 ```upload``` 属性，并可以为之绑定一个 ```onprogress``` 事件，检测上传的速度

```js
var xhr = new XMLHttpRequest();
xhr.open('POST', url, true);

var body = new FormData();
body.append(data);

xhr.upload.onprogress = function (e) {
  if (e.lengthComputable) {
    document.getElementById('test').innerHTML = (e.loaded / e.total * 100) + '%';
  }
};

xhr.send(body)
```


#### 同源策略

```JavaScript``` 出于安全方面的考虑，不允许跨域调用其他页面的对象

即 同协议，同端口，同域名

#### CORS

```xhr``` 不能跨越，但 ```xhr2``` 新增了跨源资源共享的能力

在服务器设置一些标头实现真正的跨域 ```ajax``` 请求 可以跨某个域的 ```http``` 标头

```js
Access-Control-Allow-Origin: *
```

可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的 ```Access-Control-Allow-Origin```，决定权始终在对方手中

假设本域是 ```my.com```，外域是 ```sina.com```，只要响应头 ```Access-Control-Allow-Origin``` 为 ```http://my.com```，或者是 ```*```，本次请求就可以成功

这种跨域请求，称之为'简单请求'。简单请求包括 ```GET```、 ```HEAD``` 和 ```POST```（```POST``` 的 ```Content-Type``` 类型，仅限 ```application/x-www-form-urlencoded```、 ```multipart/form-data``` 和 ```text/plain```），并且不能出现任何自定义头（例如， ```X-Custom: 12345``` ），通常能满足 ```90%``` 的需求

对于 ```PUT```、```DELETE``` 以及其他类型如 ```application/json``` 的 ```POST``` 请求，在发送 ```ajax``` 请求之前，浏览器会先发送一个 ```OPTIONS``` 请求（称为 ```preflighted``` 请求）到这个 ```URL``` 上，询问目标服务器是否接受：

```js
OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST
```

服务器必须响应并明确指出允许的 ```Method```：

```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400
```

浏览器确认服务器响应的 ```Access-Control-Allow-Methods``` 头确实包含将要发送的 ```ajax``` 请求的 ```Method```，才会继续发送 ```ajax```，否则，抛出一个错误


#### document.domain

对于主域相同而子域不同的例子，可以通过设置 ```document.domain``` 的办法来解决。具体的做法是可以在 ```http://www.a.com/a.htm``` l和 ```http://script.a.com/b.html``` 两个文件中分别加上 ```document.domain = 'a.com'```

#### window.name

`window` 对象有个 `name` 属性，该属性有个特征：即在一个窗口（`window`）的生命周期内,窗口载入的所有的页面都是共享一个 `window.name` 的，每个页面对 `window.name` 都有读写的权限，`window.name` 是持久存在一个窗口载入过的所有页面中的

#### jsonp

实质上和 ```xhr``` 对象没有太大关系，其是借助了 ```script``` 标签节点可以跨域去访问，去获取的一个特性

```jsonp``` 只能对 ```GET``` 请求起到效果，即 ```jsonp``` 的方式是不支持 ```POST``` 请求的，这也是 ```jsonp``` 这种方式的局限性

原理是：动态插入 `script` 标签，通过 `script` 标签引入一个 `js` 文件，这个 `js` 文件载入成功后会执行我们在 `url` 参数中指定的函数，并且会把我们需要的 `json` 数据作为参数传入

```js
// JSONP 即 json+padding（内填充，就是把 JSON 填充到一个盒子里）
function createJs(sUrl) {
  var oScript = document.createElement('script');
  oScript.type = 'text/javascript';
  oScript.src = sUrl;
  document.getElementsByTagName('head')[0].appendChild(oScript);
}

createJs('jsonp.js');

box({
  'name': 'test'
});

function box(json) {
  alert(json.name);
}
```

#### GET 与 POST 区别

* 在客户端，```GET``` 方式在通过 ```URL``` 提交数据，数据在 ```URL``` 中可以看到，```POST``` 方式，数据放在 ```HTTP``` 包的 ```body``` 中

* ```GET``` 方式提交的数据大小有限制（因为浏览器对 ```URL``` 的长度有限制），而 ```POST``` 则没有此限制

* 安全性问题，使用 ```GET``` 的时候，参数会显示在地址栏上，而 ```POST``` 不会，所以如果这些数据是中文数据而且是非敏感数据，那么使用 ```GET```，如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 ```POST``` 为好

![GETPOST](GETPOST.png)


#### xhr 的 withCredentials 属性

默认情况下，```ajax``` 跨源请求不提供凭据（```cookie```、```HTTP``` 认证及客户端 ```SSL``` 证明等），通过将设置 ```ajax``` 的 ```withCredentials``` 属性设置为 ```true```，可以指定某个请求应该发送凭据，如果服务器接收带凭据的请求，会用下面的 ```HTTP``` 头部来响应

```js
Access-Control-Allow-Credentials: true
```

需要注意：永远不会影响到同源请求

简单来说，在平常开发的时候，身份验证是经常遇到的问题，在**跨域请求**中，默认情况下是不发送验证信息的，要想发送验证信息，需要设置 ```withCredentials``` 属性

```js
var xhr = new XMLHttpRequest();

xhr.open('GET', url, true);
xhr.withCredentials = true;

xhr.send(null);
```



## promise 和 setTimeout

首先，我们要知道为什么要使用 `promise`

来看下面这个示例，读取一个文件，在控制台输出这个文件内容

```js
var fs = require('fs');

fs.readFile('1.txt', 'utf8', function (err, data) {
    console.log(data);
});
```

看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容

```js
var fs = require('fs');

fs.readFile('1.txt', 'utf8', function (err, data) {
  console.log(data);
  fs.readFile('2.txt', 'utf8', function (err, data) {
    console.log(data);
  });
});
```

要是读取更多的文件呢?

```js
var fs = require('fs');
fs.readFile('1.txt', 'utf8', function (err, data) {
  fs.readFile('2.txt', 'utf8', function (err, data) {
    fs.readFile('3.txt', 'utf8', function (err, data) {
      fs.readFile('4.txt', 'utf8', function (err, data) {
        // ...
      });
    });
  });
});
```

这就是传说中的 `callback hell`

#### 基本概念

首先它是一个对象，它和 ```javascript``` 普通的对象没什么区别，同时，它也是一种规范，跟异步操作约定了统一的接口，表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的

1. ```promise``` 只有三种状态，未完成，完成 (```fulfilled```) 和失败 (```rejected```)

2. ```promise``` 的状态可以由未完成转换成完成，或者未完成转换成失败

3. ```promise``` 的状态转换只发生一次

4. ```Promise``` 状态转换完成后就是外部**不可变**的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意的修改（特别是对于多方查看同一个 Promise 状态转换的情况）

```promise``` 有一个 ```then``` 方法，```then``` 方法可以接受 ```3``` 个函数作为参数

前两个函数对应 ```promise``` 的两种状态 ```fulfilled```, ```rejected``` 的回调函数，第三个函数用于处理进度信息（```.then()``` 总是返回一个新的 ```promise```）

一个简单的读取文件示例：

```js
var fs = require("fs");

function readFile() {
  return new Promise(function (resolve, reject) {
    fs.readFile("1.txt", "utf-8", function (err, data) {
      if (err) {
        reject(err)
      } else {
        resolve(data)
      }
    })
  })
}

readFile().then(function (data) {
  console.log(data)
}).catch(function (err) {
  console.log(err)
})
```

#### promise 和 setTimeout 执行顺序

详细可见 《你不知道的js（中卷）》 -- 1.5节

一个简单的示例：

```js
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function (resolve) {
  resolve();
}).then(function () {
  console.log(2);
});

// 2, 1
```

简单来说，```promise``` 的任务会在当前事件循环末尾中执行，而 ```setTimeout``` 中的任务是在下一次事件循环执行

在 ```ES6``` 中，有一个新的概念建立在事件循环队列之上，叫做 **任务队列**

简单的理解就是，它是挂在事件循环队列的每个 ```tick``` 之后的一个队列，在事件循环的每个 ```tick``` 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 ```tick``` 的任务队列末尾添加一个项目（任务）

一个任务可能引起更多任务被添加到同一个队列末尾，所以，理论上说，任务循环可能无限循环（一个任务总是添加另一个任务，以此类推），进而导致程序的无限循环，无法转移到下一个事件循环 ```tick```，从概念上看，这和代码中的无限循环（类似 ```while(true)```）的体验几乎是一样的

再来看一个实例

```js
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);
// 结果为 2 3 5 4 1
```

首先是一个 `setTimeout`，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 `1`

然后是一个 `Promise`，里面的函数是会立即执行的，所以首先输出 `2` 和 `3`

这里需要注意的是，`Promise` 的 `then` 应当会放到当前 `tick` 的最后，但是还是在当前 `tick` 中，所以会先输出 `5` 然后才会输出 `4`，最后轮到下一个 `tick` 之后才会输出 `1`

扩展：[promise 的队列与 setTimeout 的队列有何关联？](https://www.zhihu.com/question/36972010)



#### 再来看下面这个比较绕的问题


下面几个的输出值为多少

```js
// 一
for (var i = 0; i < 5; i++) {
  console.log(i);
}


// 二
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}


// 三
for (var i = 0; i < 5; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  })(i)
}


// 四
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}


// 五
for (var i = 0; i < 5; i++) {
  (function () {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  })(i)
}


// 六
for (var i = 0; i < 5; i++) {
  setTimeout((function (i) {
    console.log(i);
  })(i), i * 1000);
}



// 七
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);



// 八
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  setTimeout(function() {
    console.log(6)
  }, 0)
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);

```

----

----

1. 最基本的，输出 `0 - 4`

2. `setTimeout` 会延迟执行，那么执行到 `console.log` 的时候，其实 `i` 已经变成 `5` 了，所以结果为 `5` 个 `5`

3. 如果要输出 `0` 到 `4`，可以使用三和四两种方式

5. 去掉 `function()` 中的 `i`，内部就没有对 `i` 保持引用，结果还是 `5` 个 `5`

6. 如果修改成六这样，立即执行函数会立即执行，所以会立即输出 `0 - 4` 而不会延迟

7. 最后两个有些复杂，但是原理是类似的

都被改写成了 `Promise`，但是首先需要明确的是，`promise` 的任务会在当前事件循环末尾中执行，而 `setTimeout` 中的任务是在下一次事件循环执行

首先是一个 `setTimeout`，所以其中的任务是会在下一次事件循环中才会执行，因此开始肯定不会输出 `1`

然后是一个 `Promise`，里面的函数是会立即执行的，所以首先输出 `2` 和 `3`

这里需要注意的是，`Promise` 的 `then` 应当会放到当前 `tick` 的最后，但是还是在当前 `tick` 中（而不是下一次事件循环），所以会先输出 `5` 然后才会输出 `4`，最后轮到下一个 `tick` 才会输出 `1`

所以结果为 `2 3 5 4 1`

至于最后一个，和第七个是一样的，结果为 `2 3 5 4 1 6`



#### Promises/A+ 规范

`promise` 代表一个异步操作的最终结果。主要通过 `promise` 的 `then` 方法订阅其最终结果的处理回调函数，和订阅因某原因无法成功获取最终结果的处理回调函数。

更对详细见：<a href="https://promisesaplus.com/" target="_blank">Promises/A+</a>

`A` 与 `A+` 的不同点

* `-A+` 规范通过术语 `thenable` 来区分 `promise` 对象

* `-A+` 定义 `onFulfilled/onRejectd` 必须是作为函数来调用，而且调用过程必须是异步的

* `-A+` 严格定义了 `then` 方法链式调用时，`onFulfilled/onRejectd` 的调用顺序



## IOS 移动端 click 事件 300ms 的延迟响应

移动设备上的 ```web``` 网页是有 ```300ms``` 延迟的，玩玩会造成按钮点击延迟甚至是点击失效，这是由于区分单击事件和双击屏幕缩放的历史原因造成的

双击缩放是指用手指在屏幕上快速点击两次，```iOS``` 自带的 ```Safari``` 浏览器会将网页缩放至原始比例

原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接 ```<a href="#"></a>```，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作

所以，捕获第一次单击后，浏览器会先等待一段时间 ```t```，如果在 ```t``` 时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果 ```t``` 时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作

这个 ```t``` 在 ```IOS safari``` 下，大概为 ```300``` 毫秒，这就是延迟的由来，造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于 ```web``` 开发者来说是，页面 ```js``` 捕获 ```click``` 事件的回调函数处理，需要 ```300ms``` 后才生效，也就间接导致影响其他业务逻辑的处理

一般常见的有以下几种解决方案：

* 使用 ```fastclick.js``` 库可以解决在手机上点击事件的 ```300ms``` 延迟

* ```zepto``` 的 ```touch``` 模块，```tap``` 事件也是为了解决在 ```click``` 的延迟问题

* 触摸事件的响应顺序为 ```touchstart``` --> ```touchmove``` --> ```touchend``` --> ```click```，也可以通过绑定 ```ontouchstart``` 事件，加快对事件的响应，解决 ```300ms``` 延迟问题


#### 从上面引申出来的 Zepto 点透问题

问题如下：

![点透](http://images.cnitblog.com/blog/546511/201503/011850313937285.png)

在点击弹出来的选择组件的右上角完成后会让完成后面的 ```input``` 输入框聚焦，弹出输入键盘，也就是点透了

这是因为 ```zepto``` 的 ```tap``` 是通过兼听绑定在 ```document``` 上的 ```touch``` 事件来完成 ```tap``` 事件的模拟的，及 ```tap``` 事件是冒泡到 ```document``` 上触发的

在点击完成时的 ```tap``` 事件（```touchstart/touchend```）需要冒泡到 ```document``` 上才会触发，而在冒泡到 ```document``` 之前，用户手的接触屏幕（```touchstart```）和离开屏幕（```touchend```）是会触发 ```click``` 事件的

因为 ```click``` 事件有延迟触发（就是上面的 ```300ms```，这也就是为什么移动端不用 ```click``` 而用 ```tap``` 的原因），所以在执行完 ```tap``` 事件之后，弹出来的选择组件马上就隐藏了

此时 ```click``` 事件还在延迟的 ```300ms``` 之中，当 ```300ms``` 到来的时候，```click``` 到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有 ```click``` 事件此时便会触发，如果没有绑定 ```click``` 事件的话就当没 ```click```，但是正下方的是 ```input``` 输入框（或者 ```select``` 选择框或者单选复选框等其他组件），点击默认聚焦而弹出输入键盘，也就出现了上面的点透现象

几种解决方案：

方案一：引入 ``````fastclick.js``````，因为 ``````fastclick`````` 源码不依赖其他库所以你可以在原生的 ```js``` 前直接加上

```js
window.addEventListener("load", function () {
  FastClick.attach(document.body);
}, false);
```

方案二：用 ```touchend``` 代替 ```tap``` 事件并阻止掉 ```touchend``` 的默认行为 ```preventDefault()```

```js
$("#cbFinish").on("touchend", function (event) {
  // ...
  event.preventDefault();
});
```

方案三：延迟一定的时间（```300ms+```）来处理事件

```js
$("#cbFinish").on("tap", function (event) {
  setTimeout(function () {
    // ...
  }, 320);
}); 
```   

如果实在不行，那还是用 ```click``` 吧




## JavaScript 中的命名空间，变量声明提升，作用域和预编译

#### 命名空间

`JavaScript` 中没有命名空间这个概念的，只能模拟实现，命名空间的使用可以显著减少命名冲突，并很好的组织代码，如下一个简单的示例

```js
var namespace = namespace || {};

namespace.AModule = {};
namespace.AModule.name = 'abc';
namespace.BModule = {};
```


#### 变量声明提升

声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已

定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义

```js
var a;      // 这是声明
a = 1;      // 这是定义（赋值）
var a = 1;  // 合二为一：声明变量的存在并赋值给它
```

当你以为你只做了一件事情的时候（`var a = 1`），实际上解释器把这件事情分解成了两个步骤

一个是声明（`var a`），另一个是定义（`a = 1`）

#### 两个示例

```js
var a = 1;
 
function foo () {
  if (!a) {
    var a = 2;
  }
  alert(a);
};
 
foo();  // 输出 2
```

简单的调整一下

```js
var a;
a = 1;
 
function foo() {
  var a;  // 关键在这里
  if (!a) {
    a = 2;
  }
  alert(a);  // 此时的 a 并非函数体外的那个全局变量
}

foo()
```

如代码所示，在进入函数体后解释器声明了新的变量 `a`，而无论 `if` 语句的条件如何，都将为新的变量 `a` 赋值为 `2`



#### 作用域

`JavaScript` 在 `ES6` 之前是没有块级作用域的（`Block Scoping`），只有函数作用域（`Function Scoping`）

当解析器读到 `if` 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 `Hoisting`

> `JavaScript` 只有函数作用域！

若是想要 `alert(a)` 弹出那个 `1` 则可以创建有一个新的作用域，可以使用立即执行函数

```js
var a = 1;
 
function foo() {
  // 这个就是 IIFE，它会创建一个新的函数作用域
  // 并且该作用域在 foo() 的内部，所以 alert 访问不到
  // 不过这个作用域可以访问上层作用域，这就叫：闭包
  if (!a) {
    (function() {  
      var a = 2; 
    }());               
  };
  alert(a);
};
 
foo();
```

> '请始终保持作用域内所有变量的声明放置在作用域的顶部' 不是没有道理的

因为这样可以避免 `Hoisting` 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问

但是，变量声明的提升并非 `Hoisting` 的全部

在 `JavaScript` 中，有四种方式可以让命名进入到作用域中（按优先级）

* 语言定义的命名：比如 `this` 或者 `arguments`，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 `this` 之类的，这样是没有意义的

* 形式参数：函数定义时声明的形式参数会作为变量被 `hoisting` 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

* 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

* 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的




#### 预编译

`JavaScript` 引擎并不是读一句执行一句，而是读取一段、解释执行一段，而一段一段执行，`JavaScript` 会对读取的这段 `JavaScript` 代码整体有个预处理，这个预处理就是所谓的预编译

预编译阶段，`JavaScript` 引擎会进行变量提升，这里就会涉及到变量对象

`JavaScript` 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（`Variable Object`，缩写为 `VO`）是一个抽象概念中的"对象"，它用于存储执行上下文中

1. 变量

2. 函数声明

3. 函数参数

`VO` 按照如下顺序填充：

1. 函数参数（若为传入，初始化该参数值为 `undefined`）

2. 函数声明（若发生命名冲突，会覆盖）

3. 变量声明（初始化变量值为 `undefined`，若发生命名冲突，会忽略）


看以下几个实例

```js
function foo (x, y, z) {
  function x () {};
  alert(x);   // function x () {}
}

 
foo(100);
```

在初始化阶段，先初始化函数的参数，参数 `x` 即为传进来的参数，为 `100`，但是在处理函数声明的时候，发生冲突，`x` 会被覆盖，所以返回的是一个函数对象

```js
// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略
function foo (x, y, z) {
  function fn () {};
  var fn;
  console.log(fn);    // function fn () {}
}
 
foo(100);
 
// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作
function foo (x, y, z) {
  function fn () {};
  var fn = 1;
  console.log(fn);    // 1
}
 
foo(100);
 
// 在看一个容易出错的，最终会输出 100 和 0
var num = 0;
 
function a (num) {
  num = 100;
  console.log(num);
}
 
a();
console.log(num);
```

函数表达式不会影响 `VO`，比如 `var a = function foo(){}`

这里的 `foo` 是函数表达式的名称，这个是不会记录到 `AO` 中的，这也是为什么我们不能在外部通过 `foo` 来获取到这个函数对象

## JSON.parse() && JSON.stringify()

#### JSON.parse()

`JSON.parse()` 用来解析 `JSON` 字符串，构造由字符串描述的 ``JavaScript`` 值或对象，提供可选的 `reviver` 函数用以在返回之前对所得到的对象执行变换

```js
var json = '{"result":true, "count":42}';
JSON.parse(json);  // { result: true, count: 42 }
```

语法如下


```js
JSON.parse(text[, reviver])
```

如果被解析的 `JSON` 字符串是非法的（`text`），则会抛出一个语法错误异常

如果指定了 `reviver` 函数，则解析出的 ``JavaScript`` 值（解析值）会经过一次转换后才将被最终返回（返回值）

意思就是，解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 `reviver` 函数

在调用过程中，当前属性所属的对象会作为 `this` 值，当前属性名和属性值会分别作为第一个和第二个参数传入 `reviver` 中

如果 `reviver` 返回 `undefined`，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值


> 当遍历到最顶层的值（解析值）时，传入 `reviver` 函数的参数会是空字符串 `""`（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了）
> 
> 当前的 `this` 值会是 `{"": 修改过的解析值}`，在编写 `reviver` 函数时，要注意到这个特例（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历）


下面是两个示例

```js
// 如果到了最顶层，则直接返回属性值
// 否则将属性值变为原来的 2 倍
JSON.parse('{"p": 5}', function (k, v) {
  if(k === '') return v;     
  return v * 2;              
});        

// { p: 10 }


JSON.parse(' {"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}} ', function (k, v) {
  // 输出当前的属性名，从而得知遍历顺序是从内向外的
  console.log(k); ，

  // 最后一个属性名会是个空字符串
  // 返回原始属性值，相当于没有传递 reviver 参数
  return v;       
});

// 1
// 2
// 4
// 6
// 5
// 3 
// ""
```



#### JSON.stringify()

方法是将一个 ``JavaScript`` 值（对象或者数组）转换为一个 `JSON` 字符串，如果指定了 `replacer` 是一个函数，则可以替换值，或者如果指定了 `replacer` 是一个数组，可选的仅包括指定的属性

语法如下

```js
JSON.stringify(value[, replacer [, space]])
```

#### 关于可选参数 replacer

* 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理

* 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 `JSON` 字符串中

* 如果该参数为 `null` 或者未提供，则对象所有的属性都会被序列化


#### 关于可选参数 space

* 指定缩进用的空白字符串，用于美化输出（`pretty-print`）

* 如果参数是个数字，它代表有多少的空格（上限为 `10`），该值若小于 `1`，则意味着没有空格

* 如果该参数为字符串（字符串的前十个字母），该字符串将被作为空格

* 如果该参数没有提供（或者为 `null`）将没有空格


#### 关于序列化，有下面五点注意事项

* 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中

* 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值

* `undefined`、任意的函数以及 `symbol` 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 `null`

* 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误

* 所有以 `symbol` 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们

* 不可枚举的属性会被忽略


```js
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1, "false", false]'
JSON.stringify({ x: 5 });                  // '{"x": 5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x": 5, "y": 6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1, "false", false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null, null, null]' 

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify(
  { [Symbol.for("foo")]: "foo" },
  function (k, v) {
    if (typeof k === "symbol") {
      return "a symbol";
    }
  }
);
// undefined 

JSON.stringify(
  Object.create(
    null,
    {
      x: { value: 'x', enumerable: false },
      y: { value: 'y', enumerable: true }
    }
  )
);
// 不可枚举的属性默认会被忽略
// "{"y":"y"}"
```



#### replacer 参数

`replacer` 参数可以是一个函数或者一个数组，作为函数，它有两个参数，键值都会被序列化

* 如果返回一个 `Number`, 转换成相应的字符串被添加入 `JSON` 字符串

* 如果返回一个 `String`, 该字符串作为属性值被添加入 `JSON`

* 如果返回一个 `Boolean`, `"true"` 或者 `"false"` 被作为属性值被添加入 `JSON` 字符串

* 如果返回任何其他对象，该对象递归地序列化成 `JSON` 字符串，对每个属性调用 `replacer` 方法（除非该对象是一个函数，这种情况将不会被序列化成 `JSON` 字符串）

* 如果返回 `undefined`，该属性值不会在 `JSON` 字符串中输出

> 需要注意的是，不能用 `replacer` 方法，从数组中移除值（`values`），如若返回 `undefined` 或者一个函数，将会被 `null` 取代

```js
var foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 };
var jsonString = JSON.stringify(foo, (key, value) => {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
});

console.log(jsonString);  // {"week": 45, "month": 7}
```

如果 `replacer` 是一个数组，数组的值代表将被序列化成 `JSON` 字符串的属性名（即只有包含在这个数组中的属性名才会被序列化）

```js
var foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 };
console.log(JSON.stringify(foo, ['week', 'month']));  //  只保留 week 和 month 属性值
```


#### 关于 toJSON 方法

需要注意的是，如果一个被序列化的对象拥有 `toJSON` 方法，那么该 `toJSON` 方法就会覆盖该对象默认的序列化行为（即为调用 `toJSON` 方法后的返回值会被序列化）

```js
var obj = {
  foo: 'foo',
  toJSON: function () {
    return 'bar';
  }
};

JSON.stringify(obj);         // '"bar"'
JSON.stringify({ x: obj });  // '{"x":"bar"}'
```


#### 使用 JSON.stringify 来格式化对象

在平常的开发过程中，经常会遇到一些十分复杂的对象，往往是对象当中嵌套对象，看上去十分的不直观

我们可以利用 `replacer` 和 `space` 参数来对其进行格式化

```js
// 因为函数如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，所以需要特殊处理
var foo = function (key, value) {
  if (typeof (value) === 'function' || typeof(value) === 'symbol') {
    return value.toString()
  } else if (typeof (value) === 'undefined') {
    return 'undefined'
  } else {
    return value;
  }
}

var json = { bar: 'aaa', foo: { age: Symbol('23') }, baz: undefined, o: { name: 'zhangsan', userInfo: { sex: 0, getSex: function () { return this.sex; }, address: null } } };
JSON.stringify(json, foo, 2);

// {
//   "bar": "aaa",
//   "foo": {
//     "age": "Symbol(23)"
//   },
//   "baz": "undefined",
//   "o": {
//     "name": "zhangsan",
//     "userInfo": {
//       "sex": 0,
//       "getSex": "function () { return this.sex; }",
//       "address": null
//     }
//   }
// }
```






## clientWidth, offsetWidth, scrollWidth

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变
 
document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变
 
document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大
 
----
 
document.body.scrollTop        // 页面滚动条向下拉动的距离
 
document.body.scrollLeft       // 页面滚动条向左拉动的距离
 
obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变
 
obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同
 
----
 
// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度
 
window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）
```

两个兼容函数

```js
// 返回视口的大小，部分移动设备浏览器对 innerWidth 的兼容性不好
// 需要使用 document.documentElement.clientWidth 或者 document.body.clientWidth 来兼容（混杂模式下对 document.documentElement.clientWidth 不支持）
// 使用方法 getViewPort().width
function getViewPort () {
  // 浏览器嗅探，混杂模式
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.clientWidth,
      height: document.body.clientHeight
    };
  } else {
    return {
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    };
  }
}


// 获得文档的大小（区别与视口），与上面类似
function getDocumentPort () {
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.scrollWidth,
      height: document.body.scrollHeight
    };
  } else {
    return {
      width: Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth),
      height: Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight)
    }
  }
}
```


## call，apply，bind 的定义与实现

`bind` 方法的定义见 [ECMAScript5.1 - bind](http://yanhaijing.com/es5/#324)

使用方式如下

```js
fun.bind(thisArg[, arg1[, arg2[, ...]]])
```

`bind()` 方法会创建一个新函数，当这个新函数被调用时，它的 `this` 值是传递给 `bind()` 的第一个参数, 它的参数是 `bind()` 的其他参数和其原本的参数

`bind` 返回的绑定函数也能使用 `new` 操作符创建对象（这种行为就像把原函数当成构造器），提供的 `this` 值被忽略，同时调用时的参数被提供给模拟函数

`bind` 方法与 `call`、`apply` 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数

> 还可以写成 `fn.bind(obj, arg1)(arg2)`

一句话概括就是

该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 `bind` 方法的第一个参数作为 `this`，传入 `bind` 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数


#### 实现

初级实现

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  // 记住 this，就是需要绑定 this 的实例函数（原函数）
  var _this = this;
  var argsArray = Array.prototype.slice.call(arguments);
  return function () {
    // 剔除第一个参数，其余作为参数来传递（提供给原函数）
    return _this.apply(context, argsArray.slice(1));
  }
}
```

这里存在一些问题，在于在预置参数功能丢失的现象（因为使用了 `argsArray.slice(1)`），比较好的解决方式是下面这种

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  var _this = this;
  var args = Array.prototype.slice.call(this.arguments, 1);
  return function () {
    return _this.apply(context, args.concat(Array.prototype.slice.call(arguments)))
  }
}
```

但是 `bind` 当中还有一点比较特殊

`bind` 返回的函数如果作为构造函数，搭配 `new` 关键字出现的话，我们的绑定 `this` 就需要"被忽略"

这样一来就需要在构造函数的场景下来进行兼容

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var F = function () { };
  F.prototype = this.prototype;
  var bound = function () {
    return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments)));
  }
  bound.prototype = new F();
  return bound;
}
```

如果比较严谨的话，还需要判断调用 `bind` 方法的一定要为一个函数，否则就抛出一个错误

```js
if (typeof this !== 'function') {
  throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)
}
```


#### 扩展，要求不使用 call 和 apply

简单来说，就是手动实现一个 `call` 和 `apply` 即可

`call` 和 `apply` 本质是一样的，区别就在于参数的不同

`call` 方法的定义 [call](http://yanhaijing.com/es5/#323)

简单来说就是

* `call()` 方法在使用一个指定的 `this` 值和若干个指定的参数值的前提下调用某个函数或方法

* `apply()` 方法在使用一个指定的 `this` 值和参数值必须是数组类型的前提下调用某个函数或方法


#### 原理

`call()` 和 `apply()` 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 `this` 来获得它的引用，比如以对象 `o` 的方法来调用函数 `f()`

```js
f.call(o)

f.apply(o)
```

大致原理如下所示

```js
o.m = f;    // 将 f 存储为 o 的临时方法
o.m();      // 调用它，不传入参数

delete o.m; // 将临时方法删除
```

在严格模式中，`call()` 和 `apply()` 的第一个参数都会变成 `this` 的值，哪怕传入的实参是原始值甚至是 `null` 或 `undefined`

在 `ES3` 或者非严格模式中，传入的 `null` 和 `undefined` 都会被全局对象代替，而其他原始值则会被相应的包装对象（`wrapper object`）所替代

简单来说就是，`f.call(o)` 其原理就是先通过 `o.m = f` 将 `f` 作为 `o` 的某个临时属性 `m` 存储，然后执行 `m`，执行完毕后将 `m` 属性删除



#### 实现

这里以 `apply` 为例

初级实现

```js
Function.prototype.apply = function (context) {
  context.fn = this;
  context.fn();
  delete context.fn;
}
```

但是 `apply` 有一点不同，它的参数是一个数组，在执行的时候会把数组的值依次传递给函数当参数

需要实现类似 `context.fn(arg1, arg2, arg3 ...)` 的调用方式，这里采用 `evel` 来实现

```js
Function.prototype.apply = function (context) {
  var args = arguments[1];
  context.fn = this;

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1,arg2,arg3...)
  var fnStr = 'context.fn(';
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
  }
  fnStr += ')';
  eval(fnStr);

  delete context.fn;
}
```

有几个需要注意的地方

`this` 参数可以传递 `null` 或者不传，当为 `null` 的时候，则指向 `window`

函数是可以指定返回值的

```js
Function.prototype.apply = function (context) {
  var context = context || window;
  var args = arguments[1];
  context.fn = this;

  if (args === void 0) {
    return context.fn();
  }

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1, arg2, arg3 ...)
  var fnStr = 'context.fn(';
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
  }
  fnStr += ')';
  var returnVal = eval(fnStr);

  delete context.fn;
  return returnVal;
}
```

还有一个问题，即 `context.fn = this`，这里我们只是假设不存在名为 `fn` 的属性，所以这里我们需要保证 `fn` 的唯一性

这里可以采用 `ES6` 提供的 `symbol` 数据类型，直接添加即可

```js
var fn = Symbol()
context[fn] = this
```

如果不使用 `symbol`，也可以来手动模拟一个，简单来说就是随机定义一个属性名称，然后在进行赋值的时候判断一下

```js
function symbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    // 如果已经存在这个属性，则递归调用，直到没有这个属性
    arguments.callee(obj)
  } else {
    return unique_proper;
  }
}

// 使用
var fn = symbol(context);
```

而 `call` 方法，可以利用上面的 `apply` 来简单实现

```js
Function.prototype.call = function (context) {
  return this.apply(([].shift.apply(arguments), arguments));
}
```



#### 汇总

```js
function symbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    // 如果已经存在这个属性，则递归调用，直到没有这个属性
    arguments.callee(obj);
  } else {
    return unique_proper;
  }
}

Function.prototype.apply = function (context) {

  var context = context || window;

  // 获取传入的数组参数
  var args = arguments[1];
  var fn = symbol(context);

  // 保证 fn 的唯一性
  context[fn] = this

  // 如果没有传入参数则直接执行
  if (args == void 0) {
    return context[fn]()
  }

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1, arg2, arg3 ...)
  var fnStr = 'context[fn]('
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ','
  }
  fnStr += ')'

  // 使用 evel 执行，完成后删除这个属性
  var returnValue = eval(fnStr)
  delete context[fn]

  return returnValue
}

Function.prototype.call = function (context) {
  return this.apply(([].shift.apply(arguments)), arguments)
}

Function.prototype.bind = Function.prototype.bind || function (context) {

  // 判断调用对象是否是函数
  if (typeof this !== 'function') {
    throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)
  }

  // 记住 this，就是需要绑定 this 的实例函数（原函数）
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);

  // 在构造函数的场景下来进行兼容（因为在搭配 new 使用的时候，绑定的 this 需要被忽略）
  var F = function () { };
  F.prototype = this.prototype;

  var bound = function () {
    return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments)));
  }

  bound.prototype = new F();
  
  return bound;
}
```













#### 数组排序的两种方法

```js
// 二分排序
function oSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  var left = [];
  var right = [];
  var oNum = Math.floor(arr.length / 2);
  var oNumVode = arr.splice(oNum, 1);

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < oNumVode) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return oSort(left).concat(oNumVode, oSort(right));
}


// 冒泡排序
function mp(arr) {
  var temp;
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < arr.length; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j + 1];
        arr[j + 1] = arr[i];
        arr[i] = temp;
      }
    }
  }
  return arr;
}
```

#### 数组去重的两种方法

```js
Array.prototype.uniq1 = function () {
  // 先排序，在比较
  this.sort();
  var arr = [this[0]];
  for (var i = 1; i < this.length; i++) {
    if (this[i] !== arr[arr.length - 1]) {
      arr.push(this[i]);
    }
  }
  return arr;
}


Array.prototype.uniq2 = function () {
  var arr = [];
  for (var i = 0; i < this.length; i++) {
    // 遍历当前数组
    // 检测新数组内是否重复，如果没有出现则为 -1
    // 把 arr 数组的第 i 项插入新数组
    if (arr.indexOf(this[i]) == -1) {
      arr.push(this[i]);
    }
  }
  return arr;
}

var arr = [1, 2, 3, 4, 4, 4, 4, 5, 5, 5, 6]
arr.uniq1()
```



## typeOf，hasOwnProperty，isPrototypeOf，instanceof

#### typeOf

```js
function show(x) {

  console.log(typeof (x));    // undefined
  console.log(typeof (10));   // number
  console.log(typeof ('abc')); // string
  console.log(typeof (true));  // boolean

  console.log(typeof (function () { }));  //function

  console.log(typeof ([1, 'a', true]));  //object
  console.log(typeof ({ a: 10, b: 20 }));  //object
  console.log(typeof (null));  //object
  console.log(typeof (new Number(10)));  //object

}

show();

```

* 对于数字类型的值，`typeof` 会返回 `number`（`NaN` 也是一个数字类型，因为它在 `JavaScript` 中代表的是特殊非数字值）

* 对于字符串类型的值，`typeof` 会返回 `string`

* 对于布尔类型的值，`typeof` 会返回 `boolean`

* 对于对象，数组，`null` 而言，`typeof` 会返回 `object`

* 对于函数类型而言，`typeof` 返回 `function`

* 如果运算数没有定义（不存在或未赋值），将会返回 `undefined`






#### hasOwnProperty

是用来判断一个对象是否有你给出名称的属性或对象（需要注意的是，此方法无法检查该对象的原型链中是否具有该属性）

该属性必须是对象本身的一个成员，在跨浏览器的设计中，我们不能依赖于 `for in` 来获取对象的成员名称，一般使用 `hasOwnProperty` 来判断

```js
var buz = {
  fog: '123'
};

for (var name in buz) {
  if (buz.hasOwnProperty(name)) {
    alert("this is fog (" + name + ") for sure. Value: " + buz[name]);
  }
  else {
    alert(name); // toString or something else
  }
}
```

在 `Object.prototype` 中调用 `hasOwnProperty()`

```js
// 对象
var man = {
  hands: 2,
  legs: 2,
  heads: 1
};

// 将一个方法添加到对象上
if (typeof Object.prototype.clone === "undefined") {
  Object.prototype.clone = function () {
    // ...
  }
}

// 使用 hasOwnProperty()
for (var i in man) {
  if (Object.prototype.hasOwnProperty.call(man, i)) {  // 过滤
    console.log(i, ":", man[i]);
  }
}
```

在使用 `hasOwnProperty()` 对 `man` 对象进行精炼后，可有效的避免命名冲突，也可以使用一个本地变量来缓存比较长的属性名

```js
var i, hasOwn = Object.prototype.hasOwnProperty;

for (var i in man) {
  // 过滤
  if (hasOwn.call(man, i)) {  
    console.log(i, ":", man[i]);
  }
}
```

严格来讲，不使用 `hasOwnProperty()` 并没有错，依赖具体任务和对代码的自信，可以忽略过该方法并略微加快循环的执行速度

但是当确认不了对象的内容（和原型链）的时候，最好还是加上 `hasOwnProperty()` 这样安全的检查






#### isPrototypeOf

是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回 `true`，否则返回 `false`

```js
function Fee() {
  // . . .
}



function Fi() {
  // . . .
}

Fi.prototype = new Fee();



function Fo() {
  // . . .
}

Fo.prototype = new Fi();



function Fum() {
  // . . .
}
Fum.prototype = new Fo();


// ---------------------------


var fum = new Fum();
// ...

if (Fi.prototype.isPrototypeOf(fum)) {
  // do something safe
} 
```







#### instanceof

用来测试一个对象在其原型链构造函数上是否具有 `prototype` 属性，直白的说就是，用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上

```js
// 定义构造函数
function C() { }
function D() { }

var o = new C();

// true，因为 Object.getPrototypeOf(o) === C.prototype
o instanceof C;

// false，因为 D.prototype 不在 o 的原型链上
o instanceof D;

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象，这个空对象不在 o 的原型链上

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true
```

需要注意的是，如果表达式 `obj instanceof Foo` 返回 `true`，则并不意味着该表达式会永远返回 `ture`，因为 `Foo.prototype` 属性的值有可能会改变

改变之后的值很有可能不存在于 `obj` 的原型链上，这时原表达式的值就会成为 `false`

另外一种情况下，原表达式的值也会改变，就是改变对象 `obj` 的原型链的情况，虽然在目前的 `ES` 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 `__proto__` 魔法属性，是可以实现的

比如执行 `obj.__proto__ = {}` 之后，`obj instanceof Foo` 就会返回 `false` 了

更多详细见： [MDN - instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)


所以，在判断一个变量是不是对象的情况下，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`

```js
var fn = function () { };

console.log(fn instanceof Object);  // true
```



## 运算符优先级

```js
var provider = {
  test: {
    $get: function () {
      return function anonymous(config) {
        console.log(this);  // window
      };
    }
  }
};

var type = "test";
var config = {};
new provider[type].$get()(config);
```

这里需要明确两点，一个是构造函数的返回，另一个是 `new` 操作符的执行顺序

#### 构造函数的返回

简单来说

* 如果返回的是一个非引用类型的值时，实际上返回的是仍然是新创建的实例对象

* 如果返回的是一个引用类型的值时，返回的是引用对象本身

比如如下示例

```js
function Person() {}

const person = new Person();
console.log(typeof person);  // object

// ----

function Person() {
  return function() {}
}

const person = new Person();
console.log(typeof person);  // function
```

#### new 操作符的执行顺序

在 `MDN` 的 `new` 操作符描述中，语法是

```js
new constructor[([arguments])]
```

可以发现，参数 `arguments` 是可缺省的，那么就意味着，对于不含参数的构造函数而言，`new Person()` 和 `new Person` 是一样的

那么又会涉及到一个问题，为什么执行的时候是执行的 `new Person()`，而不是 `(new Person)()` 呢，这里就涉及到操作符的执行顺序

这里也只列举几个这里用到的运算符，更多详细的可以参考 [运算符优先级 (JavaScript)](https://msdn.microsoft.com/zh-cn/library/z3ks45k7(v=vs.94).aspx)

|优先级|运算类型|关联性|运算符|
|-|-|-|-|
|20|	圆括号|	n/a|	( … )|
|19|成员访问|	从左到右|	… . …|
||new（带参数列表）|	n/a|	new … ( … )|
|18| 函数调用|	从左到右|	… ( … )|
||new（无参数列表）|	从右到左|	new …|
|...|
|13| 加法|	从左到右|	… + …|
||减法|	从左到右|	… - …|


了解了原理之后，我们可以很轻松的将上面的问题解析为

```js
// 因为带参数列表的 new 优先级高于函数调用，所以不会先执行函数调用
(new provider[type].$get())(config);
```

这里还有一个扩展的小问题，下面的结果是多少

```js
var str = 'Hello' + true ? 'World' : 'JavaScript';
```

结果是 `World`， 因为 `+` 运算符优先级是高于条件运算符的，其实就相当于执行了 `('Hello' + true) ? 'World' : 'JavaScript'`

在来看一个操作符相关的问题

```js
function Foo() {
  getName = function () {
    console.log('1');
  };
  return this;
}
Foo.getName = function () {
  console.log('2');
};
Foo.prototype.getName = function () {
  console.log('3');
};
var getName = function () {
  console.log('4');
};
function getName() {
  console.log(5);
}

// 输出结果依次为多少
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

// 结果为 2 4 1 1 2 3 3
```

一个一个来看，首先我们来整理一下上面的代码，有几个需要注意的地方

```js
function Foo() {
  // 注意这里是全局的
  getName = function () {
    console.log('1');
  };
  return this;
}
```

还有下面这个，两者都会提升，但是函数声明的提升级别是要比 `var` 高的，所以实际执行的是

```js
function getName() {
  console.log(5);
}

// 会覆盖上面的
var getName = function () {
  console.log('4');
};
```


#### Foo.getName();

函数 `Foo` 本身并没有执行，执行的是函数的属性 `getName`，输出的是 `2`

#### getName();

这是在全局执行 `getName()`，根据我们上面的分析可知，输出的结果是 `4`

#### Foo().getName(); 

因为 () 的优先级最高（见 [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)），所以首先运行 `Foo()`，全局的 `getName` 被覆盖成输出 `console.log('1')`，并且返回的 `this` 此时代表的是 `window`

也就是相当于执行了 `window.getName()`，所以输出的结果为 `1`

#### getName();

这个因为之前调用了 `Foo()`，所以输出的结果仍然是 `1`

#### new Foo.getName();

因为 `.` 操作符要比 `new` 优先级要高，所以执行的是 `new (Foo.getName)()`，所以输出为 `2`

#### new Foo().getName();

根据优先级可知，带参数的 `new` 操作符是优先级最高的，所以执行的就是 `(new Foo()).getName()`

而 `new Foo()` 生成的对象身上没有 `getName()` 的方法，那么就会去 `prototype` 当中寻找，所以输出的是 `3`

#### new new Foo().getName();

老规矩，按照优先级添加括号，首先带参数的 `new` 操作符优先级最高，则为 `new (new Foo().getName())`

然后就会发现和上面是类似的，可以转换为 `new ((new Foo()).getName())`，所以输出的也为 `3`





## JavaScript 中的数据绑定

关于数据双向绑定，绑定的基础就是监听属性的变化事件（`propertyChange`），现在主流的框架当中的解决方法一般有以下几种

* `Knockout` / `Backbone`（发布/订阅模式），简单来说就是另外开发一套 `API`，但使用起来却不得不使用这套 `API` 来操作 `viewModel`，导致上手复杂、代码繁琐

* `Angular`（脏检查机制），特点是直接使用原生 `JavaScript` 来操作 `viewModel`，但脏检查机制随之带来的就是性能问题

* `Vue`（数据劫持，也就是 `Object.defineProperty`），会把定义的 viewModel 对象（即 `data` 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 `JavaScript` 操作对象，又可以主动触发 `propertyChange` 事件，效率虽高，但也有一些限制，见后文

另外的几种方式

* `Object.observe`，谷歌对于简化双向绑定机制的尝试，在 `Chrome 49` 中引入，然而由于性能等问题，并没有被其他各大浏览器及 `ES` 标准所接受，所以在后续版本当中移除了该方法的实现

* `Proxy`，是 `ES6` 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 `Object.observe` 以实现双向绑定）



#### 基于数据劫持实现的双向绑定

#### 什么是数据劫持

数据劫持比较好理解，通常我们利用 `Object.defineProperty` 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作

```js
// 这是将要被劫持的对象
const data = {
  name: '',
};

// 测试函数
function test(name) {
  console.log(name);
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function (key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      console.log(`get`);
    },
    set: function (newValue) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`set`);
      test(newValue);
    },
  });
});

data.name = `new name`;
```

#### 数据劫持的优势以及实现思路

目前业界分为两个大的流派，一个是以 `React` 为首的单向数据绑定，另一个是以 `Angular`、`Vue` 为主的双向数据绑定

两者主要有两点区别

* 无需显示调用，例如 `Vue` 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 `Angular` 的脏检测或是 `react` 需要显示调用 `setState`

* 可精确得知变化数据：例如上面的例子，我们劫持了属性的 `setter`，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 `diff` 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 `diff` 来找出变化值，这是额外性能损耗

本质上，基于数据劫持的双向绑定离不开 `Proxy` 与 `Object.defineProperty` 等方法对对象/对象属性的"劫持"，我们要实现一个完整的双向绑定需要以下几个要点

* 利用 `Proxy` 或 `Object.defineProperty` 生成的 `Observer` 针对对象/对象的属性进行"劫持"，在属性发生变化后通知订阅者

* 解析器 `Compile` 解析模板中的 `Directive`（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染

* `Watcher` 属于 `Observer` 和 `Compile` 桥梁，它将接收到的 `Observer` 产生的数据变化，并根据 `Compile` 提供的指令进行视图渲染，使得数据变化促使视图变化

![IMG](双向数据绑定.png)



#### 基于 Object.defineProperty 双向绑定

完整的实现可以见 [剖析Vue原理&实现双向绑定MVVM](https://segmentfault.com/a/1190000006599500)，比如上面的示例，就是一个简单的实现

但是很快就会发现，里面存在着一堆问题，比如我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等

我们可以参考 `Vue` 的实现方式，`Vue` 的操作就是加入了发布订阅模式，结合 `Object.defineProperty` 的劫持能力，实现了可用性很高的双向绑定

下面是一个完成的例子


```html
<main>
  <p>请输入:</p>
  <input type="text" id="input">
  <p id="p"></p>
</main>
```


```js
// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它
const Vue = (function() {

  let uid = 0;

  // 用于储存订阅者并发布消息
  class Dep {

    constructor() {
      // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher
      this.id = uid++;
      // 储存订阅者的数组
      this.subs = [];
    }

    // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身
    depend() {
      Dep.target.addDep(this);
    }

    // 添加订阅者
    addSub(sub) {
      this.subs.push(sub);
    }

    notify() {
      // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理
      this.subs.forEach(sub => sub.update());
    }
  }

  // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher
  Dep.target = null;
  
  // 现在我们需要实现监听者（Observer），用于监听属性值的变化
  // 监听者，监听对象属性值的变化
  class Observer {

    constructor(value) {
      this.value = value;
      this.walk(value);
    }

    // 遍历属性值并监听
    walk(value) {
      Object.keys(value).forEach(key => this.convert(key, value[key]));
    }

    // 执行监听的具体方法
    convert(key, val) {
      defineReactive(this.value, key, val);
    }

  }

  function defineReactive(obj, key, val) {

    const dep = new Dep();

    // 给当前属性的值添加监听

    let chlidOb = observe(val);
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () => {
        // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中
        // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者
        // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法
        if (Dep.target) {
          dep.depend();
        }
        return val;
      },
      set: newVal => {
        if (val === newVal) return;
        val = newVal;
        // 对新值进行监听
        chlidOb = observe(newVal);
        // 通知所有订阅者，数值被改变了
        dep.notify();
      },
    });
  }

  function observe(value) {
    // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听
    if (!value || typeof value !== 'object') {
      return;
    }
    return new Observer(value);
  }



  // 我们还需要实现一个订阅者（Watcher）
  class Watcher {

    constructor(vm, expOrFn, cb) {
      this.depIds = {}; // hash 储存订阅者的 id，避免重复的订阅者
      this.vm = vm;     // 被订阅的数据一定来自于当前 Vue 实例
      this.cb = cb;     // 当数据更新时想要做的事情
      this.expOrFn = expOrFn; // 被订阅的数据
      this.val = this.get();  // 维护更新之前的数据
    }

    // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用
    update() {
      this.run();
    }

    addDep(dep) {
      // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存
      // 此判断是避免同 id 的 Watcher 被多次储存
      if (!this.depIds.hasOwnProperty(dep.id)) {
        dep.addSub(this);
        this.depIds[dep.id] = dep;
      }
    }

    run() {
      const val = this.get();
      console.log(val);
      if (val !== this.val) {
        this.val = val;
        this.cb.call(this.vm, val);
      }
    }

    get() {
      // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者
      Dep.target = this;
      const val = this.vm._data[this.expOrFn];
      // 置空，用于下一个 Watcher 使用
      Dep.target = null;
      console.log(Dep.target, 2);
      return val;
    }
  }

  
  // 将上述方法挂载在 Vue 上
  class Vue {

    constructor(options = {}) {
      // 简化了 $options 的处理
      this.$options = options;
      // 简化了对 data 的处理
      let data = (this._data = this.$options.data);
      // 将所有 data 最外层属性代理到 Vue 实例上
      Object.keys(data).forEach(key => this._proxy(key));
      // 监听数据
      observe(data);
    }

    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者
    $watch(expOrFn, cb) {
      new Watcher(this, expOrFn, cb);
    }

    _proxy(key) {
      Object.defineProperty(this, key, {
        configurable: true,
        enumerable: true,
        get: () => this._data[key],
        set: val => {
          this._data[key] = val;
        },
      });
    }

  }

  return Vue;
})();


// 使用
let demo = new Vue({
  data: {
    text: '',
  },
});

const p = document.getElementById('p');
const input = document.getElementById('input');

input.addEventListener('keyup', function(e) {
  demo.text = e.target.value;
});

demo.$watch('text', str => p.innerHTML = str);
```


#### Object.defineProperty 的缺陷

其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组

```js
let demo = new Vue({
  data: {
    list: [1],
  },
});

const list = document.getElementById('list');
const btn = document.getElementById('btn');

btn.addEventListener('click', function () {
  demo.list.push(1);
});

const render = arr => {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < arr.length; i++) {
    const li = document.createElement('li');
    li.textContent = arr[i];
    fragment.appendChild(li);
  }
  list.appendChild(fragment);
};

// 监听数组，每次数组变化则触发渲染函数，然而却无法监听
demo.$watch('list', list => render(list));

setTimeout(
  function () {
    alert(demo.list);
  },
  5000,
);
```

是的，`Object.defineProperty` 的第一个缺陷，无法监听数组变化，然而 `Vue` 的文档提到了 `Vue` 是可以检测到数组变化的

其实简单来说，这里就是重写了原来的方法

```js
const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
const arrayAugmentations = [];

aryMethods.forEach((method) => {

  // 这里是原生 Array 的原型方法
  let original = Array.prototype[method];

  // 将 push, pop 等封装好的方法定义在对象 arrayAugmentations 的属性上
  // 注意：是属性而非原型属性
  arrayAugmentations[method] = function () {
    console.log('我被改变啦!');
    // 调用对应的原生方法并返回结果
    return original.apply(this, arguments);
  };

});

let list = ['a', 'b', 'c'];

// 将我们要监听的数组的原型指针指向上面定义的空数组对象
// 别忘了这个空数组的属性上定义了我们封装好的 push 等方法
list.__proto__ = arrayAugmentations;
list.push('d');  // 我被改变啦！ 4

// 这里的 list2 没有被重新定义原型指针，所以就正常输出
let list2 = ['a', 'b', 'c'];
list2.push('d');  // 4
```

由于只针对了八种方法进行了 `hack`，所以其他数组的属性也是检测不到的

我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 `Object.defineProperty` 的第二个缺陷，只能劫持对象的属性

因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是更好的选择

```js
Object.keys(value).forEach(key => this.convert(key, value[key]));
```



#### Proxy 实现的双向绑定

`Proxy` 在 `ES2015` 规范中被正式发布，它在目标对象之前架设一层"拦截"，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写

我们可以这样认为 `Proxy` 是 `Object.defineProperty` 的全方位加强版

`Proxy` 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 `Object.defineProperty`


#### Proxy 可以直接监听数组的变化

当我们对数组进行操作（`push`、`shift`、`splice` 等）时，会触发对应的方法名称和 `length` 的变化

下面是一个实例

```html
<main>
  <ul id="list">
  </ul>
  <button type="button" name="button" id="btn">添加列表项</button>
</main>
```

```js
const list = document.getElementById('list');
const btn = document.getElementById('btn');

// 渲染列表
const Render = {

  // 初始化
  init: function(arr) {
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < arr.length; i++) {
      const li = document.createElement('li');
      li.textContent = arr[i];
      fragment.appendChild(li);
    }
    list.appendChild(fragment);
  },

  // 我们只考虑了增加的情况，仅作为示例
  change: function(val) {
    const li = document.createElement('li');
    li.textContent = val;
    list.appendChild(li);
  },
};

// 初始数组
const arr = [1, 2, 3, 4];

// 监听数组
const newArr = new Proxy(arr, {
  get: function(target, key, receiver) {
    console.log(key);
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, value, receiver) {
    console.log(target, key, value, receiver);
    if (key !== 'length') {
      Render.change(value);
    }
    return Reflect.set(target, key, value, receiver);
  },
});

// 初始化
window.onload = function() {
  Render.init(arr);
}

// push 数字
btn.addEventListener('click', function() {
  newArr.push(6);
});
```

#### Proxy的优势

`Proxy` 有多种拦截方法，不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等，是 `Object.defineProperty` 不具备的

`Proxy` 返回的是一个新对象，我们可以只操作新的对象达到目的，而 `Object.defineProperty` 只能遍历对象属性直接修改



## 原型和闭包

主要参考 [深入理解javascript原型和闭包](http://www.cnblogs.com/wangfupeng1988/p/3977987.html)

#### 对象 - 若干属性的集合

```js
// 简单的值类型，不是对象
console.log(typeof x);                 // undefined
console.log(typeof 10);                // number
console.log(typeof 'abc');             // string
console.log(typeof true);              // boolean

// 函数其实也是对象，也是可以做为参数传递的
console.log(typeof function () { });   //function

// 引用类型
console.log(typeof [1, 'a', true]);    //object
console.log(typeof { a: 10, b: 20 });  //object
console.log(typeof null);              //object
console.log(typeof new Number(10));    //object
```

判断一个变量是不是对象，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`


#### 函数和对象的关系

对象是可以通过函数来创建

```js
//var obj = { a: 10, b: 20 };
//var arr = [5, 'x', true];

var obj = new Object();
obj.a = 10;
obj.b = 20;

var arr = new Array();
arr[0] = 5;
arr[1] = 'x';
arr[2] = true;
```

#### prototype

每个函数都有一个属性叫做 `prorotype`，这个 `prototype` 的属性值是一个对象（属性的集合），默认的还有一个叫做 `constructor` 的属性，指向这个函数本身

![prototype01](http://images.cnitblog.com/blog/138012/201409/172121182841896.png)

例如 `Object` 的 `prototype` 上就挂载了一系列方法

![prototype02](http://images.cnitblog.com/blog/138012/201409/172130097842386.png)

我们也可以在自己自定义的方法的 `prototype` 中新增自己的属性

```js
function Foo () {...}

Foo.prototype.name = ..

Foo.prototype.getName = function () {..}

var bar = new Foo();
console.log(bar.name);
console.log(bar.getName());
```

`Foo` 是一个函数，`bar` 对象是通过 `Foo` 函数 `new` 出来的，这样一来，`bar` 对象就可以调用 `Foo.prototype` 上的属性和方法

因为每个对象都有一个隐藏的属性 `__proto__`（一般称为 隐式原型），这个属性引用了创建这个对象的函数的 `prototype`，即

```js
bar.__proto__ === Foo.prototype  // true
```

#### instanceof

对于值类型可以使用 `typeof` 判断，但是对于引用类型的时候，返回值只有 `object/function`，这个时候就可以使用 `instanceof`

![instanceof](http://images.cnitblog.com/blog/138012/201409/181635468939277.png)

比如判断 `f1 instanceof Object`，按照上图来说就是：

* 沿着 `f1` 的 `__proto__` 这条线来找，同时沿着 `Object` 的 `prototype` 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 `true`，如果找到终点还未重合，则返回 `false`

这也解释了为何一下结果均返回 `true`

```js
Object instanceof Function;    // true

Function instanceof Object;    // true

Function instanceof Function;  // true
```

完整原型图如下所示：

![原型链](http://images.cnitblog.com/blog/138012/201409/181637013624694.png)

* `instanceof` 表示的就是一种继承关系，或者原型链的结构

一个小小的练习题：

```js
var a = {
  x: 1,
  y: { z: 2 }
};

var b = {};
b.__proto__ = a;

// a 和 b 都是对象（通过new Object() 生成，这里是简写）
// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）
// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），原则上应该去 Object.prototype 上查找 
// 但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找
// 所以 b.x 为 1，b.y 为 { z: 2 }
console.log(a.x);
console.log(b.x);

// 然后把 b.x 重新赋值为 22
// 因为是基本类型，所以 a.x 是不变的
b.x = 22;
console.log(a.x);
console.log(b.x);

// 这个同上面那个类似
// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址
// 其中一个变化的话自然会引起另外一个变化
b.y.z = 33;
console.log(a.y.z);
console.log(b.y.z);
```


#### 继承

访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 `__proto__` 这条链往上找，这就是原型链

可以利用 `hasOwnProperty` 来区分一个属性是不是从原型上继承得到的（特别是在 `for..in` 循环中）

`hasOwnProperty` 这个方法存在与 `Object.prototype` 上，对象的原型链是沿着 `__proto__` 这条线走的，因此在查找对象的 `hasOwnProperty` 属性的时候，就会顺着原型链一直查找到 `Object.prototype`

由于所有的对象的原型链都会找到 `Object.prototype`，因此所有的对象都会有 `Object.prototype` 的方法，这就是所谓的**继承**

同样的，每个函数都有 `call`，`apply` 方法，这也是"继承"而来的，函数由 `Function` 函数构建，因此继承的 `Function.prototype` 中的方法

至于为什么 `Function.prototype` 上也会有 `hasOwnProperty` 方法，这是因为 `Function.prototype` 同样继承自 `Object.prorotype`




#### 执行上下文环境

简单来说，函数**每被**调用一次，都会产生一个新的执行上下文环境，因为不同的调用可能就会有不同的参数

需要注意一点：函数体内部自由变量在函数在定义的时候（不是调用的时候）就已经确定了

`javascript` 在执行一个代码段之前，都会进行这些 "准备工作" 来生成执行上下文，其实分三种情况 -- 全局代码，函数体，`eval` 代码（不推荐这个）


#### 全局执行上下文环境

在产生执行全局上下文时，浏览器通常会做以下三个准备工作：

* 提取 `var` 声明的变量，并赋值（默认）为 `undefined`（变量提升）

* 提取声明式函数（`function foo () {..}`）

* 给 `this` 赋值（指向 `window` 或当前对象）


#### 函数体上下文环境（也就是所谓的局部）

会在以上三个的基础上增加以下三条：

* 给函数参数赋值

* 给 `arguments` 赋值（是一个实参副本，与实参保持一致）

* 自由变量的取值作用域，查找并赋值

所以总结来说就是，**在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空**

而在执行 `js` 代码时，会有数不清的函数调用次数，会产生许多个上下文环境，这么多上下文环境该如何管理，以及如何销毁而释放内存就主要依靠下面的**执行上下文栈**

#### 执行上下文栈

执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境

处于活动状态的执行上下文环境只有一个

其实这是一个 **压栈** ==> **出栈** 的过程，如下图所示：

* 压栈：函数未调用时只有全局上下文在执行，每次调用函数时会产生局部上下文，这就是压栈，也就是进栈

* 出栈：函数调用完成后，就会出栈，会销毁本次调用的局部上下文环境

注意：若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的）

![执行上下文栈](http://images.cnitblog.com/blog/138012/201409/232122300768665.png)

上面这种只是较为理想的情况，有一种情况无法做到这样干净利落的说销毁就销毁，这个就是 -- 闭包


#### this

`this` 是 `Javascript` 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用

随着函数使用场合的不同，`this` 的值会发生变化，但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象

`JavaScript` 中函数的调用有以下几种方式：

* 为对象方法调用

* 作为函数调用

* 作为构造函数调用

* 使用 `apply` 或 `call` 调用

一个小案例，在 `jQuery` 中，有下面这样一段代码：

```js
jQuery.extend = jQuery.fn.extend = function () {
  // ...
  if (i === length) {
    target = this;
    i--;
  }
  // ...
}
```

`jQuery.extend` 和 `jQuery.fn.extend` 都指向了同一个函数，但是当执行时，函数中的 `this` 是不一样的

执行 `jQuery.extend( .. )` 时，this 指向 `jQuery`

执行 `jQuery.fn.extend( .. )` 时，this 指向 `jQuery.fn`

这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则


#### 作用域

`javascript` 中没有块级作用域（`ES6` 之前），除了全局作用域以外，只有函数可以创建作用域

我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好（先声明，在使用），除了这两个地方，其他地方都不要出现变量声明

作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突

除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数**定义时**就已经确定了，而不是在函数**调用时**确定

抽象来看待的话，作用域只是一个 "地盘"，其中没有变量，要通过**作用域对应的执行上下文环境**来获取变量的值

同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了

所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值

## 自由变量 到 作用域链

所谓自由变量，指的是在当前作用域中未声明的变量，会去到**创建这个函数的作用域中去取值，而不是简简单单的上一级（注意，是创建，不是调用）**，这就是所谓的静态作用域

```js
var x = 100;

function foo() {
  console.log(x);
}

function bar(fn) {
  var x = 200;

  (function () {
    fn();  // 100
  })()
}

bar(foo);
```

如果没有找到，则继续往上找，一直到全局作用域为止，如果还没有找到，那就是不存在了，这个过程可以称之为**作用域链**


#### 上下文环境和作用域的关系

* 上下文环境：可以理解为一个抽象的东西，程序执行前，会生成全局上下文环境，函数在调用的时候会创建函数上下文环境

* 作用域：**除了全局作用域，只有函数才能创建作用域（ES6 之前）**，创建一个函数就创建了一个作用域，无论你调不调用，函数只要创建了，它就有独立的作用域

* 两者的区别在于：一个作用域可能没有（函数没被调用），也可能存在过（调用完成，上下文环境被摧毁），也有可能同时存在多个（闭包）上下文环境

一个简单的小例子：

```js
var x = 100;

function fn (x) {
    return function () {
        console.log(x);
    }
}

var f1 = fn(5);
var f2 = fn(10);

f1();  // 5
f2();  // 10
```





## 闭包

只需要记住应用的两种情况即可

#### 第一种 函数作为返回值

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

`bar` 函数作为返回值，赋值给 `f1` 变量，执行 `f1(15)` 时，用到了 `fn` 作用域下的 `max` 变量的值

#### 第二种 函数作为参数传递

```js
var max = 10,
  fn = function (x) {
    if (x > max) {
      console.log(x)
    }
  };

(function (f) {
  var max = 100;
  f(11);  // 11
})(fn)
```

`fn` 作为一个参数传递进入另一个函数，赋值给 `f` 参数，执行 `f(11)` 的时候，`max` 取值是 `10`，而不是 `100`

之前提到过，当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁，但是在有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁，这里指的就是闭包，以上面第一种代码为例

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

* 代码执行前的全局上下文环境，并在执行时对其中的变量进行赋值，此时全局上下文环境（活动状态）中的 `max` 为 `undefined`

* 当调用 `fn()` 时会产生 `fn()` 执行上下文环境（活动状态），此时 全局中的 `max` 仍为 `undefined`，`fn()` 上下文环境中的 `max` 为 `10`

* 当 `fn()` 调用完成，按理说应该销毁掉 `fn()` 的执行上下文环境，但是**返回的是一个函数，函数的特别之处在于可以创建一个独立的作用域**

  * 而返回的这个函数体中，还有一个自由变量 `max` 要引用 `fn` 作用域下的 `fn()` 上下文环境中的 `max`

  * 因此，这个 `max` 不能被销毁，销毁了之后 `bar` 函数中的 `max` 就找不到值了

  * 所以这里的 `fn()` 上下文环境不能被销毁，还依然存在与执行上下文栈中

* 当执行到 ```var max = 100``` 的时候，`fn()` 上下文环境依然会在执行上下文栈中，当执行完成后，全局中的 `max` 为 `100`，而 `fn()` 上下文环境中的 `max` 仍为 `10`

* 当执行最后的 `f1(5)` 的时候，即执行返回的函数 `bar(5)`，此时，`bar()` 上下文环境中的 `x` 为 `5`，而 `max` 变量是自由变量，需要向创建 `bar` 函数的作用域中查找，找到了 `max` 的值为 `10`

这里的重点就在于，创建 `bar` 函数是在执行 `fn()` 时创建的，`fn()` 早就执行结束了，但是 `fn()` 执行上下文环境还存在与栈中，因此 `bar(5)` 时，`max` 可以查找到，如果 `fn()` 上下文环境销毁了，那么 `max` 就找不到了，这也是为什么使用闭包会增加内容开销





## ES6 的一些新方法

#### let 命令

* 只要块级作用域内存在 `let` 命令，它所声明的变量就 "绑定"（`binding`）这个区域，不再受外部的影响

* `typeof` 不再是一个百分比安全的操作（如果一个变量根本没有被声明，使用 `typeof` 反而不会报错）

* `function bar(x = y, y = 2) {}` （`y` 没有声明，所以会报错）

* 不允许重复声明

* 块级作用域的出现，使得立即执行函数表达式（`IIFE`）不再必要了

* 建议避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

* 允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错

* 在 `ES6` 浏览器中（只对 `ES6` 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 `let` 处理）

 * 允许在块级作用域内声明函数

 * 函数声明类似于 `var`，即会提升到全局作用域或函数作用域的头部

 * 同时，函数声明还会提升到所在的块级作用域的头部

```js
// 不报错
"use strict";
if (true) {
  function f() { }
}

// 报错
"use strict";
if (true)
  function f() { }
```




#### const 命令

* 声明一个只读常量，一旦声明，常量的值就不能改变，而且必须立即初始化，不能留到以后在赋值

* `const foo = {};`

 * 常量 `foo` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 `foo` 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

* 与 `let` 命令相似之处：

 * 只能在声明所在的块级作用域内有效

 * 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用

 * 不可重复声明



#### 字符串的扩展

* 添加了遍历器接口，使得字符串可以被 `for...of` 循环遍历

* 添加了三个用于查询字符串位置的函数：

 * `includes()`： 返回布尔值，表示是否找到了参数字符串

 * `startsWith()`： 返回布尔值，表示参数字符串是否在源字符串的头部

 * `endsWith()`： 返回布尔值，表示参数字符串是否在源字符串的尾部

以上三个方法都支持第二个参数，表示开始搜索的位置，不同之处在于 `endsWith` 针对前 `n` 个字符，而其他两个方法针对从第 `n` 个位置直到字符串结束。

* `repeat()` 方法返回一个新字符串，表示将原字符串重复 `n` 次

 * 如果是小数，则会被取整（`2.2 => 2`, `2.9 => 2`）

 * 如果是负数（小于-1）或者 `Infinity`，则会报错

 * 如果是 `0` 到 `-1` 之间的小数，则等同于 `0`，因为会先进行取整运算（`NaN` 也等同于 `0`）

 * 如果参数是字符串，则会先转换为数字（`"3" => 3`, `"na" => ""`）

* 新增了模版字符串

```js
$("#result").append(`
    There are <b> ${basket.count} </b> items
    in your basket, <em> ${basket.onSale} </em>
    are on sale!`
);
```

 * 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义（``\`Hello\` World!``）

 * 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中

 * 如果想去掉模版字符串开头和结尾处的换行，可以使用 `trim` 方法消除它

 * 如果大括号内部是一个字符串，将会原样输出（`Hello ${"World}` => "Hello World"）

 * 模板字符串中也可以嵌入变量以及调用函数，比如 `${user.name}`，`${fn()}`




#### 对象的扩展

* 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = "bar";
var baz = {foo};
baz;  // {foo: "bar"}
```

* 方法也可以简写 `method () {return "hello"}`

* 可以用于函数的返回值：

```js
function getPoint () {
  var x = 1;
  var y = 2;
  return {x, y};
}

getPoint();  // {x: 1, y: 2}
```

* 新增属性名表达式 `obj["a" + "bc"] = 123;`

 * 表达式也可以用于定义方法名

* 属性名表达式与简洁表示法，不能同时使用，否则会报错

* 特别注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 `[object, Object]`

```js
const myObject = {
  [keyA]: "valueA",
  [keyB]: "valueB"
};

// [keyB] 会把 [keyA] 覆盖掉，而 myObject 最后只有一个 [object Object] 属性
```



#### 数值的扩展

* `parseInt()` 和 `parseFloat()` 移植到了 `Number` 对象上面 （`Number.parseInt("1*34")  // 12`）

* `Number.isInteger()` 用来判断一个值是否为整数（在 `JavaScript` 内部，整数和浮点数是同样的储存方法，所以 `3` 和 `3.0` 被视为同一个值）

`Math` 对象扩展：

* `Math.trunc()` 方法用于去除一个数的小数部分，返回整数部分

 * 对于非数值，内部会先使用 `Number` 方法将其先转为数值

 * 对于空值和无法截取整数的值，返回 `NaN`

* `Math.sign()` 方法用来判断一个数到底是正数，负数，还是零，会返回五种值：

 * 参数为正数，返回 `+1`

 * 参数为负数，返回 `-1`

 * 参数为 `0`，返回 `0`

 * 参数为 `-0`，返回 `-0`

 * 其他值，返回 `NaN`

* `Math.cbrt()` 方法用于计算一个数的立方根

* `Math.hypot()` 返回所有参数的 平方和 的 平方根 

```js 
Math.hypot(3, 4);  // 5（3 的平方 + 4 的平方 等于 5 的平方）
```




#### 数组的扩展

* `Array.from()` 将 类似数组的对象（`array-like-object`） 和 可遍历（`iterable`）的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）转为 **真正的数组**

 * 接受的第二个参数，作用类似于数组的 `map` 方法，用来对每个元素进行处理，将处理后的结果放入返回的数组

 * 如果 `Array.from()` 没有参数，就返回一个**空数组**

* `Array.of()` 用于将一组值，转换为数组（因为在 `ES5` 中，参数个数的不同，会导致 `Array()` 的行为有差异）

* `find()` 方法，用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 `true` 的成员，并返回，如果没有找到符合条件的成员，则返回 `undefined`

 * 回调函数可以接受三个参数，依次为 当前的值、当前的位置 和 原数组

* `findIndex()` 方法的用法与 `find()` 方法非常相似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 `-1`

 * `find()` 方法和 `findIndex()` 方法都可以发现 `NaN`，弥补了数组的 `indexOf` 方法的不足

* `fill()` 方法使用给定值，填充一个数组

 * 需要注意的是，数组中已有的元素，会被全部抹去

 * 可以指定第二个和第三个参数，用于指定填充的起始位置和结束位置

* 提供了三个新的方法来用于遍历数组，它们都返回一个遍历器对象，可以用 `for...of` 循环进行遍历（如果不使用 `for...of` 循环，可以手动调用遍历器对象的 `next()` 方法，进行遍历）

 * `keys()` 是对**键名**的遍历

 * `values()` 是对**键值**的遍历

 * `entries()` 是对**键值对**的遍历

* `Array.prototype.includes` 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 `includes` 方法类似

 * 第二个参数表示搜索的起始位置，默认为 `0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 `-4`，但数组长度为 `3`），则会重置为从 `0` 开始

`Map` 和 `Set` 数据结构有一个 `has` 方法，需要注意与 `includes` 区分

* `Map` 结构的 `has` 方法，是用来查找**键名**的，比如 `Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`

* `Set` 结构的 `has` 方法，是用来查找**值**的，比如 `Set.prototype.has(value)`、`WeakSet.prototype.has(value)`





#### 解构

```js
// 属于"模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值
var [a, b, c] = [1, 2, 3]
```

* 如果解构不成功，变量的值就等于 `undefined`

* 如果等号右边不是数组（不是可遍历的解构，不具有 `Iterator` 接口），那么将会报错（`number`，`string`，`false`，`NaN`，`undefined`，`null`，`{ }` 等）

* 只要某种数据具有 `Iterator` 接口，都可以采用数组形式的解构赋值

* 解构赋值允许指定默认值（内部使用的是严格相等运算符 `===`）

* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

* 对象的解构

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" }
```

* 对象的属性没有次序，变量必须与属性同名，才能取到正确的值

```js
let foo;
({ foo } = { foo: 1 }); // success

let baz;
({ bar: baz } = { bar: 1 }); // success
```

上例中的圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句




#### 字符串的解构

字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象



#### 数值和布尔值的解构

解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象

规则是，只要等号右边的值不是对象，就先将其转为对象，由于 `undefined` 和 `null` 无法转为对象，所以对它们进行解构赋值，都会报错



#### 函数相关

* 在 `ES6` 中，允许函数的参数设置默认值，即直接写在参数定义的后面（函数参数的默认值）

 * 参数变量是默认声明的，所以不能使用 `let` 或者 `const` 再次声明

 * 指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值以后，`length` 属性将失效（length属性的含义是，该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了）

* 如果设置了默认值的参数不是尾参数（即设置默认值的不是最后一个参数），那么 `length` 属性也不再计入后面的参数了

* 如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域

* 用于将一个数组转为用都好分隔的参数序列（`console.log(...[1, 2, 3])`）

* 在 ES5 中，如果将一个匿名函数赋值给一个变量，其 `name` 属性，会返回空字符串，而 ES6 中修正了这个问题，会返回实际的函数名

 * `Function` 构造函数返回的函数实例，`name` 属性的值为 `anonymous`

 * `bind` 返回的函数，`name` 属性会加上 `bound` 前缀

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 `return` 语句返回

```js
var sum = (num1, num2) => { return num1 + num2; }
```

* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号

```js
var getTempItem = id => ({ id: id, name: "Temp" });
```

* 箭头函数的使用注意点

 * 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象（例如在 `Vue` 的实例属性或回调函数中就不建议使用箭头函数，因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是对应方法未被定义）

 * 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误

 * 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `Rest` 参数代替

 * 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数

 * 需要特别注意的是：`this` 对象的指向是可变的，但是在箭头函数中，它是固定的

 * 箭头函数中的 `this` 指向的固定化，并不是因为箭头函数内部有绑定 `this` 的机制，实际原因是箭头函数根本没有自己的 `this`，导致内部的 `this` 就是外层代码块的 `this`（正式因为它没有 `this`，所以也就不能用作构造函数）



#### Symbol

`ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值，它是 `JavaScript` 第七种数据类型

```js
// 变量 s 就是一个独一无二的值
let s = Symbol();

// typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型
typeof s
// "symbol"
```








#### Object.assign()

`Object.assign()` 方法可以把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象

需要注意的是

* 对于访问器属性，该方法会执行所属访问器的 `getter` 函数，然后把得到的值拷贝给目标对象

  * 如果想拷贝访问器属性本身，可以使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperties()` 方法

* 字符串类型和 `symbol` 类型的属性都会被拷贝

* 在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 `TypeError` 异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性则不会再被拷贝



#### 利用 JSON 进行忽略原型链的深拷贝

```js
var dest = JSON.parse(JSON.stringify(target));
```

同样有缺点，它会忽略掉值为 `undefuned` 的属性以及函数表达式，但不会忽略值为 `null` 的属性


#### 规避原型链属性上的拷贝

#### 使用 hasOwnProperty

```js
for (let key in targetObj) {
  if (targetObj.hasOwnProperty(key)) {
    // ...
  }
}
```

也有一些缺点，就是会遍历了原型链上所有的属性，效率不高

#### Object.keys()

```js
const keys = Object.keys(targetObj);

keys.map((key) => {
  // ...
})
```

这个需要注意的是，只会返回参数对象自身的（不含继承的）所有可遍历（`enumerable`）属性的键名所组成的数组


#### 另辟蹊径

```js
const obj = Object.create(null);
target.__proto__ = Object.create(null);

for (let key in target) {
  // 相关操作
}
```



## fileReader 接口

`FileReader` 接口主要是将文件读入内存，并提供相应的方法，来读取文件中的数据，当然就能显示本地图片不需上传了

一个简单的示例如下：

```js
var result = document.getElementById('result');
var file = document.getElementById('file');

// 判断浏览器是否支持 FileReader 接口
if (typeof FileReader == 'undefined') {
  result.InnerHTML = '<p>你的浏览器不支持 FileReader 接口！</p>';
  // 使选择控件不可操作
  file.setAttribute('disabled', 'disabled');
}

function readAsDataURL() {
  // 检验是否为图像文件
  var file = document.getElementById('file').files[0];
  if (!/image\/\w+/.test(file.type)) {
    alert('格式不正确！');
    return false;
  }
  var reader = new FileReader();
  // 将文件以 Data URL 形式读入页面
  reader.readAsDataURL(file);
  reader.onload = function (e) {
    var result = document.getElementById('result');
    // 显示文件
    result.innerHTML = '<img src= ' + this.result + ' >'
  }
}
```

```html
<p>
  <input type='file' id='file' />
  <input type='button' value="读取图像" onclick="readAsDataURL()" />
</p>

<div id='result' name='result'></div>
```

预览完成后就可以上传到服务器了：

```js
$('#submitBtn').submit(function () {
  if ($('#upload_file').val()) {
    $('#upload_btn').attr('disabled', true);
    $('.tip').html('正在上传中，请稍候...');
    $(this).ajaxSubmit({
      type: 'post',
      url: url,
      success: function (data) { // 提交成功的回调函数
        // ...
        $('#upload_btn').attr('disabled', false);
        $('.tip').html('');
      }

    });
  }
  return false; // 不刷新页面
});
```

#### FileReader 的方法和事件

```js
// 方法
abort	                          // 中断读取

readAsText(file, [encoding])	  // 将文件读取为文本该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8
                                // 这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容

readAsBinaryString(file)        // 将文件读取二进制码通常我们将它传送到后端，后端可以通过这段字符串存储文件

readAsDataURL(file)             // 将文件读取为 DataURL 将文件读取为一串Data URL字符串，
                                // 将小文件以一种特殊格式的URL地址直接读入页面，小文件指图像与html等格式的文件


// 事件
onabort	        //  数据读取中断时触发

onerror	        //  数据读取出错时触发

onloadstart     //  数据读取开始时触发

onload	        //  数据读取成功完成时触发

onloadend       //  数据读取完成时触发，无论成功失败
```


#### 分段读取文本信息（slice）

有的时候，一次性将一个大文件读入内存，并不是一个很好的选择（如果文件太大，可能直接导致浏览器崩溃），更稳健的方法是分段读取

`HTML5 File Api` 提供了一个 `slice` 方法，允许分片读取文件内容

文件一旦开始读取，无论成功或失败，实例的 `result` 属性都会被填充，如果读取失败，则 `result` 的值为 `null` ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值

```js
function readBlob(start, end) {
  var files = document.getElementById('file').files;

  if (!files.length) {
    alert('请选择文件');
    return false;
  }

  var file = files[0],
    start = parseInt(start, 10) || 0,
    end = parseInt(end, 10) || (file.size - 1);

  var r = document.getElementById('range'),
    c = document.getElementById('content');

  var reader = new FileReader();
  reader.onloadend = function (e) {
    if (this.readyState == FileReader.DONE) {
      c.textContent = this.result;
      r.textContent = 'Read bytes: ' + (start + 1) + ' - ' + (end + 1) + ' of ' + file.size + ' bytes';
    }
  };

  // 兼容
  var blob;
  if (file.webkitSlice) {
    blob = file.webkitSlice(start, end + 1);
  } else if (file.mozSlice) {
    blob = file.mozSlice(start, end + 1);
  } else if (file.slice) {
    blob = file.slice(start, end + 1);
  }

  reader.readAsBinaryString(blob);

};

document.getElementById('file').onchange = function () {
  readBlob(10, 100);
}
```


使用了 `FileReader` 的 `onloadend` 事件来检测读取成功与否，如果用 `onloadend` 则必须检测一下 `FileReader` 的 `readyState`，因为 `read abort` 时也会触发 `onloadend` 事件，如果我们采用 `onload`，则可以不用检测 `readyState`

#### FileReader 进度条

既然 `FileReader` 是异步读取文件内容，那么就应该可以监听它的读取进度，事实上，`FileReader` 的 `onloadstart` 以及 `onprogress` 等事件，可以用来监听 `FileReader` 的读取进度

在 `onprogress` 的事件处理器中，提供了一个 `ProgressEvent` 对象，这个事件对象实际上继承了 `Event` 对象，提供了三个只读属性：`lengthComputable`、`loaded`、`total`，通过以上几个属性，即可实时显示读取进度

```js
interface ProgressEvent : Event {
  readonly attribute boolean lengthComputable;
  readonly attribute unsigned long long loaded;
  readonly attribute unsigned long long total;
};
```

`ajax` 上传并显示进度条：

```js
function upLoad() {

  var myPic = document.querySelector('myPic').files[0];
  var fd = new FormData();
  fd.append('myPic', myPic);

  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && xhr.status == 200) {
      alert(xhr.responseText);
    }
  }

  // 监听附件上传情况
  xhr.upload.onprogress = function () {
    //  evt.loaded  -- 已经上传大小
    //  evt.total   -- 附件总大小
    var loaded = evt.loaded;
    var tot = evt.total;
    var per = Math.floor(100 * loaded / tot);
    var son = document.getElementById('flag');
    flag.innerHTML = per + '%';
    flag.style.width = per + '%';
  }

  var url = '';
  xhr.open('POST', url);
  xhr.send(fd);
}
```


#### 扩展：FormData 对象

`FormData` 对象，可以把 `form` 中所有表单元素的 `name` 与 `value` 组成一个 `queryString`，提交到后台

用 `jQuery` 的方法来说，就是 `serialize` 了，但是在使用 `Ajax` 提交时，这过程就变成人工的了，因此，使用 `FormData` 对象可以减少拼接 `queryString` 的工作量

1. 可以先创建一个空的 `FormData` 对象，然后利用 `append` 方法向该对象添加字段（`key/value`）

```js
var myForm = new FormData();

myForm.append('name', 'zhangsan');
myForm.append('name', 'lisi');
myForm.append('num', 222333);  // 数字会被转换成字符串
```

2. 或者可以取得 `form` 元素对象，然后将其作为参数传入 `FormData` 对象中

```js
var myForm = document.querySelector('#myForm');
var formdata = new FormData(myForm);
```

3. 利用 `getFormData` 生成

```js
var myForm = document.querySelector('#myForm');
var formdata = myForm.getFormData();
```

4. 使用 `FormData` 提交表单：

```js
function fsubmit() {
  var data = new FormData($('#myForm')[0]);
  $.ajax({
    url: 'upLoad.html',
    type: 'POST',
    data: data,
    dataType: 'JSON',
    cahce: false,
    processData: false,
    contentType: false,
    success: function () {
      // ...
    }
  })
}
```


#### 扩展：window.URL.createObjectURL

`window.URL.createObjectURL` 的作用是创建一个新的对象 `URL`,该对象 `URL` 可以代表某一个指定的 `File` 对象或 `Blob` 对象

关于 `Bold` 对象，见 [MDN -Bold](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)

大体的意思就是

* `File` 对象,就是一个文件，比如我用 `input type='file'` 标签来上传文件,那么里面的每个文件都是一个 `File` 对象

* `Blob` 对象,就是二进制数据,比如通过 `new Blob()` 创建的对象就是 `Blob` 对象.又比如,在 `XMLHttpRequest` 里,如果指定 `responseType` 为 `blob`,那么得到的返回值也是一个 `blob` 对象

```js
objectURL = window.URL.createObjectURL(blob);
// blob 参数是一个 File 对象或者 Blob 对象
// objectURL 是生成的对象 URL 通过这个 URL，可以获取到所指定文件的完整内容

```

每次调用 `createObjectURL` 的时候，一个新的 `URL` 对象就被创建了，即使你已经为同一个文件创建过一个 `URL`

如果你不再需要这个对象，要释放它，需要使用 `URL.revokeObjectURL()` 方法

当页面被关闭，浏览器会自动释放它，但是为了最佳性能和内存使用，当确保不再用得到它的时候，就应该释放它

利用 `window.URL.createObjectURL` 显示图片：

```html
<input type= 'file' id= 'fileElem' multiple accept= 'image/*' style= 'display:none' onchange= 'handleFiles(this.files)'>
<a href='#' id='fileSelect'>Select some files</a>

<div id='fileList'>
  <p>No files selected!</p>
</div>
```

```js
window.URL = window.URL || window.webkitURL;

var fileSelect = document.getElementById('fileSelect'),
  fileElem = document.getElementById('fileElem'),
  fileList = document.getElementById('fileList');

fileSelect.addEventListener('click', function (e) {
  if (fileElem) {
    fileElem.click();
  }
  e.preventDefault(); // prevent navigation to '#'
}, false);

function handleFiles(files) {
  if (!files.length) {
    fileList.innerHTML = '<p>No files selected!</p>';
  } else {
    fileList.innerHTML = '';
    var list = document.createElement('ul');
    fileList.appendChild(list);
    for (var i = 0; i < files.length; i++) {
      var li = document.createElement('li');
      list.appendChild(li);

      var img = document.createElement('img');
      img.src = window.URL.createObjectURL(files[i]);
      img.height = 60;
      img.onload = function () {
        window.URL.revokeObjectURL(this.src);
      }
      li.appendChild(img);
      var info = document.createElement('span');
      info.innerHTML = files[i].name + ': ' + files[i].size + ' bytes';
      li.appendChild(info);
    }
  }
}
```

如果有现成的 `'img'` 标签

```js
function upLoadImg() {
  var myPic = document.getElementById('myPic').files[0];
  document.getElementsByTagName('img')[0].src = window.URL.createObjectURL(myPic);
}
```


#### 分段读取进度

```js
var bar = document.getElementById('progress-bar');
var progress = document.getElementById('progress');

var input = document.getElementById('file');
var block = 1 * 1024 * 1024; // 每次读取 1M

// 当前文件对象
var file;

// 当前已读取大小
var fileLoaded;

// 文件总大小
var fileSize;

// 每次读取一个 block
function readBlob() {
  var blob;
  if (file.webkitSlice) {
    blob = file.webkitSlice(fileLoaded, fileLoaded + block + 1);
  } else if (file.mozSlice) {
    blob = file.mozSlice(fileLoaded, fileLoaded + block + 1);
  } else if (file.slice) {
    blob = file.slice(fileLoaded, fileLoaded + block + 1);
  } else {
    alert('不支持分段读取！');
    return false;
  }
  reader.readAsBinaryString(blob);
}

// 每个 blob 读取完毕时调用
function loadHandler(e) {
  fileLoaded += e.total;
  var percent = fileLoaded / fileSize;
  if (percent < 1) {
    // 继续读取下一块
    readBlob2();
  } else {
    // 结束
    percent = 1;
  }
  percent = Math.ceil(percent * 100) + '%';
  progress.innerHTML = percent;
  progress.style.width = percent;
}

function fileSelect(e) {
  file = this.files[0];
  if (!file) {
    alert('文件不能为空！');
    return false;
  }
  fileLoaded = 0;
  fileSize = file.size;
  bar.style.display = 'block';
  // 开始读取
  readBlob2();
}

var reader = new FileReader();
// 只需监听 onload 事件

reader.onload = loadHandler;
input.onchange = fileSelect
```


参考：

[leejersey](http://www.cnblogs.com/leejersey/p/4772504.html)

[HTML5 之 FileReader 的使用](http://blog.csdn.net/jackfrued/article/details/8967667)

[JavaScript File API](http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload/)








## call 和 apply 的第一个参数

`call` 和 `apply` 用来改变函数的执行上下文（`this`），它们的第一个参数 `thisArg` 是个对象，即作为函数内的 `this`

在多数时候你传递什么给函数，那么它就是什么

```js
function fun() {
  alert(this);
}

fun.call(1);                // 1

fun.call('a');              // a

fun.call(true);             // true

fun.call({name: 'aaa'});    // [object Object]
```

有两种情况需要注意，传递 `null` 或 `undefined` 时，执行环境会是全局的（`window/global`）

可以参考[规范 15.3.4.4](http://lzw.me/pages/ecmascript/#323)

```js
fun.call(null);       // window
fun.call(undefined);  // window
```

但是在严格模式下，给 `call` 和 `apply` 传入的任何参数不再会转换

```js
'use strict'
function fun() {
  alert(this);
}

fun.call(null);        // null
fun.call(undefined);   // undefined
```

另外一个例子

```js
function foo(x, y) {
  'use strict';
  console.log(x, y, this);
}

foo.apply(null);        // undefined undefined null
foo.apply(undefined);   // undefined undefined undefined
```
























## 判断是否是数组 isArray

```js
var isArray = function (value) {
  return value && typeof value === "object" && value.constructor === "Array";
}
```

上面这个方法在 从不同的窗口（`window / frame`）里构造的数组的时候会失败，所以我们不得不考虑更多

```js
var isArray = function (value) {
  return value && typeof value === "object"
    && typeof value.length === "number"
    && typeof value.slice === "function"
    && !(value.propertyIsEnumerable("length"));
}
```

首先，我们要判断这个值是否为真，不接受 `null` 和其他为假的值

其次判断 `typeof` 运算的结果是否为 `object`，对于对象，数组和 `null` 来说，返回的是 `true`（但是对于对象来说并非如此）

然后判断这个值是否包含一个 `splice` 的方法，对于数组来说，又将会得到 `true`

最后判断 `length` 属性是否是可枚举的，对于数组来说，将得到 `false`













## 从请求的异步回调函数中取值的解决办法

问题如下

```js
function load_val() {
  $.get('url', function (data) {
    // 如何把这里取到的 data 通过 load_val 函数返回出去？
  });
}
```

如果通过一个全局变量来获取，自然也不是不可以，不过这里就涉及到一点：如果使用了全局变量来获取后，该怎么使用呢？

还是上面这个例子，我们稍微改造一下

```js

var obj = '';

function load_val() {
  $.get('url', function (data) {
    // 在此处将 data 赋予全局变量
    obj = data;
  });
}

// 调用函数获取数据
load_val();

function use_val() {
  obj += 1;
  console.log(obj);
}

use_val();
```

上面这个例子很好理解，我们想通过 `obj` 这个全局变量获取 `ajax` 异步过来的 `data` 数据，然后在 `use_val` 这个函数中使用 `obj` 这个变量

看似没问题，实际上问题很严重

在 `use_val()` 中的 `obj` 真的是 `data` 的值么？答案是否定的，而是 `''`

因为就这段代码而言，`obj = data` 是在 `use_val()` 执行完才在异步回调函数内实现的，在此之前，`obj`一直是 `''`

于是又有人说，那我写个延时函数，等待 `obj = data` 后再执行呗，那样就太不优雅了，那么该如何解决呢？

```js
// 定义一个回调函数
function load_val(callback) {
  $.get('url', function (data) {
    // 将返回结果当作参数通过回调函数返回
    callback(data); 
  });
}

load_val(function (data) {
  // 这里可以得到值
  obj = data; 
  use_val();
});

function use_val() {
  obj += 1;
  console.log(obj);
}
```

也就是在所需要调用的回调函数外加一个函数，这个函数包含一个参数，该参数是个函数，然而这个函数有着依赖于回调函数给出的值的参数，所以经过这两层，就能将原本回调函数里的值给取出来












## JavaScript 异步加载方案

最常见的莫过于 `defer` 与 `async`

#### defer

`HTML4` 为 `script` 标签定义了一个扩展属性 `defer`

`defer` 指明本元素所含的脚本不会修改 `dom`，因此代码能安全地延迟执行，但是该属性并不是一个理想的跨浏览器解决方案，该属性只有 `IE4+` 和 `firefox3.5+` 的浏览器支持，用法如下

```js
<script type='text/javascript' src='test.js' defer></script>
```

带有 `defer` 属性的 `script` 标签可以放置在文档的任何位置，当一个带有 `defer` 属性 `js` 文件下载时，它不会阻塞浏览器的其他进程

因此这类文件可以与页面中的其他资源并行下载，带有 `defer` 属性的 `script` 标签在 `dom` 加载完成（`onload` 事件触发前执行）

#### async 

`HTML5` 规范引入了 `async` 属性，用于异步加载脚本

```js
<script type='text/javascript' src='test.js' async></script>
```

`async` 与 `defer` 的相同点是采用并行下载，在下载的过程中不会产生阻塞，区别在于 `async` 是加载完成后自动执行，而 `defer` 需要等待页面完成后执行

#### 动态创建 script

主要原理 `javascript` 可以动态创建 `HTML` 中几乎所有的内容，所以我们可以利用 `javascript` 动态地创建 `script` 标签并添加到 `HTML` 中

```js
var script = document.createElement('script');

script.type = 'text/javasctipt';
script.src = 'file.js';

document.getElementByTagName('head')[0].appendChild(script)
```

我们可以使用如下方法跟踪并确保脚本下载完成并准备就绪

```js
function loadScript(url, callback) {

  // 创建标签
  var script = document.createElement("script");
  script.type = "text/javasctipt";

  // 如果是 IE
  if (script.readyState) {
    script.onreadystatechange = function () {
      if (script.readyState == 'loaded' || script.readyState == 'complete') {
        script.onreadystatechange = null;
        callback()
      }
    }
  } else {
    script.onload = function () {
      callback();
    }
  }

  // 赋值
  script.src = url;
  document.getElementByTagName("head")[0].appendChild(script)
}
```

调用方法

```js
loadScript('files.js',function(){
  console.log(`file is loaded`);
})
```

#### XMLHttpRequest 脚本注入

还可以通过 `XHR` 对象获取脚本并注入到页面

```js
// 获取 XMLHttpRequest 对象（考虑兼容性）
var getXmlHttp = function () {
  var obj;
  if (window.XMLHttpRequest)
    obj = new XMLHttpRequest();
  else
    obj = new ActiveXObject('Microsoft.XMLHTTP');
  return obj;
};

// 采用 Http 请求 get 方式，open() 方法的第三个参数表示采用异步（true）还是同步（false）来进行处理
var xmlHttp = getXmlHttp();
xmlHttp.open('GET', 'file3.js', true);

xmlHttp.onreadystatechange = function () {
  if (xmlHttp.readyState == 4) {
    if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 304) {
      var script = document.createElement('script');
      script.text = xmlHttp.responseText;
      document.body.appendChild(script);
    }
  }
}

xmlHttp.send(null);
```







## 简易事件模型

简单来说就是一个定顺序触发相应的响应函数

大致实现思路就是创建一个类或是匿名函数，在 `bind` 和 `trigger` 函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表

`bind` 时，如果字典没有则创建一个，`key` 是事件名称，`value` 是数组，里面放着当前注册的响应函数

如果字段中有，那么就直接 `push` 到数组即可，`trigger` 时调出来依次触发事件响应函数即可

不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用 `trigger` 的参数列表都传到响应函数中还要考虑到把 `arguments` 对象转化为纯数组才行等等


```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName];

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例
var emitter = new Emitter();

emitter.on('event', function (arg1, arg2) {
  console.log('get event', arg1, arg2);
})

console.log('emit event');
emitter.emit('event', 'arg1', 'arg2');
```




## 关于 'use strict'

严格模式是 `ECMAScript 5` 中的一项新特征，允许你把一段程序或功能放置在 `'strict'` 工作环境中，这种严格上下文环境防止某些行为被采取并引发更多的异常

严格的模式有助于几个方面

* 它捕获了一些常见的编码错误，抛出异常

* 它阻止，或抛出错误，当相对'不安全'的行为被采用（例如获取全局对象）

* 它禁用那些混淆的或者考虑不周的特征

```js
// 非严格的代码...

(function () {
  'use strict';

  // 严格定义你的库...
})();

// 非严格的代码
```



## 检测是否有元素被隐藏

```js
// 检查 display: [none | block], 忽略 visible: [true | false]
$(element).is(":visible");

// 匹配的是隐藏的所有元素
$('element:hidden')

// 匹配所有可见的元素
$('element:visible')
```



## 鼠标长按事件

只要长按时间到达 `1000` 毫秒，无论是否弹起鼠标，都会触发，反之如果不到 `1000` 毫秒，鼠标弹起的时候会结束

```js
// 申明全局变量
var timeStart, timeEnd, time;

// 获取此刻时间
function getTimeNow() {
  var now = new Date();
  return now.getTime();
}

// 鼠标按下时触发
function holdDown() {
  // 获取鼠标按下时的时间
  timeStart = getTimeNow();

  // setInterval 会每 100 毫秒执行一次，也就是每 100 毫秒获取一次时间
  time = setInterval(function () {
    timeEnd = getTimeNow();

    // 如果此时检测到的时间与第一次获取的时间差有 1000 毫秒
    if (timeEnd - timeStart > 1000) {
      // 便不再继续重复此函数 （clearInterval 取消周期性执行）
      clearInterval(time);
      // 字体变红
      // 一些逻辑
    }
  }, 100);
}

function holdUp() {
  // 如果按下时间不到 1000 毫秒便弹起
  clearInterval(time);
}
```







## 如何判断一个对象是否为空

1. 最常见的思路，`for...in` 遍历属性，为真则为'非空数组'，否则为'空数组'

```js
// 如果不为空，则会执行到这一步，返回 true
for (var i in obj) {
  return true
}

// 如果为空，返回 false
return false 
```

2. 通过 `JSON` 自带的 `stringify()` 方法来判断

`JSON.stringify()` 方法用于将 `JavaScript` 值转换为 `JSON` 字符串

```js
if (JSON.stringify(data) === '{}') {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```

这里需要注意为什么不用 `toString()`，因为它返回的不是我们需要的

```js
var a = {}
a.toString() // "[object Object]"
```


3. `ES6` 新增的方法 `Object.keys()`

`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举属性组成的数组

如果我们的对象为空，他会返回一个空数组，如下

```js
var a = {}
Object.keys(a) // []
```

我们可以依靠 `Object.keys()` 这个方法通过判断它的长度来知道它是否为空

```js
if (Object.keys(object).length === 0) {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```


## 如何快速判断 DOM 元素位于 viewport 以外

```js
ele.getBoundingClientRect().top > window.innerHeight  // 元素在当前屏下面

ele.getBoundingClientRect().bottom < 0                // 元素在当前屏上面
```





## 检测对象改变的几种方式

方法一，可以通过 getter 和 setter 实现

```js
var obj = {
  get foo() {
    console.log({ name: 'foo', object: obj, type: 'get' });
    return obj._foo;
  },
  set bar(val) {
    console.log({ name: 'bar', object: obj, type: 'set', oldValue: obj._bar });
    return obj._bar = val;
  }
};

obj.bar = 2;
// {name: "bar", object: {_bar: 2}, type: "set", oldValue: undefined}

obj.foo;
// {name: "foo", object: <_bar: 2>, type: 'get'}
```

方法二，在支持 Proxies（代理）的浏览器中更为通用的方法

```js
var obj = {
  foo: 1,
  bar: 2
}

var proxied = new Proxy(obj, {
  get: function (target, prop) {
    console.log({ type: 'get', target, prop });
    return Reflect.get(target, prop);
  },
  set: function (target, prop, value) {
    console.log({ type: 'set', target, prop, value });
    return Reflect.set(target, prop, value);
  }
})

proxied.bar = 2;
// {type: "set", target: { foo: 1, bar: 2 }, prop: "bar", value: 2}

proxied.foo;
// {type: "get", target: { foo: 1, bar: 2 }, prop: "foo"}
```

方法三，使用 Object.defineProperties

```js
var obj = Object.defineProperties({}, {
  'foo': {
    get: function () {
      console.log('Get Foo: ' + this.value);
    },
    set: function (val) {
      console.log('Set Foo: ' + val);
      this.value = val;
    }
  },

  'bar': {
    get: function () {
      console.log('Get Bar: ' + this.value);
    },
    set: function (val) {
      console.log('Set Bar: ' + val);
      this.value = val;
    }
  }
});

obj.foo = 2;
// Set Foo: 2

obj.bar;
// Get Bar: undefined
```












## Property 'style' does not exist on type 'Element'

这个问题一般会在 `TS` 当中使用 `document.querySelector` 去获取元素的时候发生

根据规范可知（[MDN Element 规范](https://developer.mozilla.org/en-US/docs/Web/API/Element)），`Element` 接口确实没有 `style` 属性

如果不是用来操作 `SVG` 元素，而是仅仅使用 `TS` 的话，可以像下面这样操作

```js
(document.querySelector('xxx') as HTMLElement).style.color = 'red';
```





## table 表单中的 .rows 属性

如下

```js
var tr = cartTable.children[1].rows;
```

为表单元素特有的属性，存放节点所有的 `tr` 元素，操作的话可以使用如下方式

```js
price += tr[i].cells[4].innerHTML
```

> `cells` 也是 表单元素特有的属性，里面存放的是这个表格没一行下面的所有的单元格，也就是 `td` 元素，也就是说这一行下面所有的 `td`





## offsetLeft 与 style.left 的区别

`offsetLeft` 获取的是相对于父对象的左边距

`left` 获取或设置相对于 具有定位属性（`position` 定义为 `relative`）的父对象的左边距

如果父 `div` 的 `position` 定义为 `relative`，子 `div` 的 `position` 定义为 `absolute`

那么子 `div` 的 `style.left` 的值是相对于父 `div` 的值，这同 `offsetLeft` 是相同的，区别在于

* `style.left` 返回的是字符串，如 `28px`，`offsetLeft` 返回的是数值 `28`，如果需要对取得的值进行计算，还用 `offsetLeft` 比较方便

* `style.left` 是读写的，`offsetLeft` 是只读的，所以要改变 `div` 的位置，只能修改 `style.left`

* `style.left` 的值需要事先定义，否则取到的值为空，而且必须要定义在 `html` 里,如果定义在 `css` 里，`style.left` 的值仍然为空

`offsetLeft` 则仍然能够取到，无需事先定义 `div` 的位置



## Reflect 对象

`Reflect` 对象与 `Proxy` 对象一样，也是 `ES6` 为了操作对象而提供的新 `API`

简单来说两点，一个就是将 `Object` 对象的一些明显属于语言内部的方法（比如 `Object.defineProperty`），放到 `Reflect` 对象上

另一个就是让 `Object` 操作都变成函数行为，因为 `ES5` 很多 `Object` 操作都是命令式的（另外一个原因就是这些方法可能是全局的，或者要通过原型来调用，统一起来）

这里只简单的介绍几个常用的方法，详细的可见 [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/reflect) 和 [Reflect - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)


#### Reflect.apply(target, thisArgument, argumentsList)

与 `ES5` 的 `Function.prototype.apply` 方法是类似的

比如查找数组中最大数

```js
// ES6 
Reflect.apply(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5

// ES5
Math.max.apply(undefined, [1, 2, 3, 4, 5]);  // 5

Function.prototype.apply.call(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5
```

切割字符串

```js
// ES6 
Reflect.apply(String.prototype.slice, 'hello world', [2, 8]);  // "llo wo"

// ES5 
'hello world'.slice(2, 8);  // "llo wo"

String.prototype.slice.apply('hello world', [2, 8]);  // "llo wo"
```



#### Reflect.construct(target, argumentsList[, newTarget])

与使用 ·new target(...args)· 方法类似，相当于提供了一种新的不使用 ·new· 来调用构造函数的方法

* `target` 表示被运行的目标函数

* `argumentsList` 调用构造函数传递的参数数组或者伪数组

* `newTarget` 参数为构造函数，表示使用 `Reflect.construct` 后生成的对象是谁的实例

* 如果没有传递第三个参数，默认和 `target` 一样

如果没有传递第三个参数，那么 `target` 就是唯一的构造函数，但是如果传递了第三个参数，那就表示实例将由两部分组成，实力的属性部分（constructor）由第一个参数部分生成，实例的方法部分由第三个参数生成

```js
class A1 {
  constructor(name) {
    console.log('Class A1 is invoked!');
    this.name = name;
  }
  getName() {
    console.log(this.name);
    return this.name;
  }
}

class B1 {
  constructor(age) {
    console.log('Class B1 is invoked!');
    this.age = age;
  }
  getAge() {
    console.log(this.age);
    return this.age;
  }
}

// 使用 A1 类作为构造函数
let a1 = Reflect.construct(A1, ['happy']);

// 使用 B1 类作为构造函数
let b1 = Reflect.construct(A1, ['happy'], B1);

console.log(a1);
console.log(b1);

// A1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class A1
//     getName: ƒ getName()
//     __proto__: Object

// B1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class B1
//     getAge: ƒ getAge()
//     __proto__: Object
```



#### Reflect.defineProperty(target, propertyKey, attributes)

与 `Object.defineProperty` 相似，不过如果 `Object.defineProperty` 的属性定义失败了，就会抛出一个错误，而 `Reflect.defineProperty` 如果定义属性失败的话就会返回 `false`

```js
let obj = {};

let result = Reflect.defineProperty(obj, 'name', {
  configurable: true,
  enumerable: true,
  value: 'happy'
});

console.log(result)  // true
```



#### Reflect.getPrototypeOf(target)

与 `Object.getPrototypeOf` 方法是一样的，都是返回一个对象的原型，也就是内部的 `[[Prototype]]` 属性的值

如果要获取原型的那个值不是一个对象，那么函数 `Reflect.getPrototypeOf` 会抛出一个异常

对于给定对象的原型，如果没有继承的属性，则返回 `null`



#### Reflect.ownKeys(target)

返回由目标对象自身的属性键组成的数组，包括 `symbol` 的值

```js
let a = Symbol.for('a');
let b = Symbol.for('b');

let obj = {
  [a]: 10,
  [b]: 20,
  key1: 30,
  key2: 40
};

let arr1 = Object.getOwnPropertyNames(obj);
console.log(arr1); // [ 'key1', 'key2' ]

let arr2 = Object.getOwnPropertySymbols(obj);
console.log(arr2); // [ Symbol(a), Symbol(b) ]

let arr3 = Reflect.ownKeys(obj);
console.log(arr3); // [ 'key1', 'key2', Symbol(a), Symbol(b) ]
```














## 如何判断鼠标滚动方向和绑定鼠标滚轮事件

#### 绑定鼠标滚轮事件

`js` 事件有很多需要兼容的地方，鼠标滚轮事件也有额外的差异吗，包括 `IE6` 浏览器在内的都适用 `mouseWheel`，而只有火狐浏览器使用`DOMMouseScroll`

#### 如何判断鼠标滚动方向

其他浏览器通过 `wheeldalta` 属性来判断，但是火狐浏览器没有这个属性，可以通过`detal`这个属性来判断

开发中发现每次向下滚动的时候，`wheeldalta`都是`-120`，但是`detail`却是`3`，火狐浏览器方向判断的数值正负与其他浏览器是相反的

```js
div.on('mousewheel DOMMouseScroll', function(e){
  var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail;
  // do someing
});
```

关于火狐浏览器： [firefox的event.detail](https://segmentfault.com/q/1010000003986369)


## JavaScript 判断滚动条方向

```js
$(document).ready(function () {

  // 设置参照物与比较物
  var p = 0,t = 0;

  $(window).scroll(function (e) {

    // 默认相对滚动条顶部的偏移
    p = $(this).scrollTop();
    
    // 下滚
    if( t <= p ){  
      $('.header').hide();
    }
                
    // 上滚
    else{  
      $('.header').show();
    }

    // 关于这句的解释 见下方
    setTimeout(function(){t = p;}, 0);    
  });

});
```


## setTimeout(function(){}, 0) 

`JavaScript` 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 "阻塞式执行"

假如当前 `JavaScript` 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行

如果代码中设定了一个 `setTimeout` 那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 `0`，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕，所以 `setTimeout` 并不能保证执行的时间，是否及时执行取决于 `JavaScript` 线程是拥挤还是空闲

更多见 [JavaScript 下的 setTimeout(fn, 0) 意味着什么？](http://www.cnblogs.com/silin6/p/4333999.html)

## 为什么 0.2 + 0.1 === 0.3 返回 false

在展开这个问题之前，我们需要先了解计算机内部是如何表示数的

在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数

看下面两个例子

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|13|	10|	13|	1x10^1 + 3x10^0 = 10 + 3|
|13|	2	|1101|	1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1|
|上面是整数，下面则是小数||||
|0.625|	10|	0.625|	6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005|
|0.625|	2|	0.101|	1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8|

简单来说

* 十进制整数转二进制方法 -- 除 `2` 取余

* 十进制小数转二进制方法 -- 乘 `2` 除整

在这里就不得不提 `0.1` 这个比较特殊的小数了，`0.1` 的二进制格式是 `0.0001100011....`

这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数

这里就会存在一个**在某个精度点直接舍弃**的操作，当然，代价就是，`0.1` 在计算机内部根本就不是精确的 `0.1`，而是一个有舍入误差的 `0.1`

当代码被编译或解释后，`0.1` 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 `0.1 + 0.2` 不等于 `0.3` 的原因

这里就会引申出另外一个问题，如下

#### 为什么 0.1 + 0.1 却等于 0.2

结果是，两个有舍入误差的值在求和时，相互抵消了，但这种 "负负得正，相互抵消" 不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消

另一个需要注意的是，二进制能精确地表示位数有限且分母是 `2` 的倍数的小数，比如 `0.5`，`0.5` 在计算机内部就没有舍入误差，所以 `0.5 + 0.5 === 1`

在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在

虽然允许误差存在，但是**永远不要直接比较两个浮点的大小**

一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差

如果非要计算一些浮点数，可以采用第三方库，比如 [bignumber](https://github.com/MikeMcl/bignumber.js) 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望

```js
{
  let x = new BigNumber(0.1);
  let y = new BigNumber(0.2)
  let z = new BigNumber(0.3)

  console.log(z.equals(x.add(y)))   // 0.3 === 0.1 + 0.2, true
  console.log(z.minus(x).equals(y)) // true
  console.log(z.minus(y).equals(x)) // true
}

{
  let x = 0.2
  console.log(x * x === 0.04) // false
  let y = new BigNumber(0.2)
  let r = y.mul(y)            // 0.04
  console.log(r.equals(new BigNumber(0.04))) // true
}
```


#### 小小总结

* 为什么 `0.1 + 0.2` 不等于 `0.3`，因为计算机不能精确表示 `0.1`， `0.2` 这样的浮点数，计算时使用的是带有舍入误差的数

* 并不是所有的浮点数在计算机内部都存在舍入误差，比如 `0.5` 就没有舍入误差

* 具有舍入误差的运算结可能会符合我们的期望，原因可能是 "负负得正"

* 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 `bignumber.js` 这样的浮点数运算库

