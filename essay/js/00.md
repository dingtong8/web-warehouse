## this

`this` 是 `Javascript` 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用

随着函数使用场合的不同，`this` 的值会发生变化。但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象

`JavaScript` 中函数的调用有以下几种方式：

* 为对象方法调用

* 作为函数调用

* 作为构造函数调用

* 使用 `apply` 或 `call` 调用

下面就按照调用方式的不同，分别讨论 `this` 的含义。


#### 作为对象方法调用

在 `JavaScript` 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，`this` 被自然绑定到该对象

```js
var point = { 
  x : 0, 
  y : 0, 
  moveTo : function (x, y) { 
    this.x = this.x + x; 
    this.y = this.y + y; 
  } 
}; 

point.moveTo(1, 1)  // this 绑定到当前对象，即 point 对象
```


#### 纯粹的函数调用 

函数也可以直接被调用，此时 `this` 绑定到全局对象。在浏览器中，`window` 就是该全局对象（`Node.js` 中为 `Global`）。比如下面的例子：函数被调用时，`this` 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的

```js
function makeNoSense (x) { 
  this.x = x; 
} 

makeNoSense(5); 
x;  // x 已经成为一个值为 5 的全局变量
```

对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题

我们仍然以前面提到的 `point` 对象为例，这次我们希望在 `moveTo` 方法内定义两个函数，分别将 `x`，`y` 坐标进行平移。结果可能出乎大家意料，不仅 `point` 对象没有移动，反而多出两个全局变量 `x`，`y`

```js
var point = {
  x: 0,
  y: 0,
  moveTo: function (x, y) {
    // 内部函数
    var moveX = function (x) {
      this.x = x;
    };
    // 内部函数
    var moveY = function (y) {
      this.y = y;
    };

    moveX(x);
    moveY(y);
  }
};

point.moveTo(1, 1);

point.x; // ==>0 
point.y; // ==>0 

x; // ==>1 
y; // ==>1
```

内部函数中的 `this` 成为全局的了，为了规避这一设计缺陷，一般使用变量替代的方法，该变量常被命名为 `that/_this/self`

```js
var point = {
  x: 0,
  y: 0,
  moveTo: function (x, y) {
    var that = this;
    // 内部函数
    var moveX = function (x) {
      that.x = x;
    };
    // 内部函数
    var moveY = function (y) {
      that.y = y;
    }
    moveX(x);
    moveY(y);
  }
};

point.moveTo(1, 1);

point.x; // ==>1 
point.y; // ==>1
```



#### 作为构造函数调用

所谓构造函数，就是通过这个函数生成一个新对象（`object`）。这时，`this` 就指这个新对象。 如果不使用 `new` 调用，则和普通函数一样

```js
function Point (x, y) {
  this.x = x;
  this.y = y;
}
```




#### 使用 apply 或 call 调用

`apply()` 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，`this` 指的就是这第一个参数

```js
function Point (x, y) {
  this.x = x;
  this.y = y;
  this.moveTo = function (x, y) {
    this.x = x;
    this.y = y;
  }
}

var p1 = new Point(0, 0);
var p2 = { x: 0, y: 0 };

p1.moveTo(1, 1);
p1.moveTo.apply(p2, [10, 10]);
```

在上面的例子中，我们使用构造函数生成了一个对象 `p1`，该对象同时具有 `moveTo` 方法

使用对象字面量创建了另一个对象 `p2`，我们看到使用 `apply` 可以将 `p1` 的方法应用到 `p2` 上，这时候 `this` 也被绑定到对象 `p2` 上。另一个方法 `call` 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的

注意：`apply()` 的参数为空时，默认调用全局对象


#### 四种方式的优先级

如下所示，优先级从上往下：

1. 由 `new` 调用绑定到新创建的对象

2. 由 `call` 或者 `apply`（或者 `bind`）调用？绑定到指定的对象

3. 由上下文对象调用？绑定到那个上下文对象

4. 默认：在严格模式下绑定到 `undefined`，否则绑定到全局对象







----

以上是 `this` 常见的几种使用方式，下面来看看一些不太常见的场景


#### 原型链中的 this

相同的概念在定义在原型链中的方法也是一致的，如果该方法存在于一个对象的原型链上，那么 `this` 指向的是调用这个方法的对象，表现得好像是这个方法就存在于这个对象上一样

```js
var o = {
  f: function () {
    return this.a + this.b;
  }
};

var p = Object.create(o);

p.a = 1;
p.b = 4;

console.log(p.f());  // 5
```

对象 `p` 没有属于它自己的 `f` 属性，它的 `f` 属性继承自它的原型，但是这对于最终在 `o` 中找到 `f` 属性的查找过程来说没有关系，查找过程首先从 `p`.`f` 的引用开始，所以函数中的 `this` 指向 `p`，也就是说，因为 `f` 是作为 `p` 的方法调用的，所以它的 `this` 指向了 `p`





#### getter 与 setter 中的 this

作为 `getter` 或 `setter` 函数都会绑定 `this` 到从设置属性或得到属性的那个对象

```js
function modulus() {
  return Math.sqrt(this.re * this.re + this.im * this.im);
}

var o = {
  re: 1,
  im: -1,
  get phase() {
    return Math.atan2(this.im, this.re);
  }
};

Object.defineProperty(o, 'modulus', {
  get: modulus, enumerable: true, configurable: true
});

console.log(o.phase, o.modulus); // -0.78 1.4142
```





#### 构造函数中的 this

当一个函数被作为一个构造函数来使用（使用 `new` 关键字），它的 `this` 与即将被创建的新对象绑定

构造器返回的默认值是一个 `this` 引用的对象时，但是也可以手动设置返回其他的对象，如果返回值不是一个对象，则返回 `this`

```js
function C() {
  this.a = 37;
}

var o = new C();
console.log(o.a); // 37


function C2() {
  this.a = 37;
  // 手动的设置了返回对象，与 this 绑定的默认对象被取消
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38
```




#### DOM 事件处理函数中的 this

当函数被用作事件处理函数时，它的 `this` 指向触发事件的元素

需要注意：`IE` 的 `attachEvent()` 中的 `this` 指向 `window`（`IE11+` 已经支持 `addEventListener()`）

```js
// 被调用时，将关联的元素变成蓝色
function bluify(e) {
  console.log(this === e.currentTarget); // 总是 true

  // 当 currentTarget 和 target 是同一个对象是为 true
  console.log(this === e.target);
  this.style.backgroundColor = '#A5D9F3';
}

// 获取文档中的所有元素的列表
var elements = document.getElementsByTagName('*');

// 将 bluify 作为元素的点击监听函数，当元素被点击时，就会变成蓝色
for (var i = 0; i < elements.length; i++) {
  elements[i].addEventListener('click', bluify, false);
}
```





#### 内联事件处理函数中的 this

当代码被内联处理函数调用时，它的 `this` 指向监听器所在的 `DOM` 元素

```html
<button onclick="alert(this.tagName.toLowerCase());">
  Show this
</button>
```


上面的 `alert` 会显示 `button`，但是注意只有外层代码中的 `this` 是这样设置的，如果使用闭包（如下所示），则里面的 `this` 是指向 `window/global` 的

```html
<button onclick="alert((function(){return this})());">
  Show inner this
</button>
```





## 使用 new 的时候发生了什么

----

使用 ```new``` 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作

1. 创建（或者说构造）一个全新的对象，可以简单的理解为一个空对象 `{}`

2. 这个新对象会被执行 [[原型]] 连接

3. 这个新对象会绑定到函数调用的 ```this```（简单来说就是将自己的上下文设置为这个 `{}`，即 this 表示为这个对象）

4. 如果函数没有返回其他对象，那么 ```new``` 表达式中的函数调用会自动返回这个新对象

```js
function foo(a) {
    this.a = a;
}
 
var bar = new foo(2);
console.log(bar.a); // 2
```

使用 ```new``` 来调用 ```foo(..)``` 时，我们会构造一个新对象并把它绑定到 ```foo(..)``` 调用中的 ```this``` 上


#### 关于函数的返回值

如果一个构造函数不写 `return` 语句，则系统会自动帮你返回一个对象，但是如果写了 `return` 语句，则

* 如果 `return` 的是一个基本类型的值（比如 string，number），则会忽略这个 `return`，该返回什么还是返回什么，但是会阻止构造函数接下来的执行

* 如果 `return` 了一个引用类型，则原有的 `return` 会被覆盖





#### 解决方案有两种

1. 去掉正则表达式后面的 `g`

2. 每次完成匹配之后重置模式的 `lastIndex` 属性


关于 `lastIndex` 属性，见 [RegExp.lastIndex](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex)

使用重置 `lastIndex` 的代码：

```js
var i = 0, m = 20, a = [], r = /^\d+$/g;

for (i = 0; i < m; i++) {
  a.push('' + i);
}

m = a.length;

for (i = 0; i < m; i++) {
  if (r.test(a[i])) {
    document.write(a[i] + 'true<br />');
  } else {
    document.write(a[i] + 'false<br />');
  }
  r.lastIndex = 0;
}
```





## Canvas 和 SVG 的区别

* ```SVG```
  
  * ```SVG``` 是一种使用 ```XML``` 描述 ```2D``` 图形的语言

  * ```SVG``` 基于 ```XML```，这意味着 ```SVG DOM``` 中的每个元素都是可用的，您可以为某个元素附加 ```JavaScript``` 事件处理器

  * 在 ```SVG``` 中，每个被绘制的图形均被视为对象，如果 ```SVG``` 对象的属性发生变化，那么浏览器能够自动重现图形

  * 特点：

    * 不依赖分辨率

    * 支持事件处理器

    * 最适合带有大型渲染区域的应用程序（比如谷歌地图）

    * 复杂度高会减慢渲染速度（任何过度使用 ```DOM``` 的应用都不快）

    * 不适合游戏应用

* ```Canvas```
  
  * ```Canvas``` 通过 ```JavaScript``` 来绘制 ```2D``` 图形

  * ```Canvas``` 是逐像素进行渲染的

  * 在 ```canvas``` 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注，如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象

  * 特点：

    * 依赖分辨率

    * 不支持事件处理器

    * 弱的文本渲染能力

    * 能够以 ```.png``` 或 ```.jpg``` 格式保存结果图像

    * 最适合图像密集型的游戏，其中的许多对象会被频繁重绘



## mouseover 与 mouseenter 的区别

不论鼠标指针穿过被选元素或其子元素，都会触发 ```mouseover``` 事件 -- 对应 ```mouseout```

只有在鼠标指针穿过被选元素时，才会触发 ```mouseenter``` 事件 -- 对应 ```mouseleave```

```mouseover``` 和 ```mouseout``` 在低版本的浏览器（```IE``` 出现较多）会出现闪烁的现象

此外还有一个重要的区别

* `mouseover` 事件会发现冒泡行为

* `mouseenter` 事件则不会冒泡

当一个内部元素鼠标进入，会触发这个元素的 `onmouseenter` 事件，但是事件不会继续向外层传播

它的外层盒子是不会触发 `onmouseenter` 事件的，因为事件不冒泡


## 浏览器中的各种长度

#### JavaScript

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变

document.body.clientHeight     // 返回对象内容的可视区的高度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变

document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变

document.body.offsetHeight     // 对象整体的实际高度（包括边框和填充），会随对象显示大小的变化而改变

document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大

document.body.scrollHeight     // 对象的实际内容的高度（不包括边线宽度），会随对象中内容超过可视区后而变大

----

document.body.scrollTop        // 页面滚动条向下拉动的距离

document.body.scrollLeft       // 页面滚动条向左拉动的距离

obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变

obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同

----

// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度

window.screen.height           // 屏幕分辨率的高度

window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）

window.screen.availHeight      // 显示器工作区高度（除去任务栏的距离）
```



#### jQuery

```js
width();                       // 设置或返回被选元素的宽度
 
height();                      // 设置或返回被选元素的高度

$(window).height()             // 浏览器当前窗口可视区域高度

$(document).height()           // 浏览器当前窗口文档对象高度也就是页面整体高度

$(document.body).width()       // 浏览器当前窗口文档 body 的宽度
 
$(window).scrollTop()          // 垂直滚动的距离 即当前滚动的地方的窗口顶端到整个页面顶端的距离
                               // 与 $(document).scrollTop() 一致，但是 $(window).scrollTop() 被所有浏览器支持
 
$(window).scrollLeft()         // 这是获取水平滚动条的距离

----

// 返回偏移坐标
$(selector).offset();

top: $(selector).offset().top;

left: $(selector).offset().left;

----

// 两个用的较少的方法 
$(document.body).outerHeight(true)   // 浏览器当前窗口文档 body 的总高度 包括 border padding margin（对可见和隐藏元素均有效）

$(document.body).outerWidth(true)    // 浏览器当前窗口文档 body 的总宽度 包括 border padding margin（对可见和隐藏元素均有效）
```




#### 一些比较常用的方法

#### 可视区高度

获取元素到浏览器顶端的距离，根据页面滚动，这个值是一直在变化的

```js
obj.offsetTop - document.body.scrollTop
```


#### 判断页面是否在顶部

```js
document.body.scrollTop == 0
```

#### 判断页面是否在底部

```js
$(document).height() == $(window).height() + $(window).scrollTop()

即

$(window).scrollTop() >= $(document).height() - $(window).height()
```


#### innerHeight(value)

![img](innerHeight.jpg)

```js
innerHeight  // 高度＋补白

outerHeight  // 高度＋补白＋边框，参数为 true 时为 高度＋补白＋边框＋边距
```

`value` 参数可以是一个字符串（数字加单位）或者是一个数字，如果这个 `value` 参数只提供一个数字，`jQuery` 会自动加上像素单位（`px`）

如果只提供一个字符串，任何有效的 `CSS` 尺寸都可以为高度赋值（就像 `100px`，`50%`，或者 `auto`）

注意在现代浏览器中，`CSS` 高度属性不包含 `padding`，`border` 或者 `margin`， 除非 `box-sizing` 属性被应用



#### 兼容问题

`document.body.scrollTop` 有兼容问题，可以使用

```js
var top = document.body.scrollTop || document.documentElement.scrollTop;
```



#### scrollWidth，clientWidth 和 offsetWidth 区别

分为两种情况

#### 第一种情况

元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下

* `scrollWidth = clientWidth`，两者皆为内容可视区的宽度

* `offsetWidth` 为元素的实际宽度

![img](http://images.cnitblog.com/blog/166781/201412/291654504031651.png)

#### 第二种情况

元素的内容超过可视区，滚动条出现和可用的情况下

* `scrollWidth > clientWidth`

* `scrollWidth` 为实际内容的宽度

* `clientWidth` 是内容可视区的宽度

* `offsetWidth` 是元素的实际宽度

![img](http://images.cnitblog.com/blog/166781/201412/291655026226285.png)



#### Event 对象的五种坐标


```js
clientX 和 clientY    // 相对于浏览器（可视区，左上角0，0）的坐标

screenX 和 screenY    // 相对于设备屏幕左上角（0，0）的坐标

offsetX 和 offsetY    // 相对于事件源左上角（0，0）的坐标
 
pageX 和 pageY        // 相对于整个网页左上角（0，0）的坐标，但它不会随着滚动条而变动

X 和 Y                // 本来是 IE 属性，相对于用 CSS 动态定位的最内层包容元素
```




## parseInt

使用的时候建议始终添加**第二个参数**来指定进制，比如

```js
parseInt(123, 10)  // 返回 123
```

#### 如果是整数，返回其本身

```js
parseInt(123, 10)  // 返回 123
```

#### 如果是浮点数，返回整数部分

```js
parseInt(123.123, 10)   // 返回 123
```


#### 如果是字符串

* 如果字符串第一个非空字符前面含有空格，则忽略空格，直接从第一个非空字符开始解析

```js
parseInt(" 1234", 10)   // 返回 1234
```

* 如果第一个非空字符不是数字或者符号，则返回 ```NaN```

```js
parseInt("df2bc", 10)  // 返回 NaN
```

* 如果第一个非空字符是数字，则继续解析直至解析完毕或者**遇到第一个非数字符号**为止

```js
parseInt("123abc", 10)  // 返回 123
```



## sessionStorage，localStorage 和 cookie 的区别

`sessionStorage`、`localStorage`、`cookie` 都是在浏览器端存储的数据

其中 `sessionStorage` 的概念很特别，引入了一个 "浏览器窗口" 的概念，`sessionStorage` 是在同源的同窗口（或 `tab`）中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在

关闭窗口后，`sessionStorage` 即被销毁，同时 "独立" 打开的不同窗口，即使是同一页面，`sessionStorage` 对象也是不同的

----

**两者的共同点**：都是保存在浏览器端，且同源的

**区别如下**：

* `cookie` 数据始终在同源的 `http` 请求中携带（即使不需要），即 `cookie` 在浏览器和服务器间来回传递，而 `sessionStorage` 和 `localStorage` 不会自动把数据发给服务器，仅在本地保存

* `cookie` 数据还有路径（`path`）的概念，可以限制 `cookie` 只属于某个路径下，存储大小限制也不同，`cookie` 数据不能超过 4k，同时因为每次 `http` 请求都会携带 `cookie`，所以 `cookie` 只适合保存很小的数据，如会话标识，`sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比 `cookie` 大得多，可以达到 5M 或更大，数据有效期不同

* `sessionStorage`：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持

* `localStorage`：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据

* `cookie` 只在设置的 `cookie` 过期时间之前一直有效，即使窗口或浏览器关闭，作用域不同，`sessionStorage` 不在不同的浏览器窗口中共享，即使是同一个页面

* `localStorage` 在所有同源窗口中都是共享的

* `cookie` 也是在所有同源窗口中都是共享的，`Web Storage` 支持事件通知机制，可以将数据更新的通知发送给监听者，`Web Storage` 的 `api` 接口使用更方便



## ifram 的优缺点

现在基本上都是使用 ```Ajax``` 来代替 ```iframe```，但是还是总结一下，优缺点如下：

#### 优点

1. ```iframe``` 能够原封不动的把嵌入的网页展现出来

2. 如果有多个网页引用 ```iframe```，那么你只需要修改 ```iframe``` 的内容，就可以实现调用的每一个页面内容的更改，方便快捷

3. 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 ```iframe``` 来嵌套，可以增加代码的可重用

4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 ```iframe``` 来解决


#### 缺点

1. 会产生很多页面，不容易管理

2. ```iframe``` 框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差

3. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理 ```iframe``` 中的内容，所以使用 ```iframe``` 会不利于搜索引擎优化

4. 很多的移动设备（```PDA``` 手机）无法完全显示框架，设备兼容性差

5. ```iframe``` 框架页面会增加服务器的 ```http``` 请求，对于大型网站是不可取的



## Date 对象常用的一些方法

```js
// 获取当前时间
// 返回的是一个对象类型，类似（Mon Jul 03 20xx 20:04:31 GMT+0800 (中国标准时间)）
var d = new Date();

// 获取当前时间的时间戳，类似（1210745780625）
// 等同于 Date.now()  ==> 没有括号
var d = new Date().getTime();
```

#### 转换

对于时间戳格式的日期，可以将其传入 ```new Date()``` 方法，即可得到日期的对象格式

```js
var d = new Date().getTime();  // 1499084023051

// ==> 直接传入

new Date(d);  // Mon Jul 03 2017 20:14:59 GMT+0800 (中国标准时间)
```

得到日期对象以后就可以使用下面方式来得到当前的日期时间

```js
// 年 - 月 - 日（注意月份从 0 开始计算）
new Date(d).getFullYear()

new Date(d).getMonth()

new Date(d).getDay()

// 时 - 分 - 秒
new Date(d).getHours()

new Date(d).getMinutes()

new Date(d).getSeconds()
```


## ES6 中的 class

一些相关知识点：

* 类的内部所有定义的方法，都是不可枚举的

* 类和模块的内部，默认就是严格模式，所以不需要使用 ```use strict``` 指定运行模式

* 一个类必须有 ```constructor``` 方法，如果没有显式定义，一个空的 ```constructor``` 方法会被默认添加

* 不存在变量提升（```hoist```）

* 类的方法内部如果含有 ```this```，它默认指向类的实例

* ```class``` 中的方法有三种类型：构造函数、静态方法、原型方法

* ```class``` 内部只有静态方法，没有静态属性

#### 私有方法

```ES6``` 不提供，只能通过变通方法模拟实现

一种做法是在命名上加以区别

```js
class Widget {
  // 公有方法
  foo(baz) {
      this._bar(baz);
  }

  // 私有方法
  _bar(baz) {
      return this.snaf = baz;
  }

  // ...
}
```

另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的

```js
class Widget {
  // foo 是公有方法，内部调用了 bar.call(this, baz)
  // 使得 bar 实际上成为了当前模块的私有方法
  foo(baz) {
      bar.call(this, baz);
  }

  // ...
}

function bar(baz) {
  return this.snaf = baz;
}
```

有一种方法是利用 ```Symbol``` 值的唯一性，将私有方法的名字命名为一个 ```Symbol``` 值

```js
const bar = Symbol("bar");
const snaf = Symbol("snaf");

export default class myClass {
  // 公有方法
  foo(baz) {
      this[bar](baz);
  }

  // 私有方法
  [bar](baz) {
      return this[snaf] = baz;
  }

  // ...
};
```



#### 私有属性

与私有方法一样，```ES6``` 不支持私有属性，但是可以通过闭包来实现私有属性

```js
var People = (function () {
  var p = new WeakMap();
  class People {
    constructor(name) {
      var privateProperties = {
        name: name
      };
      p.set(this, privateProperties);
    }
    sayName() {
      console.log(this.name);
    }

    get name() {
      return p.get(this).name;
    }
  }
  return People;
})();

var p = new People("zhangsan");
console.log(p.name);
p.sayName();

var p2 = new People("lisi");
console.log(p2.name);
p2.sayName();
```


#### 静态方法

静态方法一般用来提供一些工具方法，可以通过 ```static``` 关键字定义静态方法

```js
class People {
  constructor(name) {
    this.name = name;
  }
  sayName() {
    console.log(this.name);
  }
  static formatName(name) {
    return name.toUpperCase();
  }
}

console.log(People.formatName("zhangsan"));
```


#### 静态属性

```Class``` 内部只有静态方法，没有静态属性

静态属性指的是 ```Class``` 本身的属性，即 ```Class.propName```，而不是定义在实例对象（```this```）上的属性

```js
class Foo {}

Foo.prop = 1;
Foo.prop // 1
```


----

#### getters & setters

现在可以通过 ```get``` 和 ```set``` 关键字来定义 ```getters``` 和 ```setters``` 了

```js
class People {
  constructor(name) {
    this.name = name;
  }

  get name() {
    return this._name.toUpperCase();
  }

  set name(name) {
    this._name = name;
  }

  sayName() {
    console.log(this.name);
  }
}

var p = new People("zhangsan");

console.log(p.name);    // ZHANGSAN
console.log(p._name);    // zhangsan
p.sayName();    // ZHANGSAN
```

因为定义了 ```name``` 的读写器，而没有定义 ```_name``` 的读写器，所以访问这两个属性的结果是不同的


#### 继承

通过关键字 ```extends``` 来继承一个类，并且可以通过 ```super``` 关键字来引用父类

```js
class People {
  constructor(name) {
    this.name = name;
  }

  sayName() {
    console.log(this.name);
  }
}

class Student extends People {
  constructor(name, grade) {
    super(name);
    this.grade = grade;
  }

  sayGrade() {
    console.log(this.grade);
  }
}
```

几个注意事项：

* 子类必须在 ```constructor``` 方法中调用 ```super``` 方法，否则新建实例时会报错，这是因为子类没有自己的 ```this``` 对象，而是继承父类的 ```this``` 对象，然后对其进行加工，如果不调用 ```super``` 方法，子类就得不到 ```this``` 对象

* 如果子类没有定义 ```constructor``` 方法，这个方法会被默认添加，也就是说不管有没有显式定义，任何一个子类都有 ```constructor``` 方法

* 在子类的构造函数中，只有调用 ```super``` 之后，才可以使用 ```this``` 关键字，否则会报错（因为只有 ```super``` 方法才能返回父类实例）

* ```Object.getPrototypeOf``` 方法可以用来从子类上获取父类（判断一个类是否继承了另一个类）

#### super 关键字

* 使用 ```super``` 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错

* ```super``` 作为函数调用时

  * ```super``` 作为函数调用时，代表父类的构造函数（子类的构造函数必须执行一次 ```super``` 函数）

  * 虽然代表了父类的构造函数，但是 ```super``` 内部的 ```this``` 指的是子类的实例（相当于 ```Father.prototype.constructor.call(this)```）

  * 作为函数时，```super()``` 只能用在**子类**的构造函数之中，用在其他地方就会报错

* ```super``` 作为对象调用时

  * 在普通方法中，指向父类的原型对象，在静态方法中，指向父类（与父类静态方法相呼应）

  * 当 ```super``` 指向父类的原型对象时，定义在父类实例上的方法或属性，是无法通过 ```super``` 调用的（定义在 ```prototype``` 上的则可以取到）

  * 通过 ```super``` 调用父类的方法时，```super``` 会绑定子类的 ```this```

  * 通过 ```super``` 对某个属性赋值，这时 ```super``` 就是 ```this```，赋值的属性会变成子类实例的属性，如下代码

```js
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;

    // 等同于对 this.x 赋值为 3
    super.x = 3;

    // 而当读取 super.x 的时候，读的是 A.prototype.x，所以返回 undefined
    console.log(super.x);  // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```




## map 和 reduce

#### map

由于 ```map()``` 方法定义在 ```javascript``` 的 ```Array``` 中，比如我们有一个函数 ```f(x)=x2```，要把这个函数作用在一个数组 ```[1, 2, 3, 4, 5, 6, 7, 8, 9]``` 上，我们调用 ```Array``` 的 ```map()``` 方法，传入我们自己的函数，就得到了一个新的 ```Array``` 作为结果：

```js
function pow(x) {
  return x * x;
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

再比如，把 ```Array``` 的所有数字转为字符串：

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
arr.map(String); // ['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

#### reduce

```Array``` 的 ```reduce()``` 把一个函数作用在这个 ```Array``` 的 ```[x1, x2, x3...]``` 上，这个函数必须接收两个参数，```reduce()``` 把结果继续和序列的下一个元素做累积计算，其效果就是：

```js
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

比方说对一个 ```Array``` 求和，就可以用 ```reduce``` 实现：

```js
var arr = [1, 3, 5, 7, 9];

arr.reduce(function (x, y) {
  return x + y;
}); // 25
```

要把 ```[1, 3, 5, 7, 9]``` 变换成整数 ```13579```，```reduce()``` 也能派上用场：

```js
var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
  return x * 10 + y;
}); // 13579
```

利用 ```reduce()``` 求积

```js
function product(arr) {
  return arr.reduce(function(x, y){ return x * y})
}
```


#### 一个综合实例

实现一个算法，寻找字符串中出现次数最少的、并且首次出现位置最前的字符，如 `cbaacfdeaebb`

#### 方法一

利用 `hash table`，缺点是 `Object.keys()` 不能保证顺序，所以存在风险

```js
var o = [].reduce.call('cbaacfdeaebb', function (p, n) {
  return p[n] = (p[n] || 0) + 1, p;
}, {}),
  s = Object.keys(o).reduce(function (p, n) {
      return o[p] <= o[n] ? p : n;
  });
    
console.log(s, o[s]);
```

#### 方法二

引入了 `index` 来解决顺序问题

```js
const all = "cbaacfdeaebb".split("")
  .reduce((all, ch, i) => {
    const m = all[ch] || (all[ch] = { ch: ch, index: i, count: 0 });
    m.count++;
    return all;
  }, {});

const theOne = Object.keys(all)
  .map(ch => all[ch])
  .reduce((min, t) => min.count === t.count
    ? (min.index > t.index ? t : min)
    : (min.count > t.count ? t : min));

console.log(`${theOne.ch}: ${theOne.count}`);
```

#### 方法三

利用数组代替 `hash table`，解决了顺序问题，但是 `Array.sort()` 并不一定是稳定的，风险可能更大

```js
function findFirstChar(string) {
  const desc = [];

  [...string].forEach((char, index) => {
    const item = desc.find(item => item.char === char)
    item ? item.count++ : desc.push({ char, index, count: 1 })
  })

  return desc.sort((a, b) => a.count - b.count)[0]
}
```

#### 方法四

使用 `Object.values`，但是目前还是草案

```js
const less = (x, y) => (x.count <= y.count && x.first < y.first) ? x : y;

function firstSingle(string) {
  let map = {}
  string.split('')
    .forEach((char, index) => {
      map[char] ? map[char].count++ : map[char] = { count: 1, first: index, char }
    });
  return Object.values(map).reduce(less).char
}
```


#### 方法五

```js
var str = "cbaacfdeaebb";

var result = [...new Set(str)]
  .map(el => ({ el, len: str.split(el).length }))
  .reduce((a, e) => (a.len > e.len ? e : a))
  .el;
```



## call 和 apply 哪个速度更快一些

通常来说，`call` 是要比 `apply` 快一些的，至于为什么，这就要看它们在被调用之后发生了什么

#### Function.prototype.apply (thisArg, argArray)

1. 如果 `IsCallable（Function）` 为 `false`，即 `Function` 不可以被调用，则抛出一个 `TypeError` 异常

2. 如果 `argArray` 为 `null` 或未定义，则返回调用 `Function` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 和一个空数组作为参数

3. 如果 `Type（argArray）` 不是 `Object`，则抛出 `TypeError` 异常

4. 获取 `argArray` 的长度，调用 `argArray` 的 `[[Get]]` 内部方法，找到属性 `length`， 赋值给 `len`

5. 定义 `n` 为 `ToUint32（len）`

6. 初始化 `argList` 为一个空列表

7. 初始化 `index` 为 `0`

8. 循环迭代取出 `argArray`，重复循环 `while（index < n）`

  * 将下标转换成 `String` 类型，初始化 `indexName` 为 `ToString(index)`

  * 定义 `nextArg` 为 使用 `indexName` 作为参数调用 `argArray` 的 `[[Get]]` 内部方法的结果

  * 将 `nextArg` 添加到 `argList` 中，作为最后一个元素

  * 设置 `index ＝ index＋1`

9. 返回调用 `Function` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 作为该值，`argList` 作为参数列表


#### Function.prototype.call (thisArg [ , arg1 [ , arg2, .. ] ] )

* 如果 `IsCallable（Function）` 为 `false`，即 `Function` 不可以被调用，则抛出一个 `TypeError` 异常

* 定义 `argList` 为一个空列表

* 如果使用超过一个参数调用此方法，则以从 `arg1` 开始的从左到右的顺序将每个参数附加为 `argList` 的最后一个元素

* 返回调用 `func` 的 `[[Call]]` 内部方法的结果，提供 `thisArg` 作为该值，`argList` 作为参数列表


#### 总结

由于 `apply` 中定义的参数格式（数组），使得被调用之后需要做更多的事，需要将给定的参数格式改变（步骤 `8` 中所示）， 同时也有一些对参数的检查（步骤 `2`），而在 `call` 中却是不必要的

另外在 `apply` 中不管有多少个参数，都会执行循环，也就是步骤 `6 - 8`，而在 `call` 中也就是对应步骤 `3` ，是有需要才会被执行



## JavaScript 中的事件模型

简单来说，即一个类或是一个模块，有两个函数，一个 `bind` 一个 `trigger`，分别实现绑定事件和触发事件

核心需求就是可以对某一个事件名称绑定多个事件响应函数，然后触发这个事件名称时，依次按绑定顺序触发相应的响应函数

```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName],
    self = this;

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例对象
var emitter = new Emitter();

emitter.on("event2", function (arg1, arg2) {
  console.log("get event2", arg1, arg2);
})

emitter.on("event1", function (arg1, arg2) {
  console.log("get event1", arg1, arg2);
})

console.log("emit event");

emitter.emit("event2", "arg1", "arg2");
emitter.emit("event1", "arg1", "arg2");
```




## JavaScript 中常用的设计模式

#### 单例模式

简单来说，任意对象都是单例，无须特别处理

```js
var obj = { name: "zhangsan", age: 20 };
```

一个通用的惰性单例

```js
var getSingle = function (fn) {
  var result;
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}
```


#### 工厂模式

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型

```js
var Car = (function () {
  var Car = function (name, age) {
    this.name = name;
    this.age = age;
  };
  return function (name, age) {
    return new Car(name, age);
  };
})();


var zhangsan = new Car("zhangsan", 20);
var lisi = new Car("lisi", 22);
```

即

```js
var productManager = {};

productManager.createProductA = function () {
  console.log('ProductA');
}

productManager.createProductB = function () {
  console.log('ProductB');
}

productManager.factory = function (typeType) {
  return new productManager[typeType];
}

productManager.factory('createProductA');
```


#### 代理模式

简单来说，就是新建个类调用老类的接口，包装一下

```js
function Person() { }

Person.prototype.sayName = function () {
  console.log('zhangsan');
}

Person.prototype.sayAge = function () {
  console.log(20);
}

function PersonProxy() {

  this.person = new Person();
  var that = this;

  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName);
    // 代理
    that.person[functionName]();
    console.log('after proxy:', functionName);
  }

}

var p = new PersonProxy();

p.callMethod('sayName');  // 代理调用 Person 的方法 sayName()
p.callMethod('sayAge');  // 代理调用 Person 的方法 sayAge()
```


#### 观察者模式

简单来说就是事件模式，比如按钮的 `onclick` 的应用

```js
function Publisher() {
  this.listeners = [];
}

// 发布者
Publisher.prototype = {

  'addListener': function (listener) {
    this.listeners.push(listener);
  },

  'removeListener': function (listener) {
    delete this.listeners[listener];
  },

  'notify': function (obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  }

};

function Subscriber() { }

// 订阅者
Subscriber.prototype = {
  'process': function (obj) {
    console.log(obj);
  }
};

var publisher = new Publisher();

publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());

// 发布一个对象到所有订阅者
publisher.notify({ name: 'zhangsan', ageo: 30 });

// 发布一个字符串到所有订阅者
publisher.notify('2 subscribers will both perform process');
```



## JavaScript 中节点相关属性（nodeType）

一些常见的 `nodeType` 值

```js
1 - 普通元素节点，比如 div，p 等

3 - 文本节点

8 - 注释节点

9 - document 节点

10 - 文档 DTD
```

#### childNodes

用来获取子节点，注意，返回的是一个类数组对象

```js
var childs = oDiv.childNodes;
```

这里存在一个坑，比如如下

```html
<div>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
</div>
```

当 `div` 中没有文本节点的时候，此时应该为 `4` 个节点，但是 `IE9`，`Chrome`，`FireFox` 会认为存在 `9` 个节点，而 `IE8` 则认为只有 `4` 个节点

**这时因为高级浏览器会把空文本节点也当作为一个节点，标签前后的空文本也会被算作一个节点**

而且对于注释的前后算不算空文本节点，每个浏览器的解释也有不相同，所以我们在使用节点的时候，一定要过滤，比如判断节点的 `nodeType` 是不是 `1`（普通元素节点）

```js
// 得到真正的标签子节点
function getRealChild(elem) {
  var result = [];
  for (var i = 0; i < elem.childNodes.length; i++) {
    if (elem.childNodes[i].nodeType == 1) {
      result.push(elem.childNodes[i]);
    }
  }
  return result;
}
```

另外，如果要改变文本节点的内容（`nodeType` 为 `3`），需要改变其 `nodeValue` 属性

```js
oDiv.childNodes[0].nodeValue = '张三'
```


#### parentNode

`parentNode` 属性表示父节点，任何节点的 `parentNode` 的 `nodeType` 一定为 `1`，也就是说父节点一定是标签节点


#### previousSibling 和 nextSibling

表示 **上/下** 一个兄弟节点，需要注意的是，其可能是 **文本/注释** 节点，而原生 `JS` 当中并没有提供 `prevAll()`，`nextAll()`，`siblings()` 等方法

如果不存在 **上/下** 兄弟节点，返回 `null`，所以可以利用这个特性来写一个方法

```js
// prev
function getRealPrev(elem) {
  // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点
  var o = elem;

  // 循环遍历，将循环的结果再次赋予 o，依次向上查询
  while (o = o.previousSibling) {
    if (o.nodeType == 1) {
      return o;
    }
    return null;
  }
}

// next
function getRealNext(elem) {
  // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点
  var o = elem;

  // 循环遍历，将循环的结果再次赋予 o，依次向下查询
  while (o = o.nextSibling) {
    if (o.nodeType == 1) {
      return o;
    }
    return null;
  }
}

// prevAll
function getRealprevAll(elem) {
  // 原理就是遍历 elem 节点的前面，直到返回第一个 nodeType 为 1 的节点
  var o = elem;
  var result = [];

  // 循环遍历，将循环的结果再次赋予 o，依次向上查询
  // 如果不存在上一个节点，则会返回 null，便自动停止循环
  while (o = o.previousSibling) {
    if (o.nodeType == 1) {
      result.unshift(o)
    }
    return result;
  }
}

// nextAll
function getRealnextAll(elem) {
  // 原理就是遍历 elem 节点的后面，直到返回第一个 nodeType 为 1 的节点
  var o = elem;
  var result = [];

  // 循环遍历，将循环的结果再次赋予 o，依次向下查询
  // 如果不存在下一个节点，则会返回 null，便自动停止循环
  while (o = o.nextSibling) {
    if (o.nodeType == 1) {
      result.push(o)
    }
    return result;
  }
}
```


#### 创建节点

使用 `document.createElement('标签名')` 来创建一个节点，需要注意的是，创建出来的节点是不存在与 `DOM` 树上的，即孤儿节点，需要手动添加至 `DOM` 树中

```js
var oBox = document.getElementById('div');
var oDiv = document.createElement('div');

oBox.appendChild(oDiv);
```

一个需要注意的地方，`JavaScript` 中存储 `DOM` 节点的变量是动态的，比如如下例子

```js
var oBox = document.getElementById('box')
var oDiv = oBox.getElementsByTagName('div')

// 会造成死循环
// 因为 oDiv.length 会动态增加
for (var i = 0; i < oDiv.length; i++) {
  var oP = document.createElement('p');
  oP.innerHTML = '123';
  oBox.appendChild(oP);
}
```

解决方法很简单，用一个变量将 `length` 存储起来即可

```js
for (var i = 0; l = oDiv.length, i < l; i++) {
  // ...
}
```


#### appendChild()

常用的方法是使用 `appendChild()` 来追加至元素的末尾，需要注意的地方就是

**如果节点已经存在（比如 `DOM` 树中已经存在），而不是新创建的，这个时候则会移动该节点（不会克隆）**


#### insetBefore()

接收两个参数，一个是新创建的元素，另一个为参照点

```js
oBox.insetBefore(新创建的元素，参照元素)
```

这样插入的元素会以参照的元素依次往上添加（即添加的为 3，2，1，参照），如果想让顺序变为正序，使用 `oBox.childNodes[0]` 即可（需要注意，如果使用 `childNodes[0]` 来做参照删除元素的话，会存在空白节点）


#### 删除节点

节点不能自己删除，如果想要删除节点，必须使用父元素参照

```js
父元素.removeChild(删除的元素)
```

如果不知道父元素是谁，则可以使用

```js
需要删除的元素.parentNode.removeChild(需要删除的元素)
```


#### replaceChild()

替换节点，用的不是很多

```js
父元素.replaceChild(新节点, 旧节点)
```

比如 `oBox.replaceChild(div1, div2)` 结果是将 `div1` 节点处的内容替换至 `div2` 处（`div1` 处的节点内容就不存在了）


#### 克隆节点

比较常用的方式是使用 `innerHTML` 的方式来进行克隆（亦或是修改），但是执行效率没有 `DOM` 原生方法速度快

原生的方法是 `cloneNode([true])`，可以追加一个布尔值参数 `true`，表示深度克隆，克隆其所有的子节点




## 事件流，冒泡与捕获

所谓事件流，即为了描述事件的传播而规定的一个事件传播方向，分为两个阶段，事件捕获和事件冒泡

正常情况下，事件先从最外层的元素向内捕获，然后从最内层的元素往外层传播

事件的触发一定是按照事件流的顺序而来

#### DOM 0 级

```js
btn.onclick = function () {
  alert(1)
}

btn.onclick = function () {
  alert(2)
}
```

只能监听冒泡阶段，如果给同一个对象，同一个事件名绑定多个监听，后面的会覆盖掉之前的

`this` 指向的是触发事件的 `DOM` 元素

`IE 6，7，8` 中事件只能冒泡到 `document`，不能继续冒泡到 `window` 对象上

> 所以一般不能给 `window` 添加 `click` 事件


#### DOM 2 级

```js
btn.addEventListener('click', function () {
  // ...
}, false)
```

最后一个参数，`true` 表示捕获阶段，而 `false` 则表示为冒泡阶段

几个注意事项：

* 所有现代浏览器都支持事件冒泡，并且会将事件一直冒泡到 `window` 对象

* 如果不是最内层的元素同时绑定有捕获和冒泡事件，改变事件绑定的先后顺序，不会影响执行结果，依然是先捕获后冒泡

* 如果是最内层的元素同时绑定有捕获和冒泡事件，则哪个事件写在前面就先执行哪一个，不再区分捕获或冒泡

* 可以对同一个元素绑定多个事件监听函数，彼此之间不会覆盖，按先后顺序执行

* `this` 指向的是触发事件的元素（也就是事件传播到的这个元素）


一个比较完整的案例，页面布局如下

```html
<div id='box1'>
  <div id='box2'>
    <div id='box3'>
        
    </div>
  </div>
</div>
```

测试相关代码如下

```js
box2.onclick = function () {
  alert('A');
};

box2.onclick = function () {
  alert('B');
};

box2.addEventListener('click', function () {
  alert('C');
}, false);

box2.addEventListener('click', function () {
  alert('D');
}, false);

box2.addEventListener('click', function () {
  alert('E');
}, true);

box2.addEventListener('click', function () {
  alert('F');
}, true);

box3.addEventListener('click', function () {
  alert('G');
}, false);

box3.addEventListener('click', function () {
  alert('H');
}, true);
```

执行后的结果依次为：`E => F => G => H => B => C => D`

最后总结如下

* `DOM 0` 级添加到冒泡阶段

* `DOM 0` 级同名事件会发生覆盖

* `true` 表示捕获阶段，`false` 表示冒泡阶段，会先执行捕获

* `DOM 2` 级同名事件不会覆盖，按先后顺序执行

* `DOM 2` 级最内层的元素不区分冒泡和捕获，按先后顺序执行（无论是 `DOM 0` 级还是 `DOM 2` 级）



## 函数的 length 属性与 callee

> 需要注意：`ES6` 以后不再提倡使用 `callee` 属性

#### length

函数的 `length` 是形参列表的长度，就是函数定义的时候写在 `()` 中的参数个数，无视实参的个数

也就是说，`arguments.callee.length` 就是形参列表的个数，而 `arguments.length` 则表示实参个数

即在调用函数的时候传入进来的实参个数

```js
function fn(a, b, c, d, e, f) {
  console.log(arguments.callee.length);  // 6
  console.log(arguments.length);  // 3
}

fn(1, 2, 3)
```


#### callee

在函数内部，如果想要得到函数本身，使用 `this` 是得不到的，这时一般会使用 `arguments.callee`

```js
function fn() {
  console.log(arguments.callee === fn);  // true，即 arguments.callee 就是函数本身
}

fn();
```


#### 相关实例

```js
function fun(m, n, o, p, q, r) {
  alert(this.length);
}

function f(a, b) {
  arguments[0](9, 10, 11, 12, 13);
}

f(fun, 5, 6, 7);  // 4
```

函数的最终调用，是 `arguments` 对象进行的调用，而 `arguments` 对象则是一个类数组对象，所以函数 `fun` 中的 `this` 就是代表的 `arguments` 对象，所以 `this.length` 就是表示调用函数 `f()` 的实参个数

如果换成如下形式

```js
function fun(m, n, o, p, q, r) {
  alert(this.callee.length);
}

function f(a, b) {
  arguments[0](9, 10, 11, 12, 13);
}

f(fun, 5, 6, 7);  // 2
```

因为函数 `fun` 里面的 `this` 是 `arguments` 对象，所以 `arguments` 对象的 `callee` 属性就是 `f()` 函数

它的长度就是它的形参列表个数，为 `2`


再来看一个相关示例

```js
function fun(a, b, c, d) {
  // 决定了 fun2 当中的 this 指向的是 fun 当中的 arguments 对象
  arguments[0](5, 6);
}

function fun2(q, w, e, r, t) {
  alert(this.length);              // 6
  alert(this.callee.length);       // 4
  alert(arguments.length);         // 2
  alert(arguments.callee.length);  // 5
}

fun(fun2, 8, 9, 10, 11, 12);
```



#### 综合案例

```js
var number = 2;

var obj = {

  number: 4,

  // fn1 是一个 IIFE
  fn1: (function () {
    // 此时 this 为 window，即把全局变量中的 number 修改为了 4
    this.number *= 2;

    // 因为下面的变量提升，所以此时的 number 为 undefined，所以 undefined * 2 为 NaN
    number = number * 2;

    // 变量提升，var number;
    var number = 3;

    // 然后返回一个函数（闭包）
    return function () {

      // 闭包特性，此时 this 为 window，所以此时全局变量中的 number 为 8
      this.number *= 2;

      // 闭包特性，number 可以拿到 fn1() 作用域当中的 number 值，所以 3 * 3 = 9
      number *= 3;

      // 9
      alert(number);
    }
  })()
}

var fn1 = obj.fn1;

// 此时全局中的 number 为 4
// 因为 IIFE 肯定最先执行
alert(number);

// 调用的实际上是返回的那个函数
// 把全局中的 number 变为了 8，闭包中的 number 变为了 9
// 执行的 alert() 弹出的是闭包中的 number 为 9
fn1();

// 这样调用的话，this 指向的是 obj
// 此时 this.number *= 2; 即把 obj.number 变为了 8
// 此时的闭包还是老的闭包，因为没有重新赋值（因为没有执行过类似 var fn1 = obj.fn1 的操作）
// 因为之前执行过 fn1，所以闭包中的 number 为 9，此时再次调用后变为 27
obj.fn1();

// 此时全局的 number 为 8
alert(window.number);

// 8
alert(obj.number);
```



## 原型链

每一个构造函数都有一个属性叫做 `prototype`，指向一个对象，当这个构造函数被 `new` 的时候，它的每一个实例的 `__proto__` 属性都会指向这个属性

每一个函数天生都有 `prototype` 属性，指向一个空对象，也就是说，不需要去手动的定义这个属性

```js
function People(name, age) {
  this.name = name;
  this.age = age;
}

var man = new People("小明", 20);

People.prototype === man.__proto__;  // true
```

如上，这时的 `People.prototype` 是 `People` 构造函数的 "原型"，`People.prototype` 则是 `man` 的 "原型对象"

当 `man` 身上没有某个属性或者方法的时候，它会沿着 `__proto__` 属性依次向上查询

总结如下：

* 任何函数都有 `prototype`，是一个空对象（也有特殊情况，比如 `Object.create(null)`）

* `prototype` 的值是一个对象，这个函数 new 出来的实例对象的 `__proto__` 是指向这个函数的 `prototype` 的




#### 什么是类式和原型继承，两者有什么区别

#### 类式继承（构造函数）

类式继承是在函数对象内调用父类的构造函数，使得自身获得父类的方法和属性（```call``` 和 ```apply``` 方法为类式继承提供了支持）

```js
var father = function () {
  this.age = 20;
  this.say = function () {
    alert('hello i am ' + this.name + ' and i am ' + this.age + 'years old');
  }
}

var child = function () {
  this.name = 'zhangsan';
  father.call(this);
}

var man = new child();
man.say();
```


#### 原型继承

它有别于类继承是因为继承不在对象本身，而在对象的原型上（```prototype```）

当一个对象需要调用某个方法时，它回去最近的原型上查找该方法，如果没有找到，它会再次往下继续查找，这样逐级查找，一直找到了要找的方法，这些查找的原型构成了该对象的原型链条（最后指向 ```null```）

```js
var father = function () {}
father.prototype.a = function () {}

var child = function () { }
child.prototype = new father();

var man = new child();
man.a();
```


#### 对比

构造函数继承的方法都会存在父对象之中，每一次实例，都会将 ```funciton``` 保存在内存中，这样的做法毫无疑问会带来性能上的问题，其次类式继承是不可变的，在运行时，无法修改或者添加新的方法，而且类式继承不支持多重继承

而原型继承是可以通过改变原型链接而对子类进行修改的（重写方法即可），对于原型继承，可以使用类似 ```extend``` 等方法对对象进行扩展


#### 组合模式

另外的一种模式，是结合类继承和原型继承的各自优点来进行对父类的继承，用类式继承属性，而原型继承方法，这种模式避免了属性的公用，因为一般来说，每一个子类的属性都是私有的，而方法得到了统一

```js
function father() {
  this.a = 'father'
}

father.prototype.b = function () {
  alert(this.a)
}

var child = function () {
  father.call(this)
}

child.prototype = new father();
```


#### 使用 Object.create(...)

还有一种方式就是使用 ```Object.create()``` 来实现，```Object.create()``` 的作用是 创建一个空对象，并且这个对象的原型指向这个参数

典型的"原型风格"：

```js
function Foo(name) {
  this.name = name;
}

Foo.prototype.myName = function () {
  return this.name;
};

function Bar(name, label) {
  Foo.call(this, name);
  this.label = label;
}

// 我们创建了一个新的 Bar.prototype 对象并关联到 Foo.prototype
Bar.prototype = Object.create(Foo.prototype);

// 注意！现在没有 Bar.prototype.constructor 了
// 如果你需要这个属性的话可能需要手动修复一下它
// Bar.prototype.constructor = Bar;

Bar.prototype.myLabel = function () {
  return this.label;
};

var a = new Bar('a', 'obj a');

a.myName(); // 'a'
a.myLabel(); // 'obj a'
```

#### 关于 constructor

代码如下：

```js
var father = function () {}
var child = function () { }

child.prototype = new father();
var man = new child();
```

任何一个 ```prototype``` 对象都有一个 ```constructor``` 属性，指向它的构造函数，在执行比如下面步骤之前，

```js
child.prototype = new father();
```

```child.prototype.constructor``` 是指向 ```child``` 的，但是在执行以后，```child.prototype.constructor``` 便指向了 ```father```

更重要的是，每一个实例也有一个 ```constructor``` 属性，默认调用 ```prototype``` 对象的 ```constructor``` 属性

```js
// 运行前
man.constructor == child.prototype.constructor  // true

// 运行后
man.constructor == father  // true
```

这显然会导致继承链的紊乱（```man``` 明明是用构造函数 ```child``` 生成的），因此我们必须手动纠正，将 ```child.prototype``` 对象的 ```constructor``` 值改为 ```child```

这是很重要的一点，即如果替换了 ```prototype``` 对象

```js
o.prototype = {};
```

那么，下一步必然是为新的 ```prototype``` 对象加上 ```constructor``` 属性，并将这个属性指回原来的构造函数

```js
o.prototype.constructor = o;
```

#### 总结

其实还有另外一种方式，用如上例子表示就是：

```js
child.prototype = father.prototype;
```

这样一来，在改变 ```child``` 的同时，也将同时改变 ```father```

即 ```child.prototype``` 和 ```father.prototype``` 现在指向了同一个对象，那么任何对 ```child.prototype``` 的修改，都会反映到 ```father.prototype```，强烈不推荐

而之前的：

```js
child.prototype = new father();
```

说起来也会存在一些小问题，这样一来相当于直接运行了一遍 ```father```（new 的作用），如果在 ```father``` 里做了一些其他事情（比如改变全局变量等）就会造成一些副作用

所以如果要实现继承的话，推荐使用 ```Object.create(...)```



## 深复制 和 浅复制

深复制 和 浅复制 只针对像（```Object```），```Array``` 这样的复杂对象

简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级

详细可以参考：[变量的赋值与深浅拷贝](https://github.com/heptaluan/blog/blob/master/js/note/06.md)


#### 浅复制

一个简单的浅复制实现

```js
var obj = { a: 1, arr: [2, 3] };
var shallowObj = shallowCopy(obj);

function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}
```

因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 ```JavaScript``` 存储对象都是存地址的，所以浅复制会导致 ```obj.arr``` 和 ```shallowObj.arr``` 指向**同一块内存地址**

![img](https://pic4.zhimg.com/v2-39761dfd012733879e0d100ec260a5d7_b.png)

所以

```js
shallowObj.arr[1] = 5;

obj.arr[1]   // = 5
```

#### 深复制

而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上，这就不会存在上面 ```obj``` 和 ```shallowObj``` 的 ```arr``` 属性指向同一个对象的问题

```js
var obj = { a:1, arr: [1,2] };

var obj2 = deepCopy(obj);
```

![img](https://pic1.zhimg.com/6604224933c95787764d941432a1f968_b.jpg)

```js
function deepCopy(o, c) {

  var c = c || {}

  for (var i in o) {
    if (typeof o[i] === 'object') {
      // 要考虑深复制问题了
      if (o[i].constructor === Array) {
        // 这是数组
        c[i] = []
      } else {
        // 这是对象
        c[i] = {}
      }
      deepCopy(o[i], c[i])
    } else {
      c[i] = o[i]
    }
  }
  return c
}
```


## JavaScript 中的 mixin

```JavaScript``` 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类，毕竟一个对象只有一个原型，如果想实现多继承，可以使用 ```mixin```

```mixin``` 简单通俗的讲就是把一个对象的方法和属性拷贝到另一个对象上（和继承有区别）

```mixin``` 就是一个正常的类，不仅定义了接口，还定义了接口的实现

子类通过在 ```this``` 对象上面绑定方法，达到多重继承的目的

一个简单的 ```mixin```

```js
function extend(destClass, srcClass) {
  var destProto = destClass.prototype;
  var srcProto = srcClass.prototype;
  for (var method in srcProto) {
    if (!destProto[method]) {
      destProto[method] = srcProto[method];
    }
  }
}

function Book() { }
Book.prototype.printName = function () {
  console.log('I am a book, named hello');
};

function JS() { }

extend(JS, Book);
var js = new JS();
console.log(js);
```

```mixin``` 实现多继承

```js
function extend(destClass) {
  var classes = Array.prototype.slice.call(arguments, 1);
  for (var i = 0; i < classes.length; i++) {
    var srcClass = classes[i];
    var srcProto = srcClass.prototype;
    var destProto = destClass.prototype;
    for (var method in srcProto) {
      if (!destProto[method]) {
        destProto[method] = srcProto[method];
      }
    }
  }
}

function Book() { }
Book.prototype.getName = function () { };
Book.prototype.setName = function () { };

function Tech() { }
Tech.prototype.showTech = function () { };

function JS() { }

extend(JS, Book, Tech);
var js = new JS();
console.log(js);
```

很多前端库里都有 ```mixin``` 方法，比如 ```jQuery``` 的 ```extend```，```Underscore``` 中的 ```_.extend```



## 常见函数 once/bind/debouce/throttle 的实现原理

#### once

原理是利用闭包的特性，传递参数，执行完一次以后就自动解除绑定

```js
function once(dom, event, callback) {
  var handle = function () {
    callback();
    dom.removeEventListener(event, handle);
  }
  dom.addEventListener(event, handle)
}
```

第二种方式

```js
const once = (fn) => {
  let done = false;
  return function () {
    done ? undefined : ((done = true), fn.apply(this, arguments));
  }
}

const test = once(() => {
  console.log(`test`);
})

test();  // test
test();  // undefined
```

#### bind

简单的实现方式为

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function () {
    var self = this,                        // 保存原函数
      context = [].shift.call(arguments),   // 保存需要绑定的 this 上下文
      args = [].slice.call(arguments);      // 剩余的参数转为数组
    return function () {                    // 返回一个新函数
      self.apply(context, [].concat.call(args, [].slice.call(arguments)));
    }
  }
}
```

`MDN` 上 `bind` 的实现为下面这种

```js
if (!Function.prototype.bind) {

  Function.prototype.bind = function (oThis) {

    if (typeof this !== "function") {
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
      fToBind = this,
      fNOP = function () { },
      fBound = function () {
        return fToBind.apply(this instanceof fNOP
          ? this
          : oThis,
          aArgs.concat(Array.prototype.slice.call(arguments)));
      };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;

  };
}
```


#### debounce

在某些场景下，比如拖拽（```mousemove```），窗口大小调整（```resize```）等事件，触发频率比较高，若稍处理函数很复杂的话，就需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，导致假死或者卡顿感

这种情况下就出现了函数节流（```throttle```），和其类似的就是 ```debounce``` 函数，这两个函数的目的都是为了解决上述问题

#### 原理

比如每天上班大厦底下的电梯，把电梯完成一次运送，类比为一次函数的执行和响应，假设电梯有两种运行策略 ```throttle``` 和 ```debounce``` ，超时设定为 ```15``` 秒，不考虑容量限制

* ```throttle``` 策略的电梯，保证如果电梯第一个人进来后，```15``` 秒后准时运送一次，不等待，如果没有人，则待机

* ```debounce``` 策略的电梯，如果电梯里有人进来，等待 ```15``` 秒，如果有人进来，```15``` 秒等待重新计时，直到 ```15``` 秒超时，开始运送

#### debounce

```js
// 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 time，handle 才会执行
// debounce(time, handle)
var debounce = function (time, handle) {
  var last
  return function () {
    var ctx = this, args = arguments
    clearTimeout(last)
    last = setTimeout(function () {
      handle.apply(ctx, args)
    }, time)
  }
}
```


#### throttle

```js
// 频率控制 返回函数连续调用时，handle 执行频率限定为 次/time
// throttle(time, handle)

var throttle = function (time, handle) {
  var last = 0;
  return function () {
    var curr = +new Date();
    if (curr - last > time) {
      handle.apply(this, arguments)
    }
    last = curr;
  }
}
```



## 拖拽功能

#### PC 端拖拽功能

```js
var div = document.getElementById('div');

div.onmousedown = function (e) {
  var e = e || event;
  var disX = e.clientX - div.offsetLeft;
  var disY = e.clientY - div.offsetTop;

  document.onmousemove = function (e) {
    var e = e || event;
    div.style.left = e.clientX - disX + 'px';
    div.style.top = e.clientY - disY + 'px';
  }

  document.onmouseup = function () {
    document.onmousemove = null;
    document.onmouseup = null;
  }
}
```

#### 面向对象版本

```js
window.onload = function () {
  new Drag('div1');
  new Drag('div2');
};

function Drag(id) {
  var disX = 0;
  var disY = 0;
  var _this = this;

  this.oDiv = document.getElementById(id);
  this.oDiv.onmousedown = function (ev) {
    _this.fnDown(ev);

    return false;
  };
}

Drag.prototype.fnDown = function (ev) {
  var oEvent = ev || event;
  var _this = this;

  this.disX = oEvent.clientX - this.oDiv.offsetLeft;
  this.disY = oEvent.clientY - this.oDiv.offsetTop;

  document.onmousemove = function (ev) {
    _this.fnMove(ev);
  };

  document.onmouseup = function () {
    _this.fnUp();
  };
}

Drag.prototype.fnMove = function (ev) {
  var oEvent = ev || event;
  this.oDiv.style.left = oEvent.clientX - this.disX + 'px';
  this.oDiv.style.top = oEvent.clientY - this.disY + 'px';
}

Drag.prototype.fnUp = function () {
  document.onmousemove = null;
  document.onmouseup = null;
}
```

#### 移动端拖拽功能

与 ```PC``` 端实现类似，只是事件不太一样，一般用到的事件如下：

```js
touchstart:       // 手指放到屏幕上时触发

touchmove:        // 手指在屏幕上滑动式触发

touchend:         // 手指离开屏幕时触发


// 每个触摸事件被触发后，会生成一个 event 对象，event 对象里额外包括以下三个触摸列表:

touches:          // 当前屏幕上所有手指的列表

targetTouches:    // 当前 dom 元素上手指的列表，尽量使用这个代替 touches

changedTouches:   // 涉及当前事件的手指的列表，尽量使用这个代替 touches
```

```js
var div = document.getElementById('div');
var disX, disY;

div.addEventListener('touchstart', function (e) {
  var touches = e.targetTouches[0];
  disX = touches.clientX - div.offsetLeft;
  disY = touches.clientY - div.offsetTop;

  document.addEventListener('touchmove', function (e) {
    var touches = e.targetTouches[0];
    div.style.left = touches.clientX - disX + 'px';
    div.style.top = touches.clientY - disY + 'px';
  })

  document.addEventListener('touchend', function () {
    document.removeEventListener('touchmove', false)
  })

}, false);
```


## 如何监听 对象/数组 属性改变

#### 监听对象属性改变

在 ```ES5``` 中新增了一个 ```Object.defineProperty``` 的方法，可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象

```js
Object.defineProperty(obj, prop, descriptor)
```

其接受的第三个参数可以取 ```get/set``` 并各自对应一个 ```getter/setter``` 的方法

```js
var a = { obj: 0 };

Object.defineProperty(a, 'obj', {

  get: function () {
    console.log('get：' + obj);
    return obj;
  },

  set: function (value) {
    obj = value;
    console.log('set:' + obj);
  }

});

a.obj = 2; // set: 2
console.log(a.obj); // get：2
```

有个缺点就是在 ```IE8``` 及更低版本 IE 是无法使用的，因为这个特性是没有 ```polyfill``` 的，所以无法在不支持的平台实现


#### Proxy

另外还可以使用 ```ES6``` 提供的 ```Proxy``` 代理来处理

```js
var user = {}

var proxy = new Proxy(user, {

  get(target, property) {
    console.log(`get prop ${property}`)
    return `[${target[property]}]`
  },

  set(target, property, value) {
    console.log(`set prop ${property}`)
    target[property] = btoa(value)
  }
})

proxy.name = "admin"  // set prop name
                      // "admin"
```

#### 监听数组的变化

简单来说，就是定义一个新数组，然后继承原生的 ```Array```，然后重写其中我们需要监听的方法（```pop```，```push``` 等）

```js
class NewArray extends Array {
  constructor(...args) {
    // 调用父类 Array 的 constructor
    super(...args)
  }

  push(...args) {
    console.log(`监听到数组变化`)
    // 调用父类方法
    return super.push(...args);
  }
}

let arr = [1, 2];
let newArr = new NewArray(...arr);
console.log(newArr)  // [1, 2]

newArr.push(3);      // 监听到数组变化
console.log(newArr)  // [1, 2, 3]
```

#### 关于 ES5 以下实现

在 ```ES5``` 及以下的 ```JS``` 无法完美继承数组，因为 ```Array``` 构造函数执行时不会对传进去的 ```this``` 做任何处理，不止 ```Array```，```String```，```Number```，```Regexp```，```Object``` 等等 ```JS``` 的内置类都不行

数组其响应式的 ```length``` 属性以及内部的 ```[[class]]``` 属性我们无法再 ```JS``` 层面实现，这就导致我们无法去用任何一个对象来 "模仿" 一个数组

但是可以使用非标准属性 ```__proto__``` 来实现















## 判断变量类型，如何判断变量是函数

#### 原始值

在 `JS` 中有 `5` 种原始类型：字符串，数字，布尔值，`null` 和 `undefined`，如果你希望检测一个值是否为原始类型，最佳选择是使用 `typeof` 运算符

```js
对于字符串，typeof 返回 'string'

对于数字，typeof 返回 'number'

对于布尔值，typeof 返回 'boolean'

对于undefined，typeof 返回 'undefined'
```

还有一个原始值 `null`，一般不用于检测语句，但有一个例外，如果所期望的值真的是 `null`，则可以直接和 `null` 进行比较，这时应当使用 `'==='` 或者 `'!=='` 来和 `null` 进行比较

```js
var element = document.getElementById('myDiv');
 
if (element !== null) {
  element.classList.add('found');
}
```


#### 引用值

在 `JS` 中除了原始值之外的值都是引用，有这几种内置的引用的类型：`Object`, `Array`, `Error`, `Date`

`typeof` 运算符在判断这些引用类型的时候就显得力不从心，因为所有的对象都会返回 `'object'`

```js
console.log(typeof {});  // 'object'
 
console.log(typeof []);  // 'object'
 
console.log(typeof new Date());  // 'object'
 
console.log(typeof new RegExp());  // 'object'
```

所以，在检测某个引用值的类型的最好的方法是使用 `instanceof` 运算符：

```js
// 检测日期
if (value instanceof Date) {
  console.log(value.getFullYear());
}
 
// 检测正则表达式
if (value instanceof RegExp) {
  if (value.test(anotherValue)) {
    console.log('Matches');
  }
}
 
// 检测 Error
if (value instanceof Error) {
  throw value;
}
```

默认情况下，每个对象都继承自 `Object`，因此每个对象的 `value instanceof Object` 都会返回 `true`

```js
var now = new Date();
 
console.log(now instanceof Date);    // true
console.log(now instanceof Object);    // true
```

正因为这个原因，使用 `value instanceof Object` 来判断对象是否属于某个特定类型的做法并非最佳

在 `JS` 中检测自定义类型的时候，最好的做法就是使用 `instanceof` 运算符，这也是唯一的方法，但是也有例外（跨 `frame`）


#### 函数检测

检测函数最好的方法是使用 `typeof` ，因为它可以跨 `frame` 使用

```js
function myFunc () {}
 
// 推荐，返回的是 function
console.log( typeof myFunc === 'function' );  // true
```


#### 数组检测

`ES5` 中将 `Array.isArray()` 正式的引入，唯一的目的就是检测一个值是否为数组

```js
function isArray (value) {
  if (typeof Array.isArray === 'function') {
    return Array.isArray(value);
  } else {
    return Object.prototype.toString.call(value) === '[object Array]';
  }
}
```


#### 属性检测

判断属性是否存在的最好的方法是使用 `in` 运算符，`in` 运算符仅仅会简单的判断属性是否存在，而不会去读属性的值，如果实例对象的属性存在，或者继承自对象的原型，`in` 运算符都会返回 `true`

```js
var object = {
  count: 0,
  related: null
};
 
// 推荐
if ('count' in object) {
  // ...
}
 
// 不推荐
if (object['count']) {
  // ...
}
```

如果你只想检查实例对象的某个属性是否存在，则使用 `hasOwnProperty()` 方法

所以在判断实例对象是否存在的时候，推荐使用 `in` 运算符，只有在需要判断实例属性的时候才会用到 `hasOwnProperty()`



#### 总结

* 原始值（字符串，数字，布尔值，`undefined`）  --  `typeof`

* 引用值（`Date`，`RegExp`，`Error`）  --  `instanceof`

* 函数  --  `typeof`

* 数组  --  `isArray`

* 属性检测（是否存在）  --  `in` / `hasOwnProperty()`






## JavaScript 中的几种遍历对象的方式

`JS` 中遍历对象的方法，小小的总结一下，大致有以下几种

```js

Object.keys(obj)                  // 返回所有可枚举属性（不包括原型中属性，不含 Symbol 属性）
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组）

for...in                          // 返回所有可枚举属性（包括原型中的属性，不含 Symbol 属性）
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）

Object.getOwnPropertyNames(obj)   // 返回所有的自身属性（不包括原型中属性，不含 Symbol 属性，包括不可枚举（length））
                                  // （如果参数不是一个对象，ES6 之前报错，之后强制转换为对象）（返回数组）

Reflect.ownKeys(obj)              // 返回所有的自身属性（不管是否可枚举，不管是不是 Symbol，一律返回）
                                  // （如果参数不是一个对象，报错）（返回数组）

for...of                          // 返回当前对象上的每一个属性（不包括原型中的属性，包括 Symbol 属性）
                                  // （对于普通的对象，for...of 不能直接使用，否则会报错，必须部署了 iterator 接口才能使用）

```

#### Object.keys(obj)

返回一个表示给定对象的所有可枚举**属性**的**字符串数组**，包括对象自身的（不含继承的）所有可枚举属性（不含 `Symbol` 属性）

```js
var arr = ['a', 'b', 'c'];

console.log(Object.keys(arr));  // ['0', '1', '2']

// -------------------------------

var an_obj = { 100: 'a', 2: 'b', 7: 'c' };

console.log(Object.keys(an_obj));  // ['2', '7', '100']
```

几个注意点：

* 返回所有可枚举属性（不包括原型中属性，不含 `Symbol` 属性）（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）（返回数组）

* 返回的是一个表示给定对象的所有可枚举**属性**的**字符串数组**（但不包括原型中的属性）

* 数组中属性名的排列顺序和使用 `for...in` 循环遍历该对象时返回的顺序一致

* 因为 `for...in` 语句无法保证遍历顺序，故 `Object.keys(obj)` 顺序也是无法保证的，原因如下

  * `Chrome`，`Opera` 的 `JavaScript` 解析引擎遵循的是新版 `ECMA-262` 第五版规范，因此，使用 `for...in` 语句遍历对象属性时遍历书序并非属性构建顺序

  * 而 `IE6`，`IE7`，`IE8`，`Firefox`，`Safari` 的 `JavaScript` 解析引擎遵循的是较老的 `ECMA-262` 第三版规范，属性遍历顺序由属性构建的顺序决定




#### for...in

`for...in` 语句以任意顺序遍历一个对象的可枚举属性，对于每个不同的属性，语句都会被执行

```js
var obj = { a: 1, b: 2, c: 3 };

for (var prop in obj) {
  console.log(prop);  // a b c
}
```

几个注意点：

* 返回所有可枚举属性（包括原型中的属性，不含 `Symbol` 属性）（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）

* `for...in` 循环只遍历**可枚举**属性，循环将迭代对象的所有可枚举属性和从它的构造函数的 `prototype` **继承**而来的（包括被覆盖的内建属性）（即包括原型中的属性）

* `for...in` 不应该被用来迭代一个下标顺序很重要的 `Array`

* `for...in` 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的

* 如果仅迭代自身的属性，而不是它的原型，可以使用：

  * `getOwnPropertyNames()`  ==> 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组

  * `hasOwnProperty()`  ==> 来确定某属性是否是对象本身的属性（一般使用这个来过滤）

  * `propertyIsEnumerable()`  ==> 返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性



#### Object.getOwnPropertyNames(obj)

`Object.getOwnPropertyNames()` 方法返回一个由指定对象的所有自身属性的属性名（**包括**不可枚举属性）组成的数组（但不会获取原型链上的属性）

```js
var arr = ['a', 'b', 'c'];

console.log(Object.getOwnPropertyNames(arr).sort()); // ['0', '1', '2', 'length']
```

几个注意点：

* 返回所有的自身属性（不包括原型中属性，不含 `Symbol` 属性，包括不可枚举（`length`））（如果参数不是一个对象，`ES6` 之前报错，之后强制转换为对象）（返回数组）

* 返回指定对象的所有自身属性的属性名**包括不可枚举属性**组成的数组

* 不会获取原型链上的属性

* 枚举属性的顺序与通过 `for...in` 循环（或 `Object.keys`）迭代该对象属性时一致

* 如果只获取到可枚举属性，使用 `Object.keys` 或用 `for...in` 循环（配合 `hasOwnProperty()`）


#### Reflect.ownKeys

静态方法 `Reflect.ownKeys()` 返回一个由目标对象自身的属性键组成的数组

```js
Reflect.ownKeys({ z: 3, y: 2, x: 1 }); // [ 'z', 'y', 'x' ]

Reflect.ownKeys([]); // ['length']
```

几个注意点：

* 返回所有的自身属性（不管是否可枚举，不管是不是 `Symbol`，一律返回）（如果参数不是一个对象，报错）（返回数组）

* 返回值等同于 `Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`



#### for...of

`for...of` 语句在可迭代对象（包括 `Array`, `Map`, `Set`, `String`, `TypedArray`（描述一个底层的二进制数据缓存区的一个类似数组（`array-like`）视图），`arguments` 对象等）上创建一个迭代循环，对每个不同属性的属性值，调用一个自定义的有执行语句的迭代挂钩

```js
let iterable = [10, 20, 30];

for (let value of iterable) {
  console.log(value);
}
// 10
// 20
// 30

//-----------------------------

let iterable = 'foo';

for (let value of iterable) {
  console.log(value);
}
// 'f'
// 'o'
// 'o'
```

几个注意点：

* 返回当前对象上的每一个属性（对于普通的对象，`for...of` 不能直接使用，否则会报错，必须部署了 `iterator` 接口才能使用）（不包括原型中的属性，包括 `Symbol` 属性）

* 并不适用于所有的 `object`，可以迭代出任何拥有 `iterator` 的对象

* `for...of` 遍历的是**当前对象上**的每一个属性值（不包括原型上的）





## 一些数组常用的方法和其返回值

#### 会改变调用它们的对象自身的值（不会返回新数组）

```js
Array.prototype.copyWithin()  // 在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值

Array.prototype.fill()        // 将数组中指定区间的所有元素的值，都替换成某个固定的值

Array.prototype.pop()         // 删除数组的最后一个元素，并返回这个元素

Array.prototype.push()        // 在数组的末尾增加一个或多个元素，并返回数组的新长度

Array.prototype.reverse()     // 颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个

Array.prototype.shift()       // 删除数组的第一个元素，并返回这个元素

Array.prototype.sort()        // 对数组元素进行排序，并返回当前数组

Array.prototype.splice()      // 在任意的位置给数组添加或删除任意个元素

Array.prototype.unshift()     // 在数组的开头增加一个或多个元素，并返回数组的新长度
```

#### 不会改变调用它们的对象的值（返回一个新的数组或者返回一个其它的期望值）

```js
Array.prototype.concat()          // 返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组

Array.prototype.includes()        // 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false

Array.prototype.join()            // 连接所有数组元素组成一个字符串

Array.prototype.slice()           // 抽取当前数组中的一段元素组合成一个新数组

Array.prototype.toString()        // 返回一个由所有数组元素组合而成的字符串，遮蔽了原型链上的 Object.prototype.toString() 方法

Array.prototype.toLocaleString()  // 返回一个由所有数组元素组合而成的本地化后的字符串，遮蔽了原型链上的 Object.prototype.toLocaleString() 方法

Array.prototype.indexOf()         // 返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1

Array.prototype.lastIndexOf()     // 返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1

// 一个非标准的
Array.prototype.toSource()        // 返回一个表示当前数组字面量的字符串，遮蔽了原型链上的 Object.prototype.toSource() 方法

// 还有两个方法可以返回新数组

Array.from()    // 从类数组或者迭代对象（iterable object）中创建一个新的数组实例

Array.of()      // 创建一个有可变数量的参数的新的数组实例，无论参数有多少数量，而且可以是任意类型
```








## ajax，formData，同源策略，跨域

一些相关知识点：

```IE7+``` 已经内建 ```XMLHttpRequest``` 对象

老版本 ```IE``` 可以使用 ```ActiveX``` 对象（```new ActiveXObject('Microsoft.XMLHTTP')```）

在以下情况中，请使用 ```POST``` 请求：

* 无法使用缓存文件（更新服务器上的文件或数据库）

* 向服务器发送大量数据（```POST``` 没有数据量限制）

* 发送包含未知字符的用户输入时，```POST``` 比 ```GET``` 更稳定也更可靠

```open()``` 方法第三个参数表示 异步 操作（```true```）


#### 原生 ajax

```js
var xhr = new xhrRequest();

if (xhr) {

  xhr.open('GET', url);

  // 每当 readyState 值改变时，就会触发 onreadystatechange 事件
  // 注意：onreadystatechange 事件会被触发 5 次（0 - 4），对应着 readyState 的每个变化
  xhr.onreadystatechange = function () {

    // readyState 值说明  
    // 0 -- 初始化，xhr 对象已经创建，还未执行 open  
    // 1 -- 载入，已经调用 open 方法，但是还没发送请求  
    // 2 -- 载入完成，请求已经发送完成  
    // 3 -- 交互，可以接收到部分数据  
    // 4 -- OK

    // status 值说明  
    // 200: 成功  
    // 404: Not Found
    // 500: 服务器产生内部错误  
    if (xhr.readyState == 4 && xhr.status == 200) {
      // 响应分为两种
      // responseText -- 获得字符串形式的响应数据（通常是这个）
      // responseXML -- 获得 XML 形式的响应数据
      console.log(xhr.responseText);
    }
  };

  xhr.send();

}

// ---------------------------------------------------

// 如果需要使用 POST 请求发送表单数据，使用 setRequestHeader() 来添加 HTTP 头
// 然后在 send() 方法中添加需要发送的数据

// 在 Form 元素的语法中，EncType 表明提交数据的格式，用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型

// 下面是三种常用的设置方式
// application/x-www-form-urlencoded   -- 窗体数据被编码为 名称/值 对，这是标准的编码格式
// multipart/form-data                 -- 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分
// text/plain                          -- 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符 

xhr.open('POST', url, true);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(data);
```

如果 ```ajax``` 指定为 ```post``` 但是未设置 ```content-type``` 或未指定键时，由于 ```content-type``` 为 ```text/plain```，动态页并未帮你处理成键值对的形式，所以你得自己使用 ```2``` 进制流数据生成对应的 ```string``` 类型的数据

所以如果要生成键值对形式，你得指定 ```content-type``` 为 ```'application/x-www-form-urlencoded'```


#### ajax 改为 Promise

```js
function ajax(method, url, data) {
  var xhr = new XMLHttpRequest();
  return new Promise(function (resolve, reject) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4 && xhr.status == 200) {
        resolve(xhr.responseText)
      } else {
        reject(xhr.status)
      }
    }
    xhr.open(method, url)
    xhr.send(data)
  })
}

// 使用
var p = ajax('GET', url);

p.then(function (data) {
  console.log(data)
}).catch(function (status) {
  console.log(`Error: ${status}`)
})
```

----

#### xhr2

```xhr2``` 于 ```xhr``` 最大的区别在于 ```xhr``` 只支持字符串类型的数据，而 ```xhr2``` 支持任意类型的数据，比如使用 ```xhr2``` 向服务器请求一张图片

```js
var xhr = new XMLHttpRequest();
xhr.open('get', url, true)

// 处理返回内容的类型
xhr.responseType = 'bold';

xhr.onload = function (e) {
  if (this.status == 200) {
    var url = window.URL.createObjectURL(this.responseType);
    var img = new Image();
    img.src = url;
    document.body.appendChild(img);
  }
}

xhr.send();
```

#### FormData 接口

简单来说，比起普通的 ```ajax```, 使用 ```FormData``` 的最大优点就是我们可以异步上传一个二进制文件

```js
// 如果带参数使用，比如 new FormData(someForm)，FormData 对象的作用就类似于 jQuery 中的的 serialize() 方法
// 得到的对象就是这个表单元素中所有键值对数据了
function sendForm(form) {
  var data = new FormData(form);

  // 在已知的表单后添加
  data.append({ 'user': '123' })
  xhr.send(data);
}

// 不带参数使用的话，可以使用 append 来添加我们想要的数据，比如常见的表单提交
var data = new FormData();
data.append({ 'user': '123' });

var xhr = new XMLHttpRequest();
xhr.open('POST', url, true);
xhr.send(data);
```

#### upload 属性

```xhr2``` 新增了一个 ```upload``` 属性，并可以为之绑定一个 ```onprogress``` 事件，检测上传的速度

```js
var xhr = new XMLHttpRequest();
xhr.open('POST', url, true);

var body = new FormData();
body.append(data);

xhr.upload.onprogress = function (e) {
  if (e.lengthComputable) {
    document.getElementById('test').innerHTML = (e.loaded / e.total * 100) + '%';
  }
};

xhr.send(body)
```


#### 同源策略

```JavaScript``` 出于安全方面的考虑，不允许跨域调用其他页面的对象

即 同协议，同端口，同域名

#### CORS

```xhr``` 不能跨越，但 ```xhr2``` 新增了跨源资源共享的能力

在服务器设置一些标头实现真正的跨域 ```ajax``` 请求 可以跨某个域的 ```http``` 标头

```js
Access-Control-Allow-Origin: *
```

可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的 ```Access-Control-Allow-Origin```，决定权始终在对方手中

假设本域是 ```my.com```，外域是 ```sina.com```，只要响应头 ```Access-Control-Allow-Origin``` 为 ```http://my.com```，或者是 ```*```，本次请求就可以成功

这种跨域请求，称之为'简单请求'。简单请求包括 ```GET```、 ```HEAD``` 和 ```POST```（```POST``` 的 ```Content-Type``` 类型，仅限 ```application/x-www-form-urlencoded```、 ```multipart/form-data``` 和 ```text/plain```），并且不能出现任何自定义头（例如， ```X-Custom: 12345``` ），通常能满足 ```90%``` 的需求

对于 ```PUT```、```DELETE``` 以及其他类型如 ```application/json``` 的 ```POST``` 请求，在发送 ```ajax``` 请求之前，浏览器会先发送一个 ```OPTIONS``` 请求（称为 ```preflighted``` 请求）到这个 ```URL``` 上，询问目标服务器是否接受：

```js
OPTIONS /path/to/resource HTTP/1.1
Host: bar.com
Origin: http://my.com
Access-Control-Request-Method: POST
```

服务器必须响应并明确指出允许的 ```Method```：

```js
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS
Access-Control-Max-Age: 86400
```

浏览器确认服务器响应的 ```Access-Control-Allow-Methods``` 头确实包含将要发送的 ```ajax``` 请求的 ```Method```，才会继续发送 ```ajax```，否则，抛出一个错误


#### document.domain

对于主域相同而子域不同的例子，可以通过设置 ```document.domain``` 的办法来解决。具体的做法是可以在 ```http://www.a.com/a.htm``` l和 ```http://script.a.com/b.html``` 两个文件中分别加上 ```document.domain = 'a.com'```

#### window.name

`window` 对象有个 `name` 属性，该属性有个特征：即在一个窗口（`window`）的生命周期内,窗口载入的所有的页面都是共享一个 `window.name` 的，每个页面对 `window.name` 都有读写的权限，`window.name` 是持久存在一个窗口载入过的所有页面中的

#### jsonp

实质上和 ```xhr``` 对象没有太大关系，其是借助了 ```script``` 标签节点可以跨域去访问，去获取的一个特性

```jsonp``` 只能对 ```GET``` 请求起到效果，即 ```jsonp``` 的方式是不支持 ```POST``` 请求的，这也是 ```jsonp``` 这种方式的局限性

原理是：动态插入 `script` 标签，通过 `script` 标签引入一个 `js` 文件，这个 `js` 文件载入成功后会执行我们在 `url` 参数中指定的函数，并且会把我们需要的 `json` 数据作为参数传入

```js
// JSONP 即 json+padding（内填充，就是把 JSON 填充到一个盒子里）
function createJs(sUrl) {
  var oScript = document.createElement('script');
  oScript.type = 'text/javascript';
  oScript.src = sUrl;
  document.getElementsByTagName('head')[0].appendChild(oScript);
}

createJs('jsonp.js');

box({
  'name': 'test'
});

function box(json) {
  alert(json.name);
}
```

#### GET 与 POST 区别

* 在客户端，```GET``` 方式在通过 ```URL``` 提交数据，数据在 ```URL``` 中可以看到，```POST``` 方式，数据放在 ```HTTP``` 包的 ```body``` 中

* ```GET``` 方式提交的数据大小有限制（因为浏览器对 ```URL``` 的长度有限制），而 ```POST``` 则没有此限制

* 安全性问题，使用 ```GET``` 的时候，参数会显示在地址栏上，而 ```POST``` 不会，所以如果这些数据是中文数据而且是非敏感数据，那么使用 ```GET```，如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 ```POST``` 为好

![GETPOST](GETPOST.png)


#### xhr 的 withCredentials 属性

默认情况下，```ajax``` 跨源请求不提供凭据（```cookie```、```HTTP``` 认证及客户端 ```SSL``` 证明等），通过将设置 ```ajax``` 的 ```withCredentials``` 属性设置为 ```true```，可以指定某个请求应该发送凭据，如果服务器接收带凭据的请求，会用下面的 ```HTTP``` 头部来响应

```js
Access-Control-Allow-Credentials: true
```

需要注意：永远不会影响到同源请求

简单来说，在平常开发的时候，身份验证是经常遇到的问题，在**跨域请求**中，默认情况下是不发送验证信息的，要想发送验证信息，需要设置 ```withCredentials``` 属性

```js
var xhr = new XMLHttpRequest();

xhr.open('GET', url, true);
xhr.withCredentials = true;

xhr.send(null);
```



## promise 和 setTimeout

首先它是一个对象，它和 ```javascript``` 普通的对象没什么区别，同时，它也是一种规范，跟异步操作约定了统一的接口，表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的

1. ```promise``` 只有三种状态，未完成，完成 (```fulfilled```) 和失败 (```rejected```)

2. ```promise``` 的状态可以由未完成转换成完成，或者未完成转换成失败

3. ```promise``` 的状态转换只发生一次

4. ```Promise``` 状态转换完成后就是外部**不可变**的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意的修改（特别是对于多方查看同一个 Promise 状态转换的情况）

```promise``` 有一个 ```then``` 方法，```then``` 方法可以接受 ```3``` 个函数作为参数

前两个函数对应 ```promise``` 的两种状态 ```fulfilled```, ```rejected``` 的回调函数，第三个函数用于处理进度信息（```.then()``` 总是返回一个新的 ```promise```）

一个简单的读取文件示例：

```js
var fs = require("fs");

function readFile() {
  return new Promise(function (resolve, reject) {
    fs.readFile("1.txt", "utf-8", function (err, data) {
      if (err) {
        reject(err)
      } else {
        resolve(data)
      }
    })
  })
}

readFile().then(function (data) {
  console.log(data)
}).catch(function (err) {
  console.log(err)
})
```

#### promise 和 setTimeout 执行顺序

详细可见 《你不知道的js（中卷）》 -- 1.5节

一个简单的示例：

```js
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function (resolve) {
  resolve();
}).then(function () {
  console.log(2);
});

// 2, 1
```

简单来说，```promise``` 的任务会在当前事件循环末尾中执行，而 ```setTimeout``` 中的任务是在下一次事件循环执行

在 ```ES6``` 中，有一个新的概念建立在事件循环队列之上，叫做 **任务队列**

简单的理解就是，它是挂在事件循环队列的每个 ```tick``` 之后的一个队列，在事件循环的每个 ```tick``` 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 ```tick``` 的任务队列末尾添加一个项目（任务）

一个任务可能引起更多任务被添加到同一个队列末尾，所以，理论上说，任务循环可能无限循环（一个任务总是添加另一个任务，以此类推），进而导致程序的无限循环，无法转移到下一个事件循环 ```tick```，从概念上看，这和代码中的无限循环（类似 ```while(true)```）的体验几乎是一样的

再来看一个实例

```js
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);
// 结果为 2 3 5 4 1
```

首先是一个 `setTimeout`，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 `1`

然后是一个 `Promise`，里面的函数是会立即执行的，所以首先输出 `2` 和 `3`

这里需要注意的是，`Promise` 的 `then` 应当会放到当前 `tick` 的最后，但是还是在当前 `tick` 中，所以会先输出 `5` 然后才会输出 `4`，最后轮到下一个 `tick` 之后才会输出 `1`

扩展：[promise 的队列与 setTimeout 的队列有何关联？](https://www.zhihu.com/question/36972010)

#### 再来看下面这个比较绕的问题


下面几个的输出值为多少

```js
// 一
for (var i = 0; i < 5; i++) {
  console.log(i);
}


// 二
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}


// 三
for (var i = 0; i < 5; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  })(i)
}


// 四
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}


// 五
for (var i = 0; i < 5; i++) {
  (function () {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  })(i)
}


// 六
for (var i = 0; i < 5; i++) {
  setTimeout((function (i) {
    console.log(i);
  })(i), i * 1000);
}



// 七
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);



// 八
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  setTimeout(function() {
    console.log(6)
  }, 0)
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);

```

----

----

1. 最基本的，输出 `0 - 4`

2. `setTimeout` 会延迟执行，那么执行到 `console.log` 的时候，其实 `i` 已经变成 `5` 了，所以结果为 `5` 个 `5`

3. 如果要输出 `0` 到 `4`，可以使用三和四两种方式

5. 去掉 `function()` 中的 `i`，内部就没有对 `i` 保持引用，结果还是 `5` 个 `5`

6. 如果修改成六这样，立即执行函数会立即执行，所以会立即输出 `0 - 4` 而不会延迟

7. 最后两个有些复杂，但是原理是类似的

都被改写成了 `Promise`，但是首先需要明确的是，`promise` 的任务会在当前事件循环末尾中执行，而 `setTimeout` 中的任务是在下一次事件循环执行

首先是一个 `setTimeout`，所以其中的任务是会在下一次事件循环中才会执行，因此开始肯定不会输出 `1`

然后是一个 `Promise`，里面的函数是会立即执行的，所以首先输出 `2` 和 `3`

这里需要注意的是，`Promise` 的 `then` 应当会放到当前 `tick` 的最后，但是还是在当前 `tick` 中（而不是下一次事件循环），所以会先输出 `5` 然后才会输出 `4`，最后轮到下一个 `tick` 才会输出 `1`

所以结果为 `2 3 5 4 1`

至于最后一个，和第七个是一样的，结果为 `2 3 5 4 1 6`



## IOS 移动端 click 事件 300ms 的延迟响应

移动设备上的 ```web``` 网页是有 ```300ms``` 延迟的，玩玩会造成按钮点击延迟甚至是点击失效，这是由于区分单击事件和双击屏幕缩放的历史原因造成的

双击缩放是指用手指在屏幕上快速点击两次，```iOS``` 自带的 ```Safari``` 浏览器会将网页缩放至原始比例

原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接 ```<a href="#"></a>```，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作

所以，捕获第一次单击后，浏览器会先等待一段时间 ```t```，如果在 ```t``` 时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果 ```t``` 时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作

这个 ```t``` 在 ```IOS safari``` 下，大概为 ```300``` 毫秒，这就是延迟的由来，造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于 ```web``` 开发者来说是，页面 ```js``` 捕获 ```click``` 事件的回调函数处理，需要 ```300ms``` 后才生效，也就间接导致影响其他业务逻辑的处理

一般常见的有以下几种解决方案：

* 使用 ```fastclick.js``` 库可以解决在手机上点击事件的 ```300ms``` 延迟

* ```zepto``` 的 ```touch``` 模块，```tap``` 事件也是为了解决在 ```click``` 的延迟问题

* 触摸事件的响应顺序为 ```touchstart``` --> ```touchmove``` --> ```touchend``` --> ```click```，也可以通过绑定 ```ontouchstart``` 事件，加快对事件的响应，解决 ```300ms``` 延迟问题


#### 从上面引申出来的 Zepto 点透问题

问题如下：

![点透](http://images.cnitblog.com/blog/546511/201503/011850313937285.png)

在点击弹出来的选择组件的右上角完成后会让完成后面的 ```input``` 输入框聚焦，弹出输入键盘，也就是点透了

这是因为 ```zepto``` 的 ```tap``` 是通过兼听绑定在 ```document``` 上的 ```touch``` 事件来完成 ```tap``` 事件的模拟的，及 ```tap``` 事件是冒泡到 ```document``` 上触发的

在点击完成时的 ```tap``` 事件（```touchstart/touchend```）需要冒泡到 ```document``` 上才会触发，而在冒泡到 ```document``` 之前，用户手的接触屏幕（```touchstart```）和离开屏幕（```touchend```）是会触发 ```click``` 事件的

因为 ```click``` 事件有延迟触发（就是上面的 ```300ms```，这也就是为什么移动端不用 ```click``` 而用 ```tap``` 的原因），所以在执行完 ```tap``` 事件之后，弹出来的选择组件马上就隐藏了

此时 ```click``` 事件还在延迟的 ```300ms``` 之中，当 ```300ms``` 到来的时候，```click``` 到的其实不是完成而是隐藏之后的下方的元素，如果正下方的元素绑定的有 ```click``` 事件此时便会触发，如果没有绑定 ```click``` 事件的话就当没 ```click```，但是正下方的是 ```input``` 输入框（或者 ```select``` 选择框或者单选复选框等其他组件），点击默认聚焦而弹出输入键盘，也就出现了上面的点透现象

几种解决方案：

方案一：引入 ``````fastclick.js``````，因为 ``````fastclick`````` 源码不依赖其他库所以你可以在原生的 ```js``` 前直接加上

```js
window.addEventListener("load", function () {
  FastClick.attach(document.body);
}, false);
```

方案二：用 ```touchend``` 代替 ```tap``` 事件并阻止掉 ```touchend``` 的默认行为 ```preventDefault()```

```js
$("#cbFinish").on("touchend", function (event) {
  // ...
  event.preventDefault();
});
```

方案三：延迟一定的时间（```300ms+```）来处理事件

```js
$("#cbFinish").on("tap", function (event) {
  setTimeout(function () {
    // ...
  }, 320);
}); 
```   

如果实在不行，那还是用 ```click``` 吧



## 字符编码

这里主要介绍 `ASCII`，`UTF-8`，`GBK`，`GB2312` 和 `Unicode`

#### ASCII

由于计算机是美国人发明的，因此，最早只有 `127` 个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 `ASCII` 编码，比如大写字母 `A` 的编码是 `65`，小写字母 `z` 的编码是 `122`

但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 `ASCII` 编码冲突

#### Unicode 编码

因此，`Unicode` 应运而生，`Unicode` 把所有语言都统一到一套编码里，`Unicode` 只是一个符号集，`Unicode` 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求

我们常见的 `UTF-8` 就是 `Unicode` 其中一个**实现方式**（还有 `utf-16`、`utf-10` 等）


#### UTF-8 编码

`ASCII` 编码是 `1` 个字节，而 `Unicode` 编码通常是 `2` 个字节，如果统一成 `Unicode` 编码，乱码问题从此消失了

但是，如果你写的文本基本上全部是英文的话，用 `Unicode` 编码比 `ASCII` 编码需要多一倍的存储空间，在存储和传输上就十分不划算

因此，又出现了把 `Unicode` 编码转化为 "可变长编码" 的 `UTF-8` 编码，`UTF-8` 编码把一个 `Unicode` 字符根据不同的数字大小编码成 `1 - 6` 个字节，常用的英文字母被编码成 `1` 个字节，汉字通常是 `3` 个字节，只有很生僻的字符才会被编码成 `4 - 6` 个字节

再次强调：**unicode 是一种编码方式，和 ASCII 是同一个概念，而 UTF-8，UTF-16 等是一种存储方式，在存储和传输上节约空间、提高性能的一种编码形式**


#### GBK 和 GB2312

总体说来，`GBK` 包括所有的汉字，包括简体和繁体，而 `GB2312` 则只包括简体汉字

`GBK` 是 `GB2312` 的扩展，除了兼容 `GB2312` 外，它还能显示繁体中文，还有日文的假名


## JavaScript 中的垃圾回收机制

> 《JavaScript 权威指南》

* 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配

* `JavaScript` 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体

* 只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，`JavaScript` 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃

现在各大浏览器通常用采用的垃圾回收有两种方法：**标记清除**、**引用计数**

#### 标记清除

这是 `javascript` 中最常用的垃圾回收方式

当变量进入执行环境是，就标记这个变量为 "进入环境"，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们，当变量离开环境时，则将其标记为 "离开环境"

#### 引用计数

另一种不太常见的垃圾回收策略是引用计数（有时候会造成内存泄漏，一般发生在循环引用）

引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 `1`

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 `1`

当这个引用次数变成 `0` 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来

这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 `0` 的值所占的内存




## GIT 和 SVN 的区别

#### GIT 是分布式的，SVN 不是

`GIT` 跟 `SVN` 一样有自己的集中式版本库或服务器，但 `GIT` 更倾向于被使用于分布式模式，也就是每个开发人员从 中心版本库/服务器 上 `chect out` 代码后会在自己的机器上克隆一个自己的版本库，当遇到没有网络的环境时，仍然能够提交文件，查看历史版本记录，创建项目分支等

#### GIT 把内容按元数据方式存储，而 SVN 是按文件

所有的资源控制系统都是把文件的元信息隐藏在一个类似 `.svn`，`.cvs` 等的文件夹里，`.git` 目录是是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等

#### GIT 分支和 SVN 的分支不同

`SVN` 如果想知道是否合并了一个分支，需要手工运行像这样的命令 `svn propget svn:mergeinfo`，来确认代码是否被合并，所以，经常会发生有些分支被遗漏的情况

`GIT` 的分支可以从同一个工作目录下快速的在几个分支间切换，你很容易发现未被合并的分支，你能简单而快捷的合并这些文件

#### GIT 没有一个全局的版本号，而 SVN 有

`SVN` 的版本号实际是任何一个相应时间的源代码快照

#### GIT 的内容完整性要优于 SVN

`GIT` 的内容存储使用的是 `SHA-1` 哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏



## 函数

```js
// 第一种定义方式
function fn1 () {
  alert('fn1');
}

typeof fn1;  // function
```

在 `JavaScript` 中函数就是对象，只不过 函数是一个非常特殊的对象，是一个 `Function` 类的实例，其实在内存中存储的操作是通过一个键值对来存储的(如下图所示)

函数的名称仅仅是一个键，它的值是指向了内存中的一个对象，这个对象就是 `Function` 的一个对象

![img](函数01.png)

由于函数是一个对象，所以可以通过如下方式定义

以下是通过函数的拷贝来完成赋值的，两个引用并没有指向同一个对象

```js
var fn2 = fn1;

fn2();   // fn1 两个的值是虽然相等，但是指向不同的空间

// fn1 的值改变了以后，不会影响 fn2 的值
fn1 = function(){
  alert('fnn1');
}

fn2();  // 这里修改了 fn1 的内容，fn2 未做修改，故还是 fn1
fn1();  // fnn1
```

![img](函数02.png)

函数虽然是一个对象，但是却和对象有一些区别，对象是通过引用的指向完成对象的赋值的，而函数确实通过对象的拷贝来完成的，所以 `fn1` 虽然改变了，但是并不会影响 `fn2`

对于对象而言，是通过引用的指向来完成赋值的，此时修改 `o1` 或者 `o2` 会将两个值都完成修改

```js
// o1 和 o2 其实指向了同一块空间，当修改 o2 的值的时候，o1 的也会改变
var o1 = new Object();
var o2 = o1;

o2.name = 'abc';
alert(o1.name);  // abc
```

![img](函数03.png)




#### 函数对象

简单来说，对象就是"名/值"对的集合并拥有一个连到原型对象的隐藏连接

对象字面量产生的对象连接到 `Object.prototype`， 函数对象连接到 `Function.prototype`（该原型对象本身连接到 `object.prototype`）

每个函数在创建的时候会有两个附加属性：函数上下文 和 实现函数行为的代码

每个函数对象在创建的时候也会带有一个 `constructor` 属性，它的值是一个拥有 `constructor` 属性且值即为该函数的对象

函数的与众不同之处在于 它们可以被调用


#### 调用

调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数，除了声明的时候定义的形式参数，每个函数接收两个附加的参数：`this` 和 `arguments` ，参数 this 的值取决于调用的模式，在 `JavaScript` 中一共有四种调用模式：

* 方法调用模式

* 函数调用模式

* 构造调用模式

* `apply/call` 调用模式

当实际参数（`arguments`）的个数与形式参数（`parameters`）的个数不匹配的时候不会导致程序错误

如果实际参数过多，超出的参数值将会被忽略

如果实际参数过少，缺失的部分将会被替换为 `undefined`

对参数的值不会进行类型检查，即 任何类型的值都可以被传递给参数



#### 函数重载（没有重载）

```js
function sum (num1, num2) {
  return num1 + num2;
}

function sum (num1) {
  return num1 + 100;
}

sum(10);      // 110
sum(10,20);   // 110
```

换一种写法，可以看的更清楚些

```js
var sum = function (num1, num2) {
  return num1 + num2;
}

var sum = function (num1) {
  return num1 + 100;
}

sum(10);      // 110
sum(10,20);   // 110
```

此时 `sum` 所指向的空间已经从有两个参数的函数变化到只有 `num1` 的函数中

在调用的时候就只会调用 `num1` 的函数


特别指出：函数的参数和调用没用关系，如果函数只有一个参数，但是却传入了两个参数，仅仅只会匹配一个

函数是对象，不存在重载，只会存在覆盖，后面定义的会覆盖前面所定义的

```js
/**
 *  如下定义方式等于定义了一个
 *  function fn (num1, num2) {
 *      alert(num1 + num2);
 *  }
 * 
 *  所以通过以下的例子，充分说明了函数就是一个对象
 */

var fn = new Function('num1', 'num2', 'alert(num1 + num2)');

fn(12, 22);  // 34

sum(10);    // 110
sum(10, 20); // 110
```


#### 函数的值传递

由于函数是对象，所以可以直接把函数通过参数传递进来

```js
function callFun (fun, arg) {
  // 第一个参数就是函数对象
  return fun(arg);
}

function sum (num) {
  return num + 100;
}

function say (str) {
  alert(str);
}

// 调用了 say 函数
callFun(say,'abc');

// 调用了 sum 函数
callFun(sum,20);
```


作为返回值来传递（也就是所谓的闭包）

```js
function fn1 (arg) {
  var rel = function (num) {
    return arg + num;
  }
  return rel;
}

// 此时 f 是一个函数对象，可以完成调用
// 在外部调用的时候，更改函数内部的值

var f = fn1(20);

f(20); //40
f(11); //31
```

#### 来看几个实例

1）

```js
function sortByNum (a, b) {
  return a - b;
}

var arr = [1, 2, 11, 33, 12, 190];

// 对于 JS 而言，默认是按照字符串来进行排序的

arr.sort();           // 1, 11, 12, 190, 2, 33
arr.sort(sortByNum);  // 1, 2, 11, 12, 33, 190
```

2）

```js
function Person (name, age) {
  this.name = name;
  this.age = age;
}

var p1 = new Person('Lily', 30);
var p2 = new Person('Jim', 35);
var p3 = new Person('Aid', 40);

var ps = [p1, p2, p3];

function sortByName (obj1, obj2) {
  if (obj1.name > obj2.name) {
    return 1;
  }
  else if (obj1.name == obj2.name) {
    return 0;
  } else {
    return -1;
  }
}

function sortByAge (obj1, obj2) {
  return obj1.age - obj2.age;
}

ps.sort(sortByName);
ps,sort(sortByAge);
```

使用如上的方式来处理排序，带来的问题是需要为每一个属性都设置一个函数，显得不是很灵活，所以可以通过函数的返回值来调用,实现函数排序功能

```js
function sortByProperty (propertyName) {
  var sortFun = function (obj1, obj2) {
    if(obj1[propertyName] > obj2[propertyName]){
      return 1;
    } else if (obj1[propertyName] == obj2[propertyName]){
      return 0;
    } else {
      return -1;
    }
  }
}

ps.sort(sortByProperty('name'));
ps.sort(sortByProperty('age'));
```

#### 函数中的 arguments

在函数对象中有一个属性叫做 `arguments`，通过这个属性可以获取相应的参数值，之歌属性是一个数组，其实就是传递进来的参数的一个集合

```js
function say (num) {
  alert(num);    // 1
  alert(arguments.length);    // 3
}

say(1, 2, 3);
```

#### arguments.callee()

在 `arguments` 这个对象中有一个 `callee` 的方法，`arguments.callee(arg)` 可以实现反向的调用（不推荐使用）

```js
function factorial (num) {
  if (num <= 1) {
    return 1;
  } else {
    // 此时和函数名耦合在一起
    return num * factorial(num - 1);
  }
}

factorial(5); // 120
```

以上是一个求阶乘的函数，递归调用的函数名称和原有函数名耦合在一起，如果将这个函数名称更改以后，递归就会失效

```js
var fn = factorial;

// 此时不会报错
fn(5);  //120

factorial = null;

fn(5); // 报错
```

此时由于 `fn` 函数依然使用 `factorial` 这个名称来调用，但是 `factorial` 已经指向 `null` 了，所以会报错，如上情况就需要使用 `arguments.callee` 方法来调用（已经不再建议使用）

```js
function factorial (num) {
  if (num <= 1) {
    return 1;
  } else {
    // 以下就实现了函数名的解耦和，在 js 中通常都是使用这种方式来做递归
    return num * arguments.callee(num - 1);
  }
}
fn(5);  //120
```

#### 函数中的 this

当需要创建一个函数对象的时候，设置函数对象的书香和方法需要通过 `this` 关键字来引用

但是特别注意：`this` 关键字在调用的时候会根据不同的调用对象而变得不同

```js
var color = 'red';

function showColor () {
  alert(this.color);
}

function Circle (color) {
  this.color = color;
  this.showColor = showColor;
}

var c = new Circle('yellow');

c.showColor();    // yellow
showColor();      // red
```

使用 `c` 来调用 `showColor` 方法，等于调用了 `showColor` 方法，此时的 `this` 是 `c`，所以是 `yellow`

直接调用 `showColor`，此时调用的对象等于是 `window`，`showColor` 的 `this` 就是 `window`，所以就会在 `window` 中寻找 `color`


#### 返回值

当一个函数被调用的时候，它从第一个语句开始执行，并在遇到关闭函数体的 `}` 时结束，从而是的函数把控制权交还给调用该函数的程序部分

`return` 语句可用来使函数提前返回，当 `return` 被执行的时候，函数立即返回而不再执行余下的语句

一个函数总是有一个返回值，如果没有指定返回值，则返回 `unfefined`

如果函数在前面加上 `new` 前缀的方式来调用，且返回值不是一个对象，则返回 `this`（该新对象）





## JavaScript 对象

`JavaScript` 中的所有事物都是对象：字符串、数值、数组、函数...，对象只是带有属性和方法的特殊数据类型

`typeof` 函数输出的一共有几种类型，在此列出：

```js
function show(x) {
  console.log(typeof (x));    // undefined
  console.log(typeof (10));   // number

  console.log(typeof ("abc"));  // string
  console.log(typeof (true));   // boolean

  console.log(typeof (function () { }));  //function
  console.log(typeof ([1, "a", true]));  //object

  console.log(typeof ({ a: 10, b: 20 }));  //object
  console.log(typeof (null));  //object

  console.log(typeof (new Number(10)));  //object
}

show();
```

其中上面的四种（`undefined`, `number`, `string`, `boolean`）属于简单的值类型，不是对象

剩下的几种情况 -- 函数、数组、对象、`null`、`new Number(10)` 都是对象，他们都是引用类型

判断一个变量是不是对象非常简单，只需要记住：值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`

```js
var fn = function () { };
console.log(fn instanceof Object);  // true
```


#### 创建 JavaScript 对象的几种方式

#### 使用 new object() 来创建对象

在 `js` 中并不存在类，所以可以直接通过 `Objeact` 来创建对象

```js
var person = new object();

person.name = "abc";
person.age = "20";

person.say = function () {
  alert(this.name + "," + this.age);
}
```

使用如上方式创建，带来的最大问题是，由于没有类的约束，无法实现对象的重复利用，并且没有一种约定，在操作的时候可能会带来问题


#### 使用 JSON 来创建对象

`json` 格式就是 `js` 的对象，但是它神略去了 `xml` 中的标签，而是通过 `{ }` 来完成对象的说明

```js
var person = {
  name : "张三",  // 通过 "属性名：属性值" 来表示，不同的属性通过 "," 来间隔，最后一个属性后不能有 ","
  age : 20,
  say : function() {
    alert(this.name + "," + this.age);
  }
}

person.say();
```

通过 `json` 依然可以创建对象数组，创建的方式和 `js` 的数组一样

```js
var ps = [
  {name : "张三", age : 20},
  {name : "李四", age : 30}
];

for (var i = 0; i < ps.length; i++) {
  alert(ps[i]);
}
```


#### 使用工厂模式来创建对象

通过工厂的方式来创建 `person` 对象，在 `createPerson` 中创建一个对象，然后为这个对象设置相应的属性和方法，之后在返回这个对象

```js
function createPerson (name,age) {
  var o = new Object();

  o.name = name;
  o.age = age;

  o.say = function () {
    alert(this.name + "," + this.age);
  }

  return o;
}

var p1 = createPerson("张三", 20);
var p2 = createPerson("李四", 20);

p1.say();
p2.say();
```

使用工厂的方式，虽然有效的解决了类的问题，但是依然存在一个问题，没有办法检测 `p1` 和 `p2` 的数据类型

通过 `typeof` 仅仅只能检测出 `object` 类型，如果希望使用 `instanceof` 来检测的话，无法确定检测的类型

#### 使用构造函数来创建对象

通过构造函数的方式创建，和基于工厂的创建类似，最大的区别就是函数的名称，约定成俗，第一个字母大写，使用构造函数创建的时候，在函数内部是通过 `this` 关键字来完成属性的定义

```js
function Person (name,age) {
  this.name = name;
  this.age = age;
  this.say = function(){
    alert(this.name + "," + this.age);
  }
}

// 通过 new Person 来创建对象
var p1 = new Person("张三",20);
var p2 = new Person("李四",30);

p1.say();
p2.say();

// 使用构造函数的方式可以通过以下的方式来检测对象的类型
alert(p1 instanceof Person);
```

使用构造函数创建所带来的第一个问题就是每一个对象中都会存在一个方法的拷贝，如果对象行为很多的话，空间的占用率会大大的增加

如果在 `Person` 内部来创建方法 `p1.say()` 和 `p2.say()` 是不一样的

解决方法是可以将函数放到全局变量中去定义，这样可以让类中的行为指向同一个函数

```js
function Person (name,age) {
  this.name = name;
  this.age = age;
  this.say = say;
}

function say () {
  alert(this.name + "," + this.age);
}
```

若是将其设置为全局方法，如果将所有的方法都设为全局函数的时候，这个函数就可以被 `window` 调用

此时就破坏了对象的封装性，而且如果某个对象有大量的方法，就会导致代码中充斥着大量的全局函数，而不利于维护



#### 原型的内存

原型是 `js` 中非常特殊的一个对象，当一个函数创建之后，就会随之产生一个原型对象，当通过这个函数的构造函数创建了一个具体的对象之后，在这个具体的对象中就会有一个属性指向原型

```js
// 第一种状态
function Person(){}

//第二种状态
Person.prototype.name = "Leon";
Person.prototype.age = 23;

Person.prototype.say = function () {
  alert(this.name + "," + this.age);
}

// 第三种状态
// 创建了一个对象之后会有一个 _prop_ 的属性指向原型
// 在使用的时候如果在对象内部没有找到属性就会去原型中找，_prop_ 属性是隐藏的
var p1 = new Person();
p1.say();

// 以下方法可以检测出 p1 是否有 _prop_ 指向 Person 的原型
alert( Person.prototype.isPrototypeOf(p1) );


// 第四种状态
var p2 = new Person();
p2.name = "Ada";

p2.say();
p1.say();
```

然后依次图解函数中的四种状态，如下所示

#### 第一种状态

![img](对象01.jpg)

以上是第一种状态：`function Person(){}` 

`Person` 函数中有一个 `prototype` 的属性指向 `Person` 的原型对象，在原型对象中有一个 `constructor` 的属性指向了 `person` 函数，所以可以通过 `new Person()` 创建对象

#### 第二种状态

![img](对象02.jpg)

以上是第二种状态，通过 `Person.prototype.name` 为原型设置值以后，这些属性和方法都是设置在 `Person` 的原型中的

#### 第三种状态

![img](对象03.jpg)

第三种状态是，当使用 `Person` 创建了对象之后，会在对象中有一个 `_prop_` 属性（这个属性是不能被访问的）指向了原型

当使用对象调用原型的时候，首先会在对象的内部找是否有这个属性，如果没有会通过 `_prop_` 去原型中找属性，所以当调用 `p1.say()` 在自己的空间中不存在这个方法，就会去原型中寻找，找到了之后完成 `say` 的调用

#### 第四种状态

![img](对象04.jpg)

第四种状态，当创建了一个新的 `p2` 之后，依然会有一个 `_prop_` 属性指向 `Person` 的原型

此时如果通过 `p2.name` 设置了属性之后，会在对象自己的内存空间中存储 `name` 的值，当调用 `say` 方法的时候，在寻找 `name` 的时候，在自己的空间中找到以后，就不会去原型中查找了。（特别注意：原型中的值不会被替换，仅仅只是在查找的时候会被覆盖）




#### 原型的重写

使用如下方式来编写代码，当属性和方法特别多的时候，编写起来不是很方便，可以通过 `json` 的格式来编写

```js
Person.prototype.name = "Leon";
Person.prototype.age = 23;

Person.prototype.say = function () {
  alert(this.name + "," + this.age);
}
```

以下方式将会重写原型，由于原型重写，而且没有通过 `Person.prototype` 来指定，此时 `constructor` 不会在指向 `Person` 而是指向 `Object`
 
如果 `constructor` 真的比较重要，可以在 `json` 中说明原型的指向

```js
Person.prototype = {
  constructor : Person,  // 手动指定 constructor 
  name : "Leon",
  age : 23,
  say : function () {
    alert(this.name + "," + this.age);
  }
}

var p1 = new Person();
p1.say();
```




#### 测试

```js
function Person () {};
var p1 = new Person();

Person.prototype.sayHi = function () {
  alert(this.name + " :hi");
}

p1.sayHi();

// 注意 是把重写放置在 new Person 之后

Person.prototype = {
  constructor : Person, // 手动指定 constructor 
  name : "Leon",
  age : 23,
  say : function () {
    alert(this.name + "," + this.age);
  }
}

p1.sayHi();  // 不会报错，但是没有 this.name
p2.sayHi()   // 此时 p2 没有 sayHi 所以会报错

p2.say();    // Leon 23
```

运行如下图所示：

![img](对象05.jpg)


#### 基于组合和动态原型创建

为了解决原型所带来的问题，此外需要通过组合构造函数和原型来实现对象的创建，将属性在构造函数中定义，将方法在原型中定义，这种有效集合了两者的优点，是目前最为常用的一种方式

```js
function Person (name, age, friends) {
  // 属性在构造函数中定义
  this.name = name;
  this.age = age;
  this.friends = friends;
}

Person.prototype = {
  constructor : Person,
  // 方法在原型中定义
  say : function () {
    alert(this.name + "[" + this.friends + "]");
  }
}

// 此时所有的属性都是保存在自己的空间中的
var p1 = new Person("Leon', 23, ["Aid", "Cilr"]);
p1.name = "Jim";
p1.friends.push("Milk"); //为 p1 增加一个朋友

p1.say();

var p2 = new Person("Aid", 33, ["Leon"]);

// 此时原型中就多了一个 Milk
p2.say();  // leon adi cilr milk
```

#### 基于原型的一个实例

```js
function obj (name) {
  if (name) {
    this.name = name;
  }
  return this;
}

obj.prototype.name = "name2";

var a = obj("name1");
var b = new obj;

console.log(a.name);  // name1
console.log(window.name);  // name1
console.log(b.name);  // name2
```

一般函数直接调用，默认 `this` 指向全局 `window | global`

通过 `obj("name1")` 调用，返回 `this` 引用，并传递给 `a`，此时 `a` 等于 `window` 对象，即可输出 `name` 值

`new` 操作，`new obj` 等价于 `new obj()` ，实例化一个对象，这时 `this` 指向 `obj`，要拿到 `b.name` 的值，需要保证 `name` 属性存在

属性查找原则是先查找当前实例有没有属性，如果有就直接使用，如果没有，就到原型上去找，在没有就接着原型链一步一步往上

这里为了和 `a.name` 作属性区别，使用了 `if (name)` 有条件的构建 `this` 的属性 `name`

所以，现在 `name` 属性提供给 `a` 使用，原型上的 `name` 提供给 `b` 使用


#### 变体一

```js
// 去掉 if 判断
function obj (name) {
  // if(name){
    this.name = name;
  // }
  return this;
}

obj.prototype.name = "name2";

var a = obj("name1");
var b = new obj;

console.log(a.name);  // name1
console.log(window.name);  // name1

// 这时，b 实例已经有属性 name，但是参数 name 为 undefined，所以这时可以把 this.name 属性删掉，这样就能去原型找 name 了
function obj (name) {
  // if (name) {
    this.name = name;
  // }
  return this;
}

obj.prototype.name = "name2";

var a = obj("name1");
var b = new obj;

console.log(a.name);  // name1
console.log(window.name);  // name1

delete b.name;
console.log(b.name);  // name2
```


#### 变体二 new obj("myname") 试试传个参数

```js
function obj (name) {
  // if (name) {
    this.name = name;
  // }
  return this;
}

obj.prototype.name = "name2";
var a = obj("name1");

var b = new obj("myname");

console.log(a.name);  // name1
console.log(window.name);  // name1
console.log(b.name);  // myname
```


#### 其中的 this 指向问题

```js
/* new Constructor*/
function new (f) {
  var n = {"__prop__": f.prototype;  /* step1 */ }
  return function(){
    f.apply(n, arguments);  /* step2 */
    return n;  /* step3 */
  };
}
```

笼统的说，都是指向了构造函数，但实际上是指向了实例化的对象

其实 `new` 一个构造函数的过程是：先创建一个空对象，然后该对象自然有了 `this`，然后产生一个继承的过程（为该函数添加一个 `__peoto__` 属性，指向构造函数的原型）

这样一来，自然而然空对象就具有了构造函数的所有属性，最后在通过 `apply` 之类的方式调用构造函数，把环境指向原先的空对象，达到模拟调用构造函数产生一个新对象的目的




#### 扩展已经存在的对象的原型

#### 为数组添加去除重复项的方法

```js
// 方法一	 	 
Array.prototype.cx = function () {
  var arr = [];
  for (var i = 0; i &amp; lt; this.length;i++){
    if (arr.indexOf(this[i]) == -1) {
      arr.push(this[i]);
    }
  }
  return arr;
}

// 方法二	 	 
Array.prototype.cx2 = function () {
  this.sort();
  var arr = [this[0]];
  for (var i = 1; i &amp; lt; this.length ;i++ ){
    if (this[i] !== arr[arr.length - 1]) {
      arr.push(this[i]);
    }
  }
  return arr;
}	
```	
 	 
#### 去掉字符串两边的空格

```js
// 为 String 扩展一个 trim 的方法，去除两边的空格
String.prototype.trim = function(){
  return this.replace(/(^\s+)|(\s+$)/g,'');
}
```	

####  几种面向对象的书写方式 

#### 第一类

```js
(function () {
  function Circle (nRadius) {
    this.nR = nRadius;
  }

  Circle.prototype = {
    PI: 3.14,
    fnGetArea: function () {
      return this.PI * this.nR * this.nR;
    }
  }

  var c1 = new Circle(5);
  alert(c1.fnGetArea()); // 78.5
})();
```

上面这种可以说是很标准的面向对象 `JS` 书写方式了我们又称之为工厂模式，优点就是简单容易上手，以上代码略微改动，会有如下这个变种：

```js
(function () {
  function Circle (nRadius, sMessage) {
    this.init.apply(this, arguments);
  }

  Circle.prototype = {
    init: function (nRadius, sMessage) {
      this.nR = nRadius;
      this.sMessage = sMessage;
    },
    PI: 3.14,
    fnGetArea: function () {
      return this.sMessage + ": " + this.PI * this.nR * this.nR;
    }
  }

  var c = new Circle(5, "构造初始化 面积");
  alert(c.fnGetArea()); // 构造初始化 面积: 78.5
})();
```

上面这个变种，就比较有意思了，`this.init.apply(this, arguments);` 这行代码把初始化的任务交接给了 `init()` 方法，这么做的好处就是可以把所有初始化的东西都放在一个地方进行，增加可阅读性


#### 第二类

```js
(function () {
  function Circle () {
  }

  Circle.prototype = {
    init: function (nRadius, sMessage) {
      this.nR = nRadius;
      this.sMessage = sMessage;
    },
    PI: 3.14,
    fnGetArea: function () {
      return this.sMessage + ": " + this.PI * this.nR * this.nR;
    }
  }

  var c = new Circle();
  c.init(5, "手动构造初始化 面积");

  alert(c.fnGetArea()); // 手动构造初始化 面积: 78.5
})();
```

这类写法从书写角度来看省去了构造函数初始化属性，改用其 `init()` 中初始化

另一个好处在于不在 `new Circle()` 构造之初传入参数，个人认为当 `new` 构造对象的时候，最好不要掺杂参数，这样做很危险

改为手动型初始化更易于代码排查修改，当然这种写法还有一个原因就是他可以很好的转换成一般前端接受的封装型代码，我们把上面的代码也略微改动一下：

```js
(function () {
  var Circle = {
    init: function (nRadius, sMessage) {
      this.nR = nRadius;
      this.sMessage = sMessage;
    },
    PI: 3.14,
    fnGetArea: function () {
      return this.sMessage + ": " + this.PI * this.nR * this.nR;
    }
  }

  Circle.init(5, "封装型 面积");
  alert(Circle.fnGetArea()); // 封装型 面积: 78.5
})();
```

上面这类代码优点是代码的封装性良好，可以有效的重用，多用于页面功能性效果实现，封装一个 `Tab` 控件、封装一个跑马灯效果等等

缺点就是不能很好的用作继承，这是和上面三种格式最大区别。可话又说回来一般 `JS` 代码很少会用到继承的地方，除非是写一个大型库（类似 `YUI`）会用到继承外，一般写一个功能模块用到封装型代码就够用了

上面介绍了 2 类 4 种面向对象的写法，一般面向对象书写格式基本都在上面了，熟悉面向对象书写可以有效的增加你对 `JS` 的理解

熟练使用上面4中写法也能够很好的在工作中给代码维护修改带来便利。最后我们再来谈一个技巧，让你的 `Javascript` 代码在技巧上进化

#### 用对象字面量构造对象

一个对象字面量就是包含在一对花括号中的 `0` 个或多个 `名/值` 对。上文在面向对象书写格式的时候我们就大量的使用了对象字面量的书写格式

对象字面量书写 `Javascript` 可以很好的简化代码，又能极大的增加代码可读性，尤其作为参数使用可以有化腐朽为神奇的表现。我们看下面代码

```js
(function () {
  function Person (sName, nAge, nWeight, bSingle) {
    this.sName = sName;
    this.nAge = nAge;
    this.nWeight = nWeight;
    this.bSingle = bSingle;
  }

  Person.prototype.showInfo = function () {
    return this.sName + " " + this.nAge + " " + this.nWeight + " " + this.bSingle;
  }

  var p = new Person("张三", 25, 75, true);
  alert(p.showInfo());  // 张三 25 75 true
})();
```

上面是一个很标准的工厂模式，一般而言这类写法属于那种规规矩矩没有大错也没有亮点的代码，而且参数不少，一个不小心还会传入错误的参数，而应用对象字面量技巧可以很好的规避此类问题，我们来看改动过后的代码：

```js
(function () {
  function Person() {} 

  Person.prototype = {
    init: function (option) {
      if (typeof option == "undefined") {
          option = {};
      }
      this.sName = option.sName || "张三";
      this.nAge = option.nAge || 25;
      this.nWeight = option.nWeight || 75;
      this.bSingle = (typeof option.bSingle != "undefined") ? option.bSingle : true;
    },
    showInfo: function () {
      return this.sName + " " + this.nAge + " " + this.nWeight + " " + this.bSingle;
    }
  }

  var p = new Person();
  p.init({
    nWeight: 80,
    sName: "李四"
  })
  alert(p.showInfo()); // 李四 25 80 true
})();
```

这里使用第三种面向对象写法，传入参数改成了一个对象字面量，而且传入参数可以是随意设置，位置颠倒也不会有任何问题

这里充分利用对象字面量优点，利用键值对代替原始的传参方式大大提升了可读性和容错性

还有一个改进就是默认值的处理，如果没有传入任何参数，此代码也能很好的运行下去，不会有任何问题

参考：

[JavaScript 面向对象](http://www.cnblogs.com/dolphinX/p/4385862.html)

[全面理解面向对象的 JavaScript](http://blog.jobbole.com/38614/)




## 继承

在那些基于类的语言（比如 `Java`）中，继承（`inheritance/extends`）提供了两个有用的服务，如果一个新的类与一个已存在的类大部分相似，那么你只需说明其不同点即可

`JavaScript` 是一门弱类型语言，从不需要类型转换，它可以模拟那些基于类的模式，同时它也支持其他更具表现力的模式

在基于类的语言中，对象是类的实例，并且类可以用另一个类继承，`JavaScript` 是一门基于原型的语言，这意味着对象直接从其他对象继承

#### 1、基于原型的继承

先看一个实例

```js
function Foo () {
  this.y = 2;
}

typeof Foo.prototype; // Object

Foo.prototype.x = 1;
var obj3 = new Foo();

obj3.x; // 1
obj3.y; // 2
```

用函数声名的方式声明函数 `Foo` 的时候，就会有一个内置的属性，并且这个属性是一个对象，而且是预设的

然后给这个对象属性增加一个 `x`，赋值为 `1`，然后用 `new Foo()`来创建一个 `Foo` 的实例

当使用 `new` 去使用的时候，函数会做为一个构造器来使用，这时候 `this` 会指向一个对象，而这个对象的原型会指向构造器的 `prototype` 属性

所以，`y` 是这个对象上的，故为 `2`，而 `x` 是原型链上的，也就是 `Foo.prototype` 上的，为 `1`


#### 2、prototype 的属性与原型

用函数声名的方式声明函数 `Foo` 的时候，函数就会有一个 `prototype` 属性

```js
Foo.prototype
{
  constructor : Foo,
  _proto_ : Object.prototype,
  x : 1
}
```

当一个函数对象被创建的时候，`Function` 构造器产生的函数对象会运行类似这样的一些代码：

```js
this.prototype = {constructor: this};
```

新的函数对象被赋予一个 `prototype` 属性，它的值是包含了一个 `constructor` 属性且属性值为该新函数对象，该 `prototype` 对象是存放继承特征的地方。因为 `JavaScript` 语言没有提供一种方法去确定哪个函数是打算用来作构造器的，所以每个函数都会得到一个 `prototype` 对象

当采用构造器调用模式，即使用 `new` 前缀去调用一个函数的时候，这将会修改函数执行的方式，如果 `new` 运算符是一个方法而不是一个运算符，它可能会像这样执行：

```js

Function.prototype.method = function (name, func) {
	this.prototype[name] = func;
	return this;
}

Function.method("new", function () {
	// 创建一个新对象，它继承自构造器函数的原型对象
	var that = Object.beget(this.prototype)
	// 调用构造函数，绑定 this 到新的对象上
	var other = this.apply(that, arguments);
	// 如果它的返回值不是一个对象，就返回该新对象
	return (typeof other === "object" && other) || that;
});
```

我们可以定义一个构造器并扩充它的原型：

```js
var Mammal = function (name) {
	this.name = name;
};

Mammal.prototype.getName = function () {
	return this.name;
};

Mammal.prototype.says = function () {
	return this.saying || "" ;
};
```

现在，我们可以构造一个实例：

```js
var myMammal = new Mammal("The Mammal");
var name = myMammal.getName();  // "The Mammal"
```

我们可以构造另一个伪类来继承 `Mammal`，这是通过定义它的 `constructor` 函数并替换它的 `prototype` 为一个 `Mammal` 的实例来实现的：

```js
var Cat = function (name) {
	this.name = name;
	this.saying = "meow";
}

// 替换 Cat.prototype 为一个新的 Mammal 实例
Cat.prototype = new Mammal();

// 扩充原型对象，增加 purr 和 getName 方法
Cat.prototype.purr = function (n) {
	var i, s = "";
	for (i = 0; i < n; i++) {
		if (s) {
			s += "-";
		}
		s += "r";
	}
	return s;
};

Cat.prototype.getName = function () {
	return this.says() + " " + this.name + " " + this.says();
};

var myCat = new Cat("Henrietta");
var says = myCat.says();	  // "meow"

var purr = myCat.purr(5);	  // "r-r-r-r-r"
var name = myCat.getName();	// "meow Henrietta meow"

```

伪类模式本意是想向面向对象靠拢，但是它看起来格格不入。下面的代码是通过 `method` 方法定义的一个 `inherits` 方法来实现的：

```js
Function.method("inherits", function (Parent) {
	this.prototype = new Parent();
	return this;
})
```

`inherits` 和 `method` 方法都返回 `this`，这将允许我们可以以级联的样式编程：

```js
var Cat = function (name) {
	this.name = name;
	this.saying = "meow";
}
  .inherits(Mammal)
  .method("puur", function (n) {
		var i, s = "";
		for (i = 0; i < n; i++) {
			if (s) {
				s += "-";
			} 
			s += "r";
		}
		return s;
	})
  .method("getName", function () {
		return this.says() + " " + this.name + " " + this.says();
	})
```

虽然如此，但是我们并没有有所改善，虽然现在有了行为像"类"的构造器函数，但是它们并没有私有环境，所有属性都是公开的，无法访问 `super`（父类）的方法

更为糟糕的是，如果在调用构造器的时候忘记了在前面加上 `new`，那么 `this` 将不会绑定到一个新对象上，而是会绑定那个到全局对象上，这样的形式可以带来便利，但是它也隐藏了该语言的真正本质，`JavaScript` 中有更多且更好的选择

#### 3、一个简单的实现继承方式

```js
// Person 类
function Person (name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.hi = function () {
  console.log(this.name + this.age);
}

Person.prototype.LEGS_NUM = 2;
Person.prototype.ARMS_NUM = 2;

Person.prototype.walk = function () {
  console.log('walk');
}

// Student 类
function Student (age, name, className) {
  Person.call(this, age, name);
  this.className = className;
}

// 使用 Object.create 来得到以 Person.prototype 做为原型的一个空对象
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
```




#### 4、添加自己新的方法来覆盖 Person 上的方法

```js
Student.prototype.hi = function () {
  console.log(this.name + this.age + this.className);
}

// 添加自己新的方法
Student.prototype.learn = function (subject) {
  console.log(this.name + subject + this.className);
}

// test
var man = new Student('name',20,'Class 3 , Grade 2');

man.hi();         // name 20 Class 3 , Grade 2
man.LEGS_NUM;     // 2

man.walk();       // walk
man.learn('math') // man math Class 3 , Grade 2
```


#### 5、原型链原理图


![img](继承.png)



#### 6、改变 prototype

```js
Student.prototype.x = 101;
man.x; // 101
// 修改的 man 的原型的指向对象

Student.prototype = {y: 2};

// 当我们去修改 Student.prototype 的值的时候，不能修改已经实例化的一些对象，已经实例化的对象
// 是指向当时的 Student.prototype，不会影响已经创建的实例
man.y; // undefined
man.x; // 101

var abc = new Student('aaa',3,'bbb');

abc.x; // undefined
abc.y; // 2
```

所以，当我们动态的修改 `prototype` 属性的时候，是会影响所有已经创建和新创建的实例的

但是如果修改整个 `prototype` 赋值为新的对象的话，新的实例是不会修改的，但是会影响后续的实例


#### 7、比较以下实现继承的几种方式

```js
function Person () {}

function Student () {}

Student.prototype = Person.prototype; 
// 1  在改变 Student 的同时，也改变了 Person，不推荐

Student.prototype = new Person(); 
// 2 也可以实现继承，但是 Student 只是一个类，还没有实例化，只是为了继承，而调用构造函数

Student.prototype = Object.create(Person.prototype);
// 3 相对来说比较妥当的，自己的修改不会影响到原型链，ES5 之后才实现

// ES5之前的话，可以判断一下
if (!Object.create) {
  Object.create = function (proto) {
    function F() {}
    F.prototype = proto;
    return new F;
  };
}
```


#### 8、调用子类方法

```js
function Person (name) {
  this.name = name;
}

function Student (name, className) {
  this.className = className;
  Person.call(this, name);    
}

// test
var man = new Student('man','abc');
man; // Student{className: 'abc', name: 'man'}

// 若子类的方法覆盖了基类的方法
Person.prototype.init = function () {};

Student.prototype.init = function () {
  // do something...
  Person.prototype.init.apply(this, arguments);
}
```




## JavaScript 中的命名空间，变量声明提升，作用域和预编译

#### 命名空间

`JavaScript` 中没有命名空间这个概念的，只能模拟实现，命名空间的使用可以显著减少命名冲突，并很好的组织代码，如下一个简单的示例

```js
var namespace = namespace || {};

namespace.AModule = {};
namespace.AModule.name = 'abc';
namespace.BModule = {};
```


#### 变量声明提升

声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已

定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义

```js
var a;      // 这是声明
a = 1;      // 这是定义（赋值）
var a = 1;  // 合二为一：声明变量的存在并赋值给它
```

当你以为你只做了一件事情的时候（`var a = 1`），实际上解释器把这件事情分解成了两个步骤

一个是声明（`var a`），另一个是定义（`a = 1`）

#### 两个示例

```js
var a = 1;
 
function foo () {
  if (!a) {
    var a = 2;
  }
  alert(a);
};
 
foo();  // 输出 2
```

简单的调整一下

```js
var a;
a = 1;
 
function foo() {
  var a;  // 关键在这里
  if (!a) {
    a = 2;
  }
  alert(a);  // 此时的 a 并非函数体外的那个全局变量
}

foo()
```

如代码所示，在进入函数体后解释器声明了新的变量 `a`，而无论 `if` 语句的条件如何，都将为新的变量 `a` 赋值为 `2`



#### 作用域

`JavaScript` 在 `ES6` 之前是没有块级作用域的（`Block Scoping`），只有函数作用域（`Function Scoping`）

当解析器读到 `if` 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 `Hoisting`

> `JavaScript` 只有函数作用域！

若是想要 `alert(a)` 弹出那个 `1` 则可以创建有一个新的作用域，可以使用立即执行函数

```js
var a = 1;
 
function foo() {
  // 这个就是 IIFE，它会创建一个新的函数作用域
  // 并且该作用域在 foo() 的内部，所以 alert 访问不到
  // 不过这个作用域可以访问上层作用域，这就叫：闭包
  if (!a) {
    (function() {  
      var a = 2; 
    }());               
  };
  alert(a);
};
 
foo();
```

> '请始终保持作用域内所有变量的声明放置在作用域的顶部' 不是没有道理的

因为这样可以避免 `Hoisting` 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问

但是，变量声明的提升并非 `Hoisting` 的全部

在 `JavaScript` 中，有四种方式可以让命名进入到作用域中（按优先级）

* 语言定义的命名：比如 `this` 或者 `arguments`，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 `this` 之类的，这样是没有意义的

* 形式参数：函数定义时声明的形式参数会作为变量被 `hoisting` 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

* 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

* 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的




#### 预编译

`JavaScript` 引擎并不是读一句执行一句，而是读取一段、解释执行一段，而一段一段执行，`JavaScript` 会对读取的这段 `JavaScript` 代码整体有个预处理，这个预处理就是所谓的预编译

预编译阶段，`JavaScript` 引擎会进行变量提升，这里就会涉及到变量对象

`JavaScript` 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（`Variable Object`，缩写为 `VO`）是一个抽象概念中的"对象"，它用于存储执行上下文中

1. 变量

2. 函数声明

3. 函数参数

`VO` 按照如下顺序填充：

1. 函数参数（若为传入，初始化该参数值为 `undefined`）

2. 函数声明（若发生命名冲突，会覆盖）

3. 变量声明（初始化变量值为 `undefined`，若发生命名冲突，会忽略）


看以下几个实例

```js
function foo (x, y, z) {
  function x () {};
  alert(x);   // function x () {}
}

 
foo(100);
```

在初始化阶段，先初始化函数的参数，参数 `x` 即为传进来的参数，为 `100`，但是在处理函数声明的时候，发生冲突，`x` 会被覆盖，所以返回的是一个函数对象

```js
// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略
function foo (x, y, z) {
  function fn () {};
  var fn;
  console.log(fn);    // function fn () {}
}
 
foo(100);
 
// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作
function foo (x, y, z) {
  function fn () {};
  var fn = 1;
  console.log(fn);    // 1
}
 
foo(100);
 
// 在看一个容易出错的，最终会输出 100 和 0
var num = 0;
 
function a (num) {
  num = 100;
  console.log(num);
}
 
a();
console.log(num);
```

函数表达式不会影响 `VO`，比如 `var a = function foo(){}`

这里的 `foo` 是函数表达式的名称，这个是不会记录到 `AO` 中的，这也是为什么我们不能在外部通过 `foo` 来获取到这个函数对象

## JSON.parse() && JSON.stringify()

#### JSON.parse()

`JSON.parse()` 用来解析 `JSON` 字符串，构造由字符串描述的 ``JavaScript`` 值或对象，提供可选的 `reviver` 函数用以在返回之前对所得到的对象执行变换

```js
var json = '{"result":true, "count":42}';
JSON.parse(json);  // { result: true, count: 42 }
```

语法如下


```js
JSON.parse(text[, reviver])
```

如果被解析的 `JSON` 字符串是非法的（`text`），则会抛出一个语法错误异常

如果指定了 `reviver` 函数，则解析出的 ``JavaScript`` 值（解析值）会经过一次转换后才将被最终返回（返回值）

意思就是，解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 `reviver` 函数

在调用过程中，当前属性所属的对象会作为 `this` 值，当前属性名和属性值会分别作为第一个和第二个参数传入 `reviver` 中

如果 `reviver` 返回 `undefined`，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值


> 当遍历到最顶层的值（解析值）时，传入 `reviver` 函数的参数会是空字符串 `""`（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了）
> 
> 当前的 `this` 值会是 `{"": 修改过的解析值}`，在编写 `reviver` 函数时，要注意到这个特例（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历）


下面是两个示例

```js
// 如果到了最顶层，则直接返回属性值
// 否则将属性值变为原来的 2 倍
JSON.parse('{"p": 5}', function (k, v) {
  if(k === '') return v;     
  return v * 2;              
});        

// { p: 10 }


JSON.parse(' {"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}} ', function (k, v) {
  // 输出当前的属性名，从而得知遍历顺序是从内向外的
  console.log(k); ，

  // 最后一个属性名会是个空字符串
  // 返回原始属性值，相当于没有传递 reviver 参数
  return v;       
});

// 1
// 2
// 4
// 6
// 5
// 3 
// ""
```



#### JSON.stringify()

方法是将一个 ``JavaScript`` 值（对象或者数组）转换为一个 `JSON` 字符串，如果指定了 `replacer` 是一个函数，则可以替换值，或者如果指定了 `replacer` 是一个数组，可选的仅包括指定的属性

语法如下

```js
JSON.stringify(value[, replacer [, space]])
```

#### 关于可选参数 replacer

* 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理

* 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 `JSON` 字符串中

* 如果该参数为 `null` 或者未提供，则对象所有的属性都会被序列化


#### 关于可选参数 space

* 指定缩进用的空白字符串，用于美化输出（`pretty-print`）

* 如果参数是个数字，它代表有多少的空格（上限为 `10`），该值若小于 `1`，则意味着没有空格

* 如果该参数为字符串（字符串的前十个字母），该字符串将被作为空格

* 如果该参数没有提供（或者为 `null`）将没有空格


#### 关于序列化，有下面五点注意事项

* 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中

* 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值

* `undefined`、任意的函数以及 `symbol` 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 `null`

* 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误

* 所有以 `symbol` 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们

* 不可枚举的属性会被忽略


```js
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1, "false", false]'
JSON.stringify({ x: 5 });                  // '{"x": 5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x": 5, "y": 6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1, "false", false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null, null, null]' 

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify(
  { [Symbol.for("foo")]: "foo" },
  function (k, v) {
    if (typeof k === "symbol") {
      return "a symbol";
    }
  }
);
// undefined 

JSON.stringify(
  Object.create(
    null,
    {
      x: { value: 'x', enumerable: false },
      y: { value: 'y', enumerable: true }
    }
  )
);
// 不可枚举的属性默认会被忽略
// "{"y":"y"}"
```



#### replacer 参数

`replacer` 参数可以是一个函数或者一个数组，作为函数，它有两个参数，键值都会被序列化

* 如果返回一个 `Number`, 转换成相应的字符串被添加入 `JSON` 字符串

* 如果返回一个 `String`, 该字符串作为属性值被添加入 `JSON`

* 如果返回一个 `Boolean`, `"true"` 或者 `"false"` 被作为属性值被添加入 `JSON` 字符串

* 如果返回任何其他对象，该对象递归地序列化成 `JSON` 字符串，对每个属性调用 `replacer` 方法（除非该对象是一个函数，这种情况将不会被序列化成 `JSON` 字符串）

* 如果返回 `undefined`，该属性值不会在 `JSON` 字符串中输出

> 需要注意的是，不能用 `replacer` 方法，从数组中移除值（`values`），如若返回 `undefined` 或者一个函数，将会被 `null` 取代

```js
var foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 };
var jsonString = JSON.stringify(foo, (key, value) => {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
});

console.log(jsonString);  // {"week": 45, "month": 7}
```

如果 `replacer` 是一个数组，数组的值代表将被序列化成 `JSON` 字符串的属性名（即只有包含在这个数组中的属性名才会被序列化）

```js
var foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 };
console.log(JSON.stringify(foo, ['week', 'month']));  //  只保留 week 和 month 属性值
```


#### 关于 toJSON 方法

需要注意的是，如果一个被序列化的对象拥有 `toJSON` 方法，那么该 `toJSON` 方法就会覆盖该对象默认的序列化行为（即为调用 `toJSON` 方法后的返回值会被序列化）

```js
var obj = {
  foo: 'foo',
  toJSON: function () {
    return 'bar';
  }
};

JSON.stringify(obj);         // '"bar"'
JSON.stringify({ x: obj });  // '{"x":"bar"}'
```


#### 使用 JSON.stringify 来格式化对象

在平常的开发过程中，经常会遇到一些十分复杂的对象，往往是对象当中嵌套对象，看上去十分的不直观

我们可以利用 `replacer` 和 `space` 参数来对其进行格式化

```js
// 因为函数如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，所以需要特殊处理
var foo = function (key, value) {
  if (typeof (value) === 'function' || typeof(value) === 'symbol') {
    return value.toString()
  } else if (typeof (value) === 'undefined') {
    return 'undefined'
  } else {
    return value;
  }
}

var json = { bar: 'aaa', foo: { age: Symbol('23') }, baz: undefined, o: { name: 'zhangsan', userInfo: { sex: 0, getSex: function () { return this.sex; }, address: null } } };
JSON.stringify(json, foo, 2);

// {
//   "bar": "aaa",
//   "foo": {
//     "age": "Symbol(23)"
//   },
//   "baz": "undefined",
//   "o": {
//     "name": "zhangsan",
//     "userInfo": {
//       "sex": 0,
//       "getSex": "function () { return this.sex; }",
//       "address": null
//     }
//   }
// }
```






## clientWidth, offsetWidth, scrollWidth

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变
 
document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变
 
document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大
 
----
 
document.body.scrollTop        // 页面滚动条向下拉动的距离
 
document.body.scrollLeft       // 页面滚动条向左拉动的距离
 
obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变
 
obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同
 
----
 
// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度
 
window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）
```

两个兼容函数

```js
// 返回视口的大小，部分移动设备浏览器对 innerWidth 的兼容性不好
// 需要使用 document.documentElement.clientWidth 或者 document.body.clientWidth 来兼容（混杂模式下对 document.documentElement.clientWidth 不支持）
// 使用方法 getViewPort().width
function getViewPort () {
  // 浏览器嗅探，混杂模式
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.clientWidth,
      height: document.body.clientHeight
    };
  } else {
    return {
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    };
  }
}


// 获得文档的大小（区别与视口），与上面类似
function getDocumentPort () {
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.scrollWidth,
      height: document.body.scrollHeight
    };
  } else {
    return {
      width: Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth),
      height: Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight)
    }
  }
}
```


## call，apply，bind 的定义与实现

`bind` 方法的定义见 [ECMAScript5.1 - bind](http://yanhaijing.com/es5/#324)

使用方式如下

```js
fun.bind(thisArg[, arg1[, arg2[, ...]]])
```

`bind()` 方法会创建一个新函数，当这个新函数被调用时，它的 `this` 值是传递给 `bind()` 的第一个参数, 它的参数是 `bind()` 的其他参数和其原本的参数

`bind` 返回的绑定函数也能使用 `new` 操作符创建对象（这种行为就像把原函数当成构造器），提供的 `this` 值被忽略，同时调用时的参数被提供给模拟函数

`bind` 方法与 `call`、`apply` 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数

> 还可以写成 `fn.bind(obj, arg1)(arg2)`

一句话概括就是

该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 `bind` 方法的第一个参数作为 `this`，传入 `bind` 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数


#### 实现

初级实现

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  // 记住 this，就是需要绑定 this 的实例函数（原函数）
  var _this = this;
  var argsArray = Array.prototype.slice.call(arguments);
  return function () {
    // 剔除第一个参数，其余作为参数来传递（提供给原函数）
    return _this.apply(context, argsArray.slice(1));
  }
}
```

这里存在一些问题，在于在预置参数功能丢失的现象（因为使用了 `argsArray.slice(1)`），比较好的解决方式是下面这种

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  var _this = this;
  var args = Array.prototype.slice.call(this.arguments, 1);
  return function () {
    return _this.apply(context, args.concat(Array.prototype.slice.call(arguments)))
  }
}
```

但是 `bind` 当中还有一点比较特殊

`bind` 返回的函数如果作为构造函数，搭配 `new` 关键字出现的话，我们的绑定 `this` 就需要"被忽略"

这样一来就需要在构造函数的场景下来进行兼容

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var F = function () { };
  F.prototype = this.prototype;
  var bound = function () {
    return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments)));
  }
  bound.prototype = new F();
  return bound;
}
```

如果比较严谨的话，还需要判断调用 `bind` 方法的一定要为一个函数，否则就抛出一个错误

```js
if (typeof this !== 'function') {
  throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)
}
```


#### 扩展，要求不使用 call 和 apply

简单来说，就是手动实现一个 `call` 和 `apply` 即可

`call` 和 `apply` 本质是一样的，区别就在于参数的不同

`call` 方法的定义 [call](http://yanhaijing.com/es5/#323)

简单来说就是

* `call()` 方法在使用一个指定的 `this` 值和若干个指定的参数值的前提下调用某个函数或方法

* `apply()` 方法在使用一个指定的 `this` 值和参数值必须是数组类型的前提下调用某个函数或方法


#### 原理

`call()` 和 `apply()` 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 `this` 来获得它的引用，比如以对象 `o` 的方法来调用函数 `f()`

```js
f.call(o)

f.apply(o)
```

大致原理如下所示

```js
o.m = f;    // 将 f 存储为 o 的临时方法
o.m();      // 调用它，不传入参数

delete o.m; // 将临时方法删除
```

在严格模式中，`call()` 和 `apply()` 的第一个参数都会变成 `this` 的值，哪怕传入的实参是原始值甚至是 `null` 或 `undefined`

在 `ES3` 或者非严格模式中，传入的 `null` 和 `undefined` 都会被全局对象代替，而其他原始值则会被相应的包装对象（`wrapper object`）所替代

简单来说就是，`f.call(o)` 其原理就是先通过 `o.m = f` 将 `f` 作为 `o` 的某个临时属性 `m` 存储，然后执行 `m`，执行完毕后将 `m` 属性删除



#### 实现

这里以 `apply` 为例

初级实现

```js
Function.prototype.apply = function (context) {
  context.fn = this;
  context.fn();
  delete context.fn;
}
```

但是 `apply` 有一点不同，它的参数是一个数组，在执行的时候会把数组的值依次传递给函数当参数

需要实现类似 `context.fn(arg1, arg2, arg3 ...)` 的调用方式，这里采用 `evel` 来实现

```js
Function.prototype.apply = function (context) {
  var args = arguments[1];
  context.fn = this;

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1,arg2,arg3...)
  var fnStr = 'context.fn(';
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
  }
  fnStr += ')';
  eval(fnStr);

  delete context.fn;
}
```

有几个需要注意的地方

`this` 参数可以传递 `null` 或者不传，当为 `null` 的时候，则指向 `window`

函数是可以指定返回值的

```js
Function.prototype.apply = function (context) {
  var context = context || window;
  var args = arguments[1];
  context.fn = this;

  if (args === void 0) {
    return context.fn();
  }

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1, arg2, arg3 ...)
  var fnStr = 'context.fn(';
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
  }
  fnStr += ')';
  var returnVal = eval(fnStr);

  delete context.fn;
  return returnVal;
}
```

还有一个问题，即 `context.fn = this`，这里我们只是假设不存在名为 `fn` 的属性，所以这里我们需要保证 `fn` 的唯一性

这里可以采用 `ES6` 提供的 `symbol` 数据类型，直接添加即可

```js
var fn = Symbol()
context[fn] = this
```

如果不使用 `symbol`，也可以来手动模拟一个，简单来说就是随机定义一个属性名称，然后在进行赋值的时候判断一下

```js
function symbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    // 如果已经存在这个属性，则递归调用，直到没有这个属性
    arguments.callee(obj)
  } else {
    return unique_proper;
  }
}

// 使用
var fn = symbol(context);
```

而 `call` 方法，可以利用上面的 `apply` 来简单实现

```js
Function.prototype.call = function (context) {
  return this.apply(([].shift.apply(arguments), arguments));
}
```



#### 汇总

```js
function symbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    // 如果已经存在这个属性，则递归调用，直到没有这个属性
    arguments.callee(obj);
  } else {
    return unique_proper;
  }
}

Function.prototype.apply = function (context) {

  var context = context || window;

  // 获取传入的数组参数
  var args = arguments[1];
  var fn = symbol(context);

  // 保证 fn 的唯一性
  context[fn] = this

  // 如果没有传入参数则直接执行
  if (args == void 0) {
    return context[fn]()
  }

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1, arg2, arg3 ...)
  var fnStr = 'context[fn]('
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ','
  }
  fnStr += ')'

  // 使用 evel 执行，完成后删除这个属性
  var returnValue = eval(fnStr)
  delete context[fn]

  return returnValue
}

Function.prototype.call = function (context) {
  return this.apply(([].shift.apply(arguments)), arguments)
}

Function.prototype.bind = Function.prototype.bind || function (context) {

  // 判断调用对象是否是函数
  if (typeof this !== 'function') {
    throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)
  }

  // 记住 this，就是需要绑定 this 的实例函数（原函数）
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);

  // 在构造函数的场景下来进行兼容（因为在搭配 new 使用的时候，绑定的 this 需要被忽略）
  var F = function () { };
  F.prototype = this.prototype;

  var bound = function () {
    return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments)));
  }

  bound.prototype = new F();
  
  return bound;
}
```













#### 数组排序的两种方法

```js
// 二分排序
function oSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  var left = [];
  var right = [];
  var oNum = Math.floor(arr.length / 2);
  var oNumVode = arr.splice(oNum, 1);

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < oNumVode) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return oSort(left).concat(oNumVode, oSort(right));
}


// 冒泡排序
function mp(arr) {
  var temp;
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < arr.length; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j + 1];
        arr[j + 1] = arr[i];
        arr[i] = temp;
      }
    }
  }
  return arr;
}
```

#### 数组去重的两种方法

```js
Array.prototype.uniq1 = function () {
  // 先排序，在比较
  this.sort();
  var arr = [this[0]];
  for (var i = 1; i < this.length; i++) {
    if (this[i] !== arr[arr.length - 1]) {
      arr.push(this[i]);
    }
  }
  return arr;
}


Array.prototype.uniq2 = function () {
  var arr = [];
  for (var i = 0; i < this.length; i++) {
    // 遍历当前数组
    // 检测新数组内是否重复，如果没有出现则为 -1
    // 把 arr 数组的第 i 项插入新数组
    if (arr.indexOf(this[i]) == -1) {
      arr.push(this[i]);
    }
  }
  return arr;
}

var arr = [1, 2, 3, 4, 4, 4, 4, 5, 5, 5, 6]
arr.uniq1()
```



## typeOf，hasOwnProperty，isPrototypeOf，instanceof

#### typeOf

```js
function show(x) {

  console.log(typeof (x));    // undefined
  console.log(typeof (10));   // number
  console.log(typeof ('abc')); // string
  console.log(typeof (true));  // boolean

  console.log(typeof (function () { }));  //function

  console.log(typeof ([1, 'a', true]));  //object
  console.log(typeof ({ a: 10, b: 20 }));  //object
  console.log(typeof (null));  //object
  console.log(typeof (new Number(10)));  //object

}

show();

```

* 对于数字类型的值，`typeof` 会返回 `number`（`NaN` 也是一个数字类型，因为它在 `JavaScript` 中代表的是特殊非数字值）

* 对于字符串类型的值，`typeof` 会返回 `string`

* 对于布尔类型的值，`typeof` 会返回 `boolean`

* 对于对象，数组，`null` 而言，`typeof` 会返回 `object`

* 对于函数类型而言，`typeof` 返回 `function`

* 如果运算数没有定义（不存在或未赋值），将会返回 `undefined`






#### hasOwnProperty

是用来判断一个对象是否有你给出名称的属性或对象（需要注意的是，此方法无法检查该对象的原型链中是否具有该属性）

该属性必须是对象本身的一个成员，在跨浏览器的设计中，我们不能依赖于 `for in` 来获取对象的成员名称，一般使用 `hasOwnProperty` 来判断

```js
var buz = {
  fog: '123'
};

for (var name in buz) {
  if (buz.hasOwnProperty(name)) {
    alert("this is fog (" + name + ") for sure. Value: " + buz[name]);
  }
  else {
    alert(name); // toString or something else
  }
}
```

在 `Object.prototype` 中调用 `hasOwnProperty()`

```js
// 对象
var man = {
  hands: 2,
  legs: 2,
  heads: 1
};

// 将一个方法添加到对象上
if (typeof Object.prototype.clone === "undefined") {
  Object.prototype.clone = function () {
    // ...
  }
}

// 使用 hasOwnProperty()
for (var i in man) {
  if (Object.prototype.hasOwnProperty.call(man, i)) {  // 过滤
    console.log(i, ":", man[i]);
  }
}
```

在使用 `hasOwnProperty()` 对 `man` 对象进行精炼后，可有效的避免命名冲突，也可以使用一个本地变量来缓存比较长的属性名

```js
var i, hasOwn = Object.prototype.hasOwnProperty;

for (var i in man) {
  // 过滤
  if (hasOwn.call(man, i)) {  
    console.log(i, ":", man[i]);
  }
}
```

严格来讲，不使用 `hasOwnProperty()` 并没有错，依赖具体任务和对代码的自信，可以忽略过该方法并略微加快循环的执行速度

但是当确认不了对象的内容（和原型链）的时候，最好还是加上 `hasOwnProperty()` 这样安全的检查






#### isPrototypeOf

是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回 `true`，否则返回 `false`

```js
function Fee() {
  // . . .
}



function Fi() {
  // . . .
}

Fi.prototype = new Fee();



function Fo() {
  // . . .
}

Fo.prototype = new Fi();



function Fum() {
  // . . .
}
Fum.prototype = new Fo();


// ---------------------------


var fum = new Fum();
// ...

if (Fi.prototype.isPrototypeOf(fum)) {
  // do something safe
} 
```







#### instanceof

用来测试一个对象在其原型链构造函数上是否具有 `prototype` 属性，直白的说就是，用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上

```js
// 定义构造函数
function C() { }
function D() { }

var o = new C();

// true，因为 Object.getPrototypeOf(o) === C.prototype
o instanceof C;

// false，因为 D.prototype 不在 o 的原型链上
o instanceof D;

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象，这个空对象不在 o 的原型链上

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true
```

需要注意的是，如果表达式 `obj instanceof Foo` 返回 `true`，则并不意味着该表达式会永远返回 `ture`，因为 `Foo.prototype` 属性的值有可能会改变

改变之后的值很有可能不存在于 `obj` 的原型链上，这时原表达式的值就会成为 `false`

另外一种情况下，原表达式的值也会改变，就是改变对象 `obj` 的原型链的情况，虽然在目前的 `ES` 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 `__proto__` 魔法属性，是可以实现的

比如执行 `obj.__proto__ = {}` 之后，`obj instanceof Foo` 就会返回 `false` 了

更多详细见： [MDN - instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)


所以，在判断一个变量是不是对象的情况下，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`

```js
var fn = function () { };

console.log(fn instanceof Object);  // true
```



## 运算符优先级

```js
var provider = {
  test: {
    $get: function () {
      return function anonymous(config) {
        console.log(this);  // window
      };
    }
  }
};

var type = "test";
var config = {};
new provider[type].$get()(config);
```

这里需要明确两点，一个是构造函数的返回，另一个是 `new` 操作符的执行顺序

#### 构造函数的返回

简单来说

* 如果返回的是一个非引用类型的值时，实际上返回的是仍然是新创建的实例对象

* 如果返回的是一个引用类型的值时，返回的是引用对象本身

比如如下示例

```js
function Person() {}

const person = new Person();
console.log(typeof person);  // object

// ----

function Person() {
  return function() {}
}

const person = new Person();
console.log(typeof person);  // function
```

#### new 操作符的执行顺序

在 `MDN` 的 `new` 操作符描述中，语法是

```js
new constructor[([arguments])]
```

可以发现，参数 `arguments` 是可缺省的，那么就意味着，对于不含参数的构造函数而言，`new Person()` 和 `new Person` 是一样的

那么又会涉及到一个问题，为什么执行的时候是执行的 `new Person()`，而不是 `(new Person)()` 呢，这里就涉及到操作符的执行顺序

这里也只列举几个这里用到的运算符，更多详细的可以参考 [运算符优先级 (JavaScript)](https://msdn.microsoft.com/zh-cn/library/z3ks45k7(v=vs.94).aspx)

|优先级|运算类型|关联性|运算符|
|-|-|-|-|
|20|	圆括号|	n/a|	( … )|
|19|成员访问|	从左到右|	… . …|
||new（带参数列表）|	n/a|	new … ( … )|
|18| 函数调用|	从左到右|	… ( … )|
||new（无参数列表）|	从右到左|	new …|
|...|
|13| 加法|	从左到右|	… + …|
||减法|	从左到右|	… - …|


了解了原理之后，我们可以很轻松的将上面的问题解析为

```js
// 因为带参数列表的 new 优先级高于函数调用，所以不会先执行函数调用
(new provider[type].$get())(config);
```

这里还有一个扩展的小问题，下面的结果是多少

```js
var str = 'Hello' + true ? 'World' : 'JavaScript';
```

结果是 `World`， 因为 `+` 运算符优先级是高于条件运算符的，其实就相当于执行了 `('Hello' + true) ? 'World' : 'JavaScript'`

在来看一个操作符相关的问题

```js
function Foo() {
  getName = function () {
    console.log('1');
  };
  return this;
}
Foo.getName = function () {
  console.log('2');
};
Foo.prototype.getName = function () {
  console.log('3');
};
var getName = function () {
  console.log('4');
};
function getName() {
  console.log(5);
}

// 输出结果依次为多少
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

// 结果为 2 4 1 1 2 3 3
```

一个一个来看，首先我们来整理一下上面的代码，有几个需要注意的地方

```js
function Foo() {
  // 注意这里是全局的
  getName = function () {
    console.log('1');
  };
  return this;
}
```

还有下面这个，两者都会提升，但是函数声明的提升级别是要比 `var` 高的，所以实际执行的是

```js
function getName() {
  console.log(5);
}

// 会覆盖上面的
var getName = function () {
  console.log('4');
};
```


#### Foo.getName();

函数 `Foo` 本身并没有执行，执行的是函数的属性 `getName`，输出的是 `2`

#### getName();

这是在全局执行 `getName()`，根据我们上面的分析可知，输出的结果是 `4`

#### Foo().getName(); 

因为 () 的优先级最高（见 [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)），所以首先运行 `Foo()`，全局的 `getName` 被覆盖成输出 `console.log('1')`，并且返回的 `this` 此时代表的是 `window`

也就是相当于执行了 `window.getName()`，所以输出的结果为 `1`

#### getName();

这个因为之前调用了 `Foo()`，所以输出的结果仍然是 `1`

#### new Foo.getName();

因为 `.` 操作符要比 `new` 优先级要高，所以执行的是 `new (Foo.getName)()`，所以输出为 `2`

#### new Foo().getName();

根据优先级可知，带参数的 `new` 操作符是优先级最高的，所以执行的就是 `(new Foo()).getName()`

而 `new Foo()` 生成的对象身上没有 `getName()` 的方法，那么就会去 `prototype` 当中寻找，所以输出的是 `3`

#### new new Foo().getName();

老规矩，按照优先级添加括号，首先带参数的 `new` 操作符优先级最高，则为 `new (new Foo().getName())`

然后就会发现和上面是类似的，可以转换为 `new ((new Foo()).getName())`，所以输出的也为 `3`





## JavaScript 中的数据绑定

关于数据双向绑定，绑定的基础就是监听属性的变化事件（`propertyChange`），现在主流的框架当中的解决方法一般有以下几种

* `Knockout` / `Backbone`（发布/订阅模式），简单来说就是另外开发一套 `API`，但使用起来却不得不使用这套 `API` 来操作 `viewModel`，导致上手复杂、代码繁琐

* `Angular`（脏检查机制），特点是直接使用原生 `JavaScript` 来操作 `viewModel`，但脏检查机制随之带来的就是性能问题

* `Vue`（数据劫持，也就是 `Object.defineProperty`），会把定义的 viewModel 对象（即 `data` 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 `JavaScript` 操作对象，又可以主动触发 `propertyChange` 事件，效率虽高，但也有一些限制，见后文

另外的几种方式

* `Object.observe`，谷歌对于简化双向绑定机制的尝试，在 `Chrome 49` 中引入，然而由于性能等问题，并没有被其他各大浏览器及 `ES` 标准所接受，所以在后续版本当中移除了该方法的实现

* `Proxy`，是 `ES6` 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 `Object.observe` 以实现双向绑定）



#### 基于数据劫持实现的双向绑定

#### 什么是数据劫持

数据劫持比较好理解，通常我们利用 `Object.defineProperty` 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作

```js
// 这是将要被劫持的对象
const data = {
  name: '',
};

// 测试函数
function test(name) {
  console.log(name);
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function (key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      console.log(`get`);
    },
    set: function (newValue) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`set`);
      test(newValue);
    },
  });
});

data.name = `new name`;
```

#### 数据劫持的优势以及实现思路

目前业界分为两个大的流派，一个是以 `React` 为首的单向数据绑定，另一个是以 `Angular`、`Vue` 为主的双向数据绑定

两者主要有两点区别

* 无需显示调用，例如 `Vue` 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 `Angular` 的脏检测或是 `react` 需要显示调用 `setState`

* 可精确得知变化数据：例如上面的例子，我们劫持了属性的 `setter`，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 `diff` 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 `diff` 来找出变化值，这是额外性能损耗

本质上，基于数据劫持的双向绑定离不开 `Proxy` 与 `Object.defineProperty` 等方法对对象/对象属性的"劫持"，我们要实现一个完整的双向绑定需要以下几个要点

* 利用 `Proxy` 或 `Object.defineProperty` 生成的 `Observer` 针对对象/对象的属性进行"劫持"，在属性发生变化后通知订阅者

* 解析器 `Compile` 解析模板中的 `Directive`（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染

* `Watcher` 属于 `Observer` 和 `Compile` 桥梁，它将接收到的 `Observer` 产生的数据变化，并根据 `Compile` 提供的指令进行视图渲染，使得数据变化促使视图变化

![IMG](双向数据绑定.png)



#### 基于 Object.defineProperty 双向绑定

完整的实现可以见 [剖析Vue原理&实现双向绑定MVVM](https://segmentfault.com/a/1190000006599500)，比如上面的示例，就是一个简单的实现

但是很快就会发现，里面存在着一堆问题，比如我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等

我们可以参考 `Vue` 的实现方式，`Vue` 的操作就是加入了发布订阅模式，结合 `Object.defineProperty` 的劫持能力，实现了可用性很高的双向绑定

下面是一个完成的例子


```html
<main>
  <p>请输入:</p>
  <input type="text" id="input">
  <p id="p"></p>
</main>
```


```js
// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它
const Vue = (function() {

  let uid = 0;

  // 用于储存订阅者并发布消息
  class Dep {

    constructor() {
      // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher
      this.id = uid++;
      // 储存订阅者的数组
      this.subs = [];
    }

    // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身
    depend() {
      Dep.target.addDep(this);
    }

    // 添加订阅者
    addSub(sub) {
      this.subs.push(sub);
    }

    notify() {
      // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理
      this.subs.forEach(sub => sub.update());
    }
  }

  // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher
  Dep.target = null;
  
  // 现在我们需要实现监听者（Observer），用于监听属性值的变化
  // 监听者，监听对象属性值的变化
  class Observer {

    constructor(value) {
      this.value = value;
      this.walk(value);
    }

    // 遍历属性值并监听
    walk(value) {
      Object.keys(value).forEach(key => this.convert(key, value[key]));
    }

    // 执行监听的具体方法
    convert(key, val) {
      defineReactive(this.value, key, val);
    }

  }

  function defineReactive(obj, key, val) {

    const dep = new Dep();

    // 给当前属性的值添加监听

    let chlidOb = observe(val);
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () => {
        // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中
        // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者
        // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法
        if (Dep.target) {
          dep.depend();
        }
        return val;
      },
      set: newVal => {
        if (val === newVal) return;
        val = newVal;
        // 对新值进行监听
        chlidOb = observe(newVal);
        // 通知所有订阅者，数值被改变了
        dep.notify();
      },
    });
  }

  function observe(value) {
    // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听
    if (!value || typeof value !== 'object') {
      return;
    }
    return new Observer(value);
  }



  // 我们还需要实现一个订阅者（Watcher）
  class Watcher {

    constructor(vm, expOrFn, cb) {
      this.depIds = {}; // hash 储存订阅者的 id，避免重复的订阅者
      this.vm = vm;     // 被订阅的数据一定来自于当前 Vue 实例
      this.cb = cb;     // 当数据更新时想要做的事情
      this.expOrFn = expOrFn; // 被订阅的数据
      this.val = this.get();  // 维护更新之前的数据
    }

    // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用
    update() {
      this.run();
    }

    addDep(dep) {
      // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存
      // 此判断是避免同 id 的 Watcher 被多次储存
      if (!this.depIds.hasOwnProperty(dep.id)) {
        dep.addSub(this);
        this.depIds[dep.id] = dep;
      }
    }

    run() {
      const val = this.get();
      console.log(val);
      if (val !== this.val) {
        this.val = val;
        this.cb.call(this.vm, val);
      }
    }

    get() {
      // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者
      Dep.target = this;
      const val = this.vm._data[this.expOrFn];
      // 置空，用于下一个 Watcher 使用
      Dep.target = null;
      console.log(Dep.target, 2);
      return val;
    }
  }

  
  // 将上述方法挂载在 Vue 上
  class Vue {

    constructor(options = {}) {
      // 简化了 $options 的处理
      this.$options = options;
      // 简化了对 data 的处理
      let data = (this._data = this.$options.data);
      // 将所有 data 最外层属性代理到 Vue 实例上
      Object.keys(data).forEach(key => this._proxy(key));
      // 监听数据
      observe(data);
    }

    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者
    $watch(expOrFn, cb) {
      new Watcher(this, expOrFn, cb);
    }

    _proxy(key) {
      Object.defineProperty(this, key, {
        configurable: true,
        enumerable: true,
        get: () => this._data[key],
        set: val => {
          this._data[key] = val;
        },
      });
    }

  }

  return Vue;
})();


// 使用
let demo = new Vue({
  data: {
    text: '',
  },
});

const p = document.getElementById('p');
const input = document.getElementById('input');

input.addEventListener('keyup', function(e) {
  demo.text = e.target.value;
});

demo.$watch('text', str => p.innerHTML = str);
```


#### Object.defineProperty 的缺陷

其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组

```js
let demo = new Vue({
  data: {
    list: [1],
  },
});

const list = document.getElementById('list');
const btn = document.getElementById('btn');

btn.addEventListener('click', function () {
  demo.list.push(1);
});

const render = arr => {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < arr.length; i++) {
    const li = document.createElement('li');
    li.textContent = arr[i];
    fragment.appendChild(li);
  }
  list.appendChild(fragment);
};

// 监听数组，每次数组变化则触发渲染函数，然而却无法监听
demo.$watch('list', list => render(list));

setTimeout(
  function () {
    alert(demo.list);
  },
  5000,
);
```

是的，`Object.defineProperty` 的第一个缺陷，无法监听数组变化，然而 `Vue` 的文档提到了 `Vue` 是可以检测到数组变化的

其实简单来说，这里就是重写了原来的方法

```js
const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
const arrayAugmentations = [];

aryMethods.forEach((method) => {

  // 这里是原生 Array 的原型方法
  let original = Array.prototype[method];

  // 将 push, pop 等封装好的方法定义在对象 arrayAugmentations 的属性上
  // 注意：是属性而非原型属性
  arrayAugmentations[method] = function () {
    console.log('我被改变啦!');
    // 调用对应的原生方法并返回结果
    return original.apply(this, arguments);
  };

});

let list = ['a', 'b', 'c'];

// 将我们要监听的数组的原型指针指向上面定义的空数组对象
// 别忘了这个空数组的属性上定义了我们封装好的 push 等方法
list.__proto__ = arrayAugmentations;
list.push('d');  // 我被改变啦！ 4

// 这里的 list2 没有被重新定义原型指针，所以就正常输出
let list2 = ['a', 'b', 'c'];
list2.push('d');  // 4
```

由于只针对了八种方法进行了 `hack`，所以其他数组的属性也是检测不到的

我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 `Object.defineProperty` 的第二个缺陷，只能劫持对象的属性

因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是更好的选择

```js
Object.keys(value).forEach(key => this.convert(key, value[key]));
```



#### Proxy 实现的双向绑定

`Proxy` 在 `ES2015` 规范中被正式发布，它在目标对象之前架设一层"拦截"，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写

我们可以这样认为 `Proxy` 是 `Object.defineProperty` 的全方位加强版

`Proxy` 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 `Object.defineProperty`


#### Proxy 可以直接监听数组的变化

当我们对数组进行操作（`push`、`shift`、`splice` 等）时，会触发对应的方法名称和 `length` 的变化

下面是一个实例

```html
<main>
  <ul id="list">
  </ul>
  <button type="button" name="button" id="btn">添加列表项</button>
</main>
```

```js
const list = document.getElementById('list');
const btn = document.getElementById('btn');

// 渲染列表
const Render = {

  // 初始化
  init: function(arr) {
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < arr.length; i++) {
      const li = document.createElement('li');
      li.textContent = arr[i];
      fragment.appendChild(li);
    }
    list.appendChild(fragment);
  },

  // 我们只考虑了增加的情况，仅作为示例
  change: function(val) {
    const li = document.createElement('li');
    li.textContent = val;
    list.appendChild(li);
  },
};

// 初始数组
const arr = [1, 2, 3, 4];

// 监听数组
const newArr = new Proxy(arr, {
  get: function(target, key, receiver) {
    console.log(key);
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, value, receiver) {
    console.log(target, key, value, receiver);
    if (key !== 'length') {
      Render.change(value);
    }
    return Reflect.set(target, key, value, receiver);
  },
});

// 初始化
window.onload = function() {
  Render.init(arr);
}

// push 数字
btn.addEventListener('click', function() {
  newArr.push(6);
});
```

#### Proxy的优势

`Proxy` 有多种拦截方法，不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等，是 `Object.defineProperty` 不具备的

`Proxy` 返回的是一个新对象，我们可以只操作新的对象达到目的，而 `Object.defineProperty` 只能遍历对象属性直接修改



## 原型和闭包

主要参考 [深入理解javascript原型和闭包](http://www.cnblogs.com/wangfupeng1988/p/3977987.html)

#### 对象 - 若干属性的集合

```js
// 简单的值类型，不是对象
console.log(typeof x);                 // undefined
console.log(typeof 10);                // number
console.log(typeof 'abc');             // string
console.log(typeof true);              // boolean

// 函数其实也是对象，也是可以做为参数传递的
console.log(typeof function () { });   //function

// 引用类型
console.log(typeof [1, 'a', true]);    //object
console.log(typeof { a: 10, b: 20 });  //object
console.log(typeof null);              //object
console.log(typeof new Number(10));    //object
```

判断一个变量是不是对象，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`


#### 函数和对象的关系

对象是可以通过函数来创建

```js
//var obj = { a: 10, b: 20 };
//var arr = [5, 'x', true];

var obj = new Object();
obj.a = 10;
obj.b = 20;

var arr = new Array();
arr[0] = 5;
arr[1] = 'x';
arr[2] = true;
```

#### prototype

每个函数都有一个属性叫做 `prorotype`，这个 `prototype` 的属性值是一个对象（属性的集合），默认的还有一个叫做 `constructor` 的属性，指向这个函数本身

![prototype01](http://images.cnitblog.com/blog/138012/201409/172121182841896.png)

例如 `Object` 的 `prototype` 上就挂载了一系列方法

![prototype02](http://images.cnitblog.com/blog/138012/201409/172130097842386.png)

我们也可以在自己自定义的方法的 `prototype` 中新增自己的属性

```js
function Foo () {...}

Foo.prototype.name = ..

Foo.prototype.getName = function () {..}

var bar = new Foo();
console.log(bar.name);
console.log(bar.getName());
```

`Foo` 是一个函数，`bar` 对象是通过 `Foo` 函数 `new` 出来的，这样一来，`bar` 对象就可以调用 `Foo.prototype` 上的属性和方法

因为每个对象都有一个隐藏的属性 `__proto__`（一般称为 隐式原型），这个属性引用了创建这个对象的函数的 `prototype`，即

```js
bar.__proto__ === Foo.prototype  // true
```

#### instanceof

对于值类型可以使用 `typeof` 判断，但是对于引用类型的时候，返回值只有 `object/function`，这个时候就可以使用 `instanceof`

![instanceof](http://images.cnitblog.com/blog/138012/201409/181635468939277.png)

比如判断 `f1 instanceof Object`，按照上图来说就是：

* 沿着 `f1` 的 `__proto__` 这条线来找，同时沿着 `Object` 的 `prototype` 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 `true`，如果找到终点还未重合，则返回 `false`

这也解释了为何一下结果均返回 `true`

```js
Object instanceof Function;    // true

Function instanceof Object;    // true

Function instanceof Function;  // true
```

完整原型图如下所示：

![原型链](http://images.cnitblog.com/blog/138012/201409/181637013624694.png)

* `instanceof` 表示的就是一种继承关系，或者原型链的结构

一个小小的练习题：

```js
var a = {
  x: 1,
  y: { z: 2 }
};

var b = {};
b.__proto__ = a;

// a 和 b 都是对象（通过new Object() 生成，这里是简写）
// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）
// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），原则上应该去 Object.prototype 上查找 
// 但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找
// 所以 b.x 为 1，b.y 为 { z: 2 }
console.log(a.x);
console.log(b.x);

// 然后把 b.x 重新赋值为 22
// 因为是基本类型，所以 a.x 是不变的
b.x = 22;
console.log(a.x);
console.log(b.x);

// 这个同上面那个类似
// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址
// 其中一个变化的话自然会引起另外一个变化
b.y.z = 33;
console.log(a.y.z);
console.log(b.y.z);
```


#### 继承

访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 `__proto__` 这条链往上找，这就是原型链

可以利用 `hasOwnProperty` 来区分一个属性是不是从原型上继承得到的（特别是在 `for..in` 循环中）

`hasOwnProperty` 这个方法存在与 `Object.prototype` 上，对象的原型链是沿着 `__proto__` 这条线走的，因此在查找对象的 `hasOwnProperty` 属性的时候，就会顺着原型链一直查找到 `Object.prototype`

由于所有的对象的原型链都会找到 `Object.prototype`，因此所有的对象都会有 `Object.prototype` 的方法，这就是所谓的**继承**

同样的，每个函数都有 `call`，`apply` 方法，这也是"继承"而来的，函数由 `Function` 函数构建，因此继承的 `Function.prototype` 中的方法

至于为什么 `Function.prototype` 上也会有 `hasOwnProperty` 方法，这是因为 `Function.prototype` 同样继承自 `Object.prorotype`




#### 执行上下文环境

简单来说，函数**每被**调用一次，都会产生一个新的执行上下文环境，因为不同的调用可能就会有不同的参数

需要注意一点：函数体内部自由变量在函数在定义的时候（不是调用的时候）就已经确定了

`javascript` 在执行一个代码段之前，都会进行这些 "准备工作" 来生成执行上下文，其实分三种情况 -- 全局代码，函数体，`eval` 代码（不推荐这个）


#### 全局执行上下文环境

在产生执行全局上下文时，浏览器通常会做以下三个准备工作：

* 提取 `var` 声明的变量，并赋值（默认）为 `undefined`（变量提升）

* 提取声明式函数（`function foo () {..}`）

* 给 `this` 赋值（指向 `window` 或当前对象）


#### 函数体上下文环境（也就是所谓的局部）

会在以上三个的基础上增加以下三条：

* 给函数参数赋值

* 给 `arguments` 赋值（是一个实参副本，与实参保持一致）

* 自由变量的取值作用域，查找并赋值

所以总结来说就是，**在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空**

而在执行 `js` 代码时，会有数不清的函数调用次数，会产生许多个上下文环境，这么多上下文环境该如何管理，以及如何销毁而释放内存就主要依靠下面的**执行上下文栈**

#### 执行上下文栈

执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境

处于活动状态的执行上下文环境只有一个

其实这是一个 **压栈** ==> **出栈** 的过程，如下图所示：

* 压栈：函数未调用时只有全局上下文在执行，每次调用函数时会产生局部上下文，这就是压栈，也就是进栈

* 出栈：函数调用完成后，就会出栈，会销毁本次调用的局部上下文环境

注意：若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的）

![执行上下文栈](http://images.cnitblog.com/blog/138012/201409/232122300768665.png)

上面这种只是较为理想的情况，有一种情况无法做到这样干净利落的说销毁就销毁，这个就是 -- 闭包


#### this

`this` 是 `Javascript` 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用

随着函数使用场合的不同，`this` 的值会发生变化，但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象

`JavaScript` 中函数的调用有以下几种方式：

* 为对象方法调用

* 作为函数调用

* 作为构造函数调用

* 使用 `apply` 或 `call` 调用

一个小案例，在 `jQuery` 中，有下面这样一段代码：

```js
jQuery.extend = jQuery.fn.extend = function () {
  // ...
  if (i === length) {
    target = this;
    i--;
  }
  // ...
}
```

`jQuery.extend` 和 `jQuery.fn.extend` 都指向了同一个函数，但是当执行时，函数中的 `this` 是不一样的

执行 `jQuery.extend( .. )` 时，this 指向 `jQuery`

执行 `jQuery.fn.extend( .. )` 时，this 指向 `jQuery.fn`

这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则


#### 作用域

`javascript` 中没有块级作用域（`ES6` 之前），除了全局作用域以外，只有函数可以创建作用域

我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好（先声明，在使用），除了这两个地方，其他地方都不要出现变量声明

作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突

除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数**定义时**就已经确定了，而不是在函数**调用时**确定

抽象来看待的话，作用域只是一个 "地盘"，其中没有变量，要通过**作用域对应的执行上下文环境**来获取变量的值

同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了

所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值

## 自由变量 到 作用域链

所谓自由变量，指的是在当前作用域中未声明的变量，会去到**创建这个函数的作用域中去取值，而不是简简单单的上一级（注意，是创建，不是调用）**，这就是所谓的静态作用域

```js
var x = 100;

function foo() {
  console.log(x);
}

function bar(fn) {
  var x = 200;

  (function () {
    fn();  // 100
  })()
}

bar(foo);
```

如果没有找到，则继续往上找，一直到全局作用域为止，如果还没有找到，那就是不存在了，这个过程可以称之为**作用域链**


#### 上下文环境和作用域的关系

* 上下文环境：可以理解为一个抽象的东西，程序执行前，会生成全局上下文环境，函数在调用的时候会创建函数上下文环境

* 作用域：**除了全局作用域，只有函数才能创建作用域（ES6 之前）**，创建一个函数就创建了一个作用域，无论你调不调用，函数只要创建了，它就有独立的作用域

* 两者的区别在于：一个作用域可能没有（函数没被调用），也可能存在过（调用完成，上下文环境被摧毁），也有可能同时存在多个（闭包）上下文环境

一个简单的小例子：

```js
var x = 100;

function fn (x) {
    return function () {
        console.log(x);
    }
}

var f1 = fn(5);
var f2 = fn(10);

f1();  // 5
f2();  // 10
```





## 闭包

只需要记住应用的两种情况即可

#### 第一种 函数作为返回值

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

`bar` 函数作为返回值，赋值给 `f1` 变量，执行 `f1(15)` 时，用到了 `fn` 作用域下的 `max` 变量的值

#### 第二种 函数作为参数传递

```js
var max = 10,
  fn = function (x) {
    if (x > max) {
      console.log(x)
    }
  };

(function (f) {
  var max = 100;
  f(11);  // 11
})(fn)
```

`fn` 作为一个参数传递进入另一个函数，赋值给 `f` 参数，执行 `f(11)` 的时候，`max` 取值是 `10`，而不是 `100`

之前提到过，当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁，但是在有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁，这里指的就是闭包，以上面第一种代码为例

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

* 代码执行前的全局上下文环境，并在执行时对其中的变量进行赋值，此时全局上下文环境（活动状态）中的 `max` 为 `undefined`

* 当调用 `fn()` 时会产生 `fn()` 执行上下文环境（活动状态），此时 全局中的 `max` 仍为 `undefined`，`fn()` 上下文环境中的 `max` 为 `10`

* 当 `fn()` 调用完成，按理说应该销毁掉 `fn()` 的执行上下文环境，但是**返回的是一个函数，函数的特别之处在于可以创建一个独立的作用域**

  * 而返回的这个函数体中，还有一个自由变量 `max` 要引用 `fn` 作用域下的 `fn()` 上下文环境中的 `max`

  * 因此，这个 `max` 不能被销毁，销毁了之后 `bar` 函数中的 `max` 就找不到值了

  * 所以这里的 `fn()` 上下文环境不能被销毁，还依然存在与执行上下文栈中

* 当执行到 ```var max = 100``` 的时候，`fn()` 上下文环境依然会在执行上下文栈中，当执行完成后，全局中的 `max` 为 `100`，而 `fn()` 上下文环境中的 `max` 仍为 `10`

* 当执行最后的 `f1(5)` 的时候，即执行返回的函数 `bar(5)`，此时，`bar()` 上下文环境中的 `x` 为 `5`，而 `max` 变量是自由变量，需要向创建 `bar` 函数的作用域中查找，找到了 `max` 的值为 `10`

这里的重点就在于，创建 `bar` 函数是在执行 `fn()` 时创建的，`fn()` 早就执行结束了，但是 `fn()` 执行上下文环境还存在与栈中，因此 `bar(5)` 时，`max` 可以查找到，如果 `fn()` 上下文环境销毁了，那么 `max` 就找不到了，这也是为什么使用闭包会增加内容开销





## ES6 的一些新方法

#### let 命令

* 只要块级作用域内存在 `let` 命令，它所声明的变量就 "绑定"（`binding`）这个区域，不再受外部的影响

* `typeof` 不再是一个百分比安全的操作（如果一个变量根本没有被声明，使用 `typeof` 反而不会报错）

* `function bar(x = y, y = 2) {}` （`y` 没有声明，所以会报错）

* 不允许重复声明

* 块级作用域的出现，使得立即执行函数表达式（`IIFE`）不再必要了

* 建议避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

* 允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错

* 在 `ES6` 浏览器中（只对 `ES6` 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 `let` 处理）

 * 允许在块级作用域内声明函数

 * 函数声明类似于 `var`，即会提升到全局作用域或函数作用域的头部

 * 同时，函数声明还会提升到所在的块级作用域的头部

```js
// 不报错
"use strict";
if (true) {
  function f() { }
}

// 报错
"use strict";
if (true)
  function f() { }
```




#### const 命令

* 声明一个只读常量，一旦声明，常量的值就不能改变，而且必须立即初始化，不能留到以后在赋值

* `const foo = {};`

 * 常量 `foo` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 `foo` 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

* 与 `let` 命令相似之处：

 * 只能在声明所在的块级作用域内有效

 * 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用

 * 不可重复声明



#### 字符串的扩展

* 添加了遍历器接口，使得字符串可以被 `for...of` 循环遍历

* 添加了三个用于查询字符串位置的函数：

 * `includes()`： 返回布尔值，表示是否找到了参数字符串

 * `startsWith()`： 返回布尔值，表示参数字符串是否在源字符串的头部

 * `endsWith()`： 返回布尔值，表示参数字符串是否在源字符串的尾部

以上三个方法都支持第二个参数，表示开始搜索的位置，不同之处在于 `endsWith` 针对前 `n` 个字符，而其他两个方法针对从第 `n` 个位置直到字符串结束。

* `repeat()` 方法返回一个新字符串，表示将原字符串重复 `n` 次

 * 如果是小数，则会被取整（`2.2 => 2`, `2.9 => 2`）

 * 如果是负数（小于-1）或者 `Infinity`，则会报错

 * 如果是 `0` 到 `-1` 之间的小数，则等同于 `0`，因为会先进行取整运算（`NaN` 也等同于 `0`）

 * 如果参数是字符串，则会先转换为数字（`"3" => 3`, `"na" => ""`）

* 新增了模版字符串

```js
$("#result").append(`
    There are <b> ${basket.count} </b> items
    in your basket, <em> ${basket.onSale} </em>
    are on sale!`
);
```

 * 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义（``\`Hello\` World!``）

 * 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中

 * 如果想去掉模版字符串开头和结尾处的换行，可以使用 `trim` 方法消除它

 * 如果大括号内部是一个字符串，将会原样输出（`Hello ${"World}` => "Hello World"）

 * 模板字符串中也可以嵌入变量以及调用函数，比如 `${user.name}`，`${fn()}`




#### 对象的扩展

* 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = "bar";
var baz = {foo};
baz;  // {foo: "bar"}
```

* 方法也可以简写 `method () {return "hello"}`

* 可以用于函数的返回值：

```js
function getPoint () {
  var x = 1;
  var y = 2;
  return {x, y};
}

getPoint();  // {x: 1, y: 2}
```

* 新增属性名表达式 `obj["a" + "bc"] = 123;`

 * 表达式也可以用于定义方法名

* 属性名表达式与简洁表示法，不能同时使用，否则会报错

* 特别注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 `[object, Object]`

```js
const myObject = {
  [keyA]: "valueA",
  [keyB]: "valueB"
};

// [keyB] 会把 [keyA] 覆盖掉，而 myObject 最后只有一个 [object Object] 属性
```



#### 数值的扩展

* `parseInt()` 和 `parseFloat()` 移植到了 `Number` 对象上面 （`Number.parseInt("1*34")  // 12`）

* `Number.isInteger()` 用来判断一个值是否为整数（在 `JavaScript` 内部，整数和浮点数是同样的储存方法，所以 `3` 和 `3.0` 被视为同一个值）

`Math` 对象扩展：

* `Math.trunc()` 方法用于去除一个数的小数部分，返回整数部分

 * 对于非数值，内部会先使用 `Number` 方法将其先转为数值

 * 对于空值和无法截取整数的值，返回 `NaN`

* `Math.sign()` 方法用来判断一个数到底是正数，负数，还是零，会返回五种值：

 * 参数为正数，返回 `+1`

 * 参数为负数，返回 `-1`

 * 参数为 `0`，返回 `0`

 * 参数为 `-0`，返回 `-0`

 * 其他值，返回 `NaN`

* `Math.cbrt()` 方法用于计算一个数的立方根

* `Math.hypot()` 返回所有参数的 平方和 的 平方根 

```js 
Math.hypot(3, 4);  // 5（3 的平方 + 4 的平方 等于 5 的平方）
```




#### 数组的扩展

* `Array.from()` 将 类似数组的对象（`array-like-object`） 和 可遍历（`iterable`）的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）转为 **真正的数组**

 * 接受的第二个参数，作用类似于数组的 `map` 方法，用来对每个元素进行处理，将处理后的结果放入返回的数组

 * 如果 `Array.from()` 没有参数，就返回一个**空数组**

* `Array.of()` 用于将一组值，转换为数组（因为在 `ES5` 中，参数个数的不同，会导致 `Array()` 的行为有差异）

* `find()` 方法，用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 `true` 的成员，并返回，如果没有找到符合条件的成员，则返回 `undefined`

 * 回调函数可以接受三个参数，依次为 当前的值、当前的位置 和 原数组

* `findIndex()` 方法的用法与 `find()` 方法非常相似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 `-1`

 * `find()` 方法和 `findIndex()` 方法都可以发现 `NaN`，弥补了数组的 `indexOf` 方法的不足

* `fill()` 方法使用给定值，填充一个数组

 * 需要注意的是，数组中已有的元素，会被全部抹去

 * 可以指定第二个和第三个参数，用于指定填充的起始位置和结束位置

* 提供了三个新的方法来用于遍历数组，它们都返回一个遍历器对象，可以用 `for...of` 循环进行遍历（如果不使用 `for...of` 循环，可以手动调用遍历器对象的 `next()` 方法，进行遍历）

 * `keys()` 是对**键名**的遍历

 * `values()` 是对**键值**的遍历

 * `entries()` 是对**键值对**的遍历

* `Array.prototype.includes` 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 `includes` 方法类似

 * 第二个参数表示搜索的起始位置，默认为 `0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 `-4`，但数组长度为 `3`），则会重置为从 `0` 开始

`Map` 和 `Set` 数据结构有一个 `has` 方法，需要注意与 `includes` 区分

* `Map` 结构的 `has` 方法，是用来查找**键名**的，比如 `Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`

* `Set` 结构的 `has` 方法，是用来查找**值**的，比如 `Set.prototype.has(value)`、`WeakSet.prototype.has(value)`





#### 解构

```js
// 属于"模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值
var [a, b, c] = [1, 2, 3]
```

* 如果解构不成功，变量的值就等于 `undefined`

* 如果等号右边不是数组（不是可遍历的解构，不具有 `Iterator` 接口），那么将会报错（`number`，`string`，`false`，`NaN`，`undefined`，`null`，`{ }` 等）

* 只要某种数据具有 `Iterator` 接口，都可以采用数组形式的解构赋值

* 解构赋值允许指定默认值（内部使用的是严格相等运算符 `===`）

* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

* 对象的解构

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" }
```

* 对象的属性没有次序，变量必须与属性同名，才能取到正确的值

```js
let foo;
({ foo } = { foo: 1 }); // success

let baz;
({ bar: baz } = { bar: 1 }); // success
```

上例中的圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句




#### 字符串的解构

字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象



#### 数值和布尔值的解构

解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象

规则是，只要等号右边的值不是对象，就先将其转为对象，由于 `undefined` 和 `null` 无法转为对象，所以对它们进行解构赋值，都会报错



#### 函数相关

* 在 `ES6` 中，允许函数的参数设置默认值，即直接写在参数定义的后面（函数参数的默认值）

 * 参数变量是默认声明的，所以不能使用 `let` 或者 `const` 再次声明

 * 指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值以后，`length` 属性将失效（length属性的含义是，该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了）

* 如果设置了默认值的参数不是尾参数（即设置默认值的不是最后一个参数），那么 `length` 属性也不再计入后面的参数了

* 如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域

* 用于将一个数组转为用都好分隔的参数序列（`console.log(...[1, 2, 3])`）

* 在 ES5 中，如果将一个匿名函数赋值给一个变量，其 `name` 属性，会返回空字符串，而 ES6 中修正了这个问题，会返回实际的函数名

 * `Function` 构造函数返回的函数实例，`name` 属性的值为 `anonymous`

 * `bind` 返回的函数，`name` 属性会加上 `bound` 前缀

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 `return` 语句返回

```js
var sum = (num1, num2) => { return num1 + num2; }
```

* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号

```js
var getTempItem = id => ({ id: id, name: "Temp" });
```

* 箭头函数的使用注意点

 * 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象（例如在 `Vue` 的实例属性或回调函数中就不建议使用箭头函数，因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是对应方法未被定义）

 * 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误

 * 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `Rest` 参数代替

 * 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数

 * 需要特别注意的是：`this` 对象的指向是可变的，但是在箭头函数中，它是固定的

 * 箭头函数中的 `this` 指向的固定化，并不是因为箭头函数内部有绑定 `this` 的机制，实际原因是箭头函数根本没有自己的 `this`，导致内部的 `this` 就是外层代码块的 `this`（正式因为它没有 `this`，所以也就不能用作构造函数）



#### Symbol

`ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值，它是 `JavaScript` 第七种数据类型

```js
// 变量 s 就是一个独一无二的值
let s = Symbol();

// typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型
typeof s
// "symbol"
```



## 变量的赋值与深浅拷贝

#### JavaScript 中变量的赋值

在 `JavaScript` 中，变量的赋值分为 「传值」 与 「传址」

给变量赋予基本数据类型的值，也就是「传值」，而给变量赋予引用数据类型的值，实际上是「传址」

基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较

```js
var num1 = 123;
var num2 = 123;
var num3 = num1;

num1 === num2;  // true
num1 === num3;  // true

num1 = 456;
num1 === num2;  // false
num1 === num3;  // false
```

引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较

```js
var arr1 = [1, 2, 3];
var arr2 = [1, 2, 3];
var arr3 = arr1;

arr1 === arr2;  // false
arr1 === arr3;  // true

arr3 = [1, 2, 3];
arr1 === arr3;  // false
arr2 === arr3;  // false
```


#### JavaScript 中变量的拷贝

拷贝分为浅拷贝和深拷贝

#### 浅拷贝

浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性

对于目标对象第一层为基本类型的数据，就是直接赋值，即「传值」

而对于目标对象第一层为引用数据类型的数据，就是直接赋与内存中的堆内存地址，即「传址」



#### 深拷贝

深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性

一般来说，在 `JavaScript` 中考虑复合类型的深层复制的时候，往往就是指对于 `Date`，`Object` 和 `Array` 三个复合类型的处

一般简单的处理方式是建立一个新的空对象，然后递归遍历旧的的对象，直到发现基础类型的子节点才赋予到新对象对应的位置

不过这个方法存在一个问题，就是 `JavaScript` 中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后需要考虑原型应不应该被赋予给新对象

一般在使用过程中，我们通常会使用 `hasOwnProperty` 方法来进行判断是否过滤掉那些继承自原型链上的属性


#### 实现

```js
function _isPlainObject(target) {
  return (typeof target === 'object' && !!target && !Array.isArray(target));
}

function shallowExtend() {

  var args = Array.prototype.slice.call(arguments);
  // 第一个参数作为 target
  var target = args[0];
  var src;
  target = _isPlainObject(target) ? target : {};

  for (var i = 1; i < args.length; i++) {
    src = args[i];
    if (!_isPlainObject(src)) {
      continue;
    }
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        if (src[key] != undefined) {
          target[key] = src[key];
        }
      }
    }
  }
  return target;
}

var target = {
  key: 'value',
  num: 1,
  bool: false,
  arr: [1, 2, 3],
  obj: {
    objKey: 'objValue'
  },
};

var result = shallowExtend({}, target, {
  key: 'changeValue',
  num: 2
})

// 对原引用类型数据做修改
target.arr.push(4);

console.log(target.arr === result.arr)  // true
console.log(result)

// {
//   key: 'changeValue',
//   num: 2,
//   bool: false,
//   arr: [1, 2, 3, 4],
//   obj: {
//     objKey: 'objValue'
//   },
// }
```


#### jQuery 中的 extend 的实现

先来看看怎么使用

```js
$.extend( target [, object1 ] [, objectN ] )

// 可以添加参数来指示是否深度合并
$.extend( [deep ], target, object1 [, objectN ] )
```

> 需要注意的是，第一个参数不支持传递 `false`

取值 | 解释
---- | ----
`deep` | 可选，`Boolean` 类型 指示是否深度合并对象，默认为 `false`，如果该值为 `true`，且多个对象的某个同名属性也都是对象，则该"属性对象"的属性也将进行合并
`target` | `Object` 类型 目标对象，其他对象的成员属性将被附加到该对象上
`object1` | 可选，`Object` 类型 第一个被合并的对象
`objectN` | 可选，`Object` 类型 第N个被合并的对象

简单来说，该方法的作用是用一个或多个其他对象来扩展一个对象，返回扩展后的对象

如果不指定 `target`，则是给 `jQuery` 命名空间本身进行扩展（有利于为 `jQuery` 增加新方法）

如果第一个参数设置为 `true`，则 `jQuery` 返回一个深层次的副本，递归的复制找到的任何对象，否则的话副本会与原对象共享结构

**未定义的属性不会被复制，然而从对象的原型继承的属性将会被复制**

源码如下
```js
// 版本为 3.31
jQuery.extend = jQuery.fn.extend = function () {
  var options,
    name,
    src,
    copy,
    copyIsArray,
    clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // 如果第一个参数是布尔值，则为判断是否深拷贝的标志变量
  if (typeof target === "boolean") {
    deep = target;
    // 跳过 deep 标志变量，留意上面 i 的初始值为1
    target = arguments[i] || {};
    // i 自增1
    i++;
  }

  // 判断 target 是否为 object / array / function 以外的类型变量
  if (typeof target !== "object" && !isFunction(target)) {
    // 如果是其它类型变量，则强制重新赋值为新的空对象
    target = {};
  }

  // 如果只传入 1 个参数，或者是传入 2 个参数，第一个参数为 deep 变量，第二个为 target
  // 所以 length 的值可能为 1 或 2，但无论是 1 或 2，下段 for 循环只会运行一次
  if (i === length) {
    // 将 jQuery 本身赋值给 target
    target = this;
    // i 自减1，可能的值为 0 或 1
    i--;
  }

  for (; i < length; i++) {
    // 以下拷贝操作，只针对非 null 或 undefined 的 arguments[i] 进行
    if ((options = arguments[i]) != null) {
      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name];
        // 避免死循环的情况
        if (target === copy) {
          continue;
        }
        // 如果是深拷贝，且 copy 值有效，且 copy 值为纯 object 或纯 array
        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            // 数组情况
            copyIsArray = false;
            clone = src && Array.isArray(src)
              ? src
              : [];
          } else {
            // 对象情况
            clone = src && jQuery.isPlainObject(src)
              ? src
              : {};
          }
          // 克隆 copy 对象到原对象并赋值回原属性，而不是重新赋值
          // 递归调用
          target[name] = jQuery.extend(deep, clone, copy);

          // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }
  // Return the modified object
  return target;
};
```




#### Object.assign()

`Object.assign()` 方法可以把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象

需要注意的是

* 对于访问器属性，该方法会执行所属访问器的 `getter` 函数，然后把得到的值拷贝给目标对象

  * 如果想拷贝访问器属性本身，可以使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperties()` 方法

* 字符串类型和 `symbol` 类型的属性都会被拷贝

* 在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 `TypeError` 异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性则不会再被拷贝



#### 利用 JSON 进行忽略原型链的深拷贝

```js
var dest = JSON.parse(JSON.stringify(target));
```

同样有缺点，它会忽略掉值为 `undefuned` 的属性以及函数表达式，但不会忽略值为 `null` 的属性


#### 规避原型链属性上的拷贝

#### 使用 hasOwnProperty

```js
for (let key in targetObj) {
  if (targetObj.hasOwnProperty(key)) {
    // ...
  }
}
```

也有一些缺点，就是会遍历了原型链上所有的属性，效率不高

#### Object.keys()

```js
const keys = Object.keys(targetObj);

keys.map((key) => {
  // ...
})
```

这个需要注意的是，只会返回参数对象自身的（不含继承的）所有可遍历（`enumerable`）属性的键名所组成的数组


#### 另辟蹊径

```js
const obj = Object.create(null);
target.__proto__ = Object.create(null);

for (let key in target) {
  // 相关操作
}
```



## fileReader 接口

`FileReader` 接口主要是将文件读入内存，并提供相应的方法，来读取文件中的数据，当然就能显示本地图片不需上传了

一个简单的示例如下：

```js
var result = document.getElementById('result');
var file = document.getElementById('file');

// 判断浏览器是否支持 FileReader 接口
if (typeof FileReader == 'undefined') {
  result.InnerHTML = '<p>你的浏览器不支持 FileReader 接口！</p>';
  // 使选择控件不可操作
  file.setAttribute('disabled', 'disabled');
}

function readAsDataURL() {
  // 检验是否为图像文件
  var file = document.getElementById('file').files[0];
  if (!/image\/\w+/.test(file.type)) {
    alert('格式不正确！');
    return false;
  }
  var reader = new FileReader();
  // 将文件以 Data URL 形式读入页面
  reader.readAsDataURL(file);
  reader.onload = function (e) {
    var result = document.getElementById('result');
    // 显示文件
    result.innerHTML = '<img src= ' + this.result + ' >'
  }
}
```

```html
<p>
  <input type='file' id='file' />
  <input type='button' value="读取图像" onclick="readAsDataURL()" />
</p>

<div id='result' name='result'></div>
```

预览完成后就可以上传到服务器了：

```js
$('#submitBtn').submit(function () {
  if ($('#upload_file').val()) {
    $('#upload_btn').attr('disabled', true);
    $('.tip').html('正在上传中，请稍候...');
    $(this).ajaxSubmit({
      type: 'post',
      url: url,
      success: function (data) { // 提交成功的回调函数
        // ...
        $('#upload_btn').attr('disabled', false);
        $('.tip').html('');
      }

    });
  }
  return false; // 不刷新页面
});
```

#### FileReader 的方法和事件

```js
// 方法
abort	                          // 中断读取

readAsText(file, [encoding])	  // 将文件读取为文本该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8
                                // 这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容

readAsBinaryString(file)        // 将文件读取二进制码通常我们将它传送到后端，后端可以通过这段字符串存储文件

readAsDataURL(file)             // 将文件读取为 DataURL 将文件读取为一串Data URL字符串，
                                // 将小文件以一种特殊格式的URL地址直接读入页面，小文件指图像与html等格式的文件


// 事件
onabort	        //  数据读取中断时触发

onerror	        //  数据读取出错时触发

onloadstart     //  数据读取开始时触发

onload	        //  数据读取成功完成时触发

onloadend       //  数据读取完成时触发，无论成功失败
```


#### 分段读取文本信息（slice）

有的时候，一次性将一个大文件读入内存，并不是一个很好的选择（如果文件太大，可能直接导致浏览器崩溃），更稳健的方法是分段读取

`HTML5 File Api` 提供了一个 `slice` 方法，允许分片读取文件内容

文件一旦开始读取，无论成功或失败，实例的 `result` 属性都会被填充，如果读取失败，则 `result` 的值为 `null` ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值

```js
function readBlob(start, end) {
  var files = document.getElementById('file').files;

  if (!files.length) {
    alert('请选择文件');
    return false;
  }

  var file = files[0],
    start = parseInt(start, 10) || 0,
    end = parseInt(end, 10) || (file.size - 1);

  var r = document.getElementById('range'),
    c = document.getElementById('content');

  var reader = new FileReader();
  reader.onloadend = function (e) {
    if (this.readyState == FileReader.DONE) {
      c.textContent = this.result;
      r.textContent = 'Read bytes: ' + (start + 1) + ' - ' + (end + 1) + ' of ' + file.size + ' bytes';
    }
  };

  // 兼容
  var blob;
  if (file.webkitSlice) {
    blob = file.webkitSlice(start, end + 1);
  } else if (file.mozSlice) {
    blob = file.mozSlice(start, end + 1);
  } else if (file.slice) {
    blob = file.slice(start, end + 1);
  }

  reader.readAsBinaryString(blob);

};

document.getElementById('file').onchange = function () {
  readBlob(10, 100);
}
```


使用了 `FileReader` 的 `onloadend` 事件来检测读取成功与否，如果用 `onloadend` 则必须检测一下 `FileReader` 的 `readyState`，因为 `read abort` 时也会触发 `onloadend` 事件，如果我们采用 `onload`，则可以不用检测 `readyState`

#### FileReader 进度条

既然 `FileReader` 是异步读取文件内容，那么就应该可以监听它的读取进度，事实上，`FileReader` 的 `onloadstart` 以及 `onprogress` 等事件，可以用来监听 `FileReader` 的读取进度

在 `onprogress` 的事件处理器中，提供了一个 `ProgressEvent` 对象，这个事件对象实际上继承了 `Event` 对象，提供了三个只读属性：`lengthComputable`、`loaded`、`total`，通过以上几个属性，即可实时显示读取进度

```js
interface ProgressEvent : Event {
  readonly attribute boolean lengthComputable;
  readonly attribute unsigned long long loaded;
  readonly attribute unsigned long long total;
};
```

`ajax` 上传并显示进度条：

```js
function upLoad() {

  var myPic = document.querySelector('myPic').files[0];
  var fd = new FormData();
  fd.append('myPic', myPic);

  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && xhr.status == 200) {
      alert(xhr.responseText);
    }
  }

  // 监听附件上传情况
  xhr.upload.onprogress = function () {
    //  evt.loaded  -- 已经上传大小
    //  evt.total   -- 附件总大小
    var loaded = evt.loaded;
    var tot = evt.total;
    var per = Math.floor(100 * loaded / tot);
    var son = document.getElementById('flag');
    flag.innerHTML = per + '%';
    flag.style.width = per + '%';
  }

  var url = '';
  xhr.open('POST', url);
  xhr.send(fd);
}
```


#### 扩展：FormData 对象

`FormData` 对象，可以把 `form` 中所有表单元素的 `name` 与 `value` 组成一个 `queryString`，提交到后台

用 `jQuery` 的方法来说，就是 `serialize` 了，但是在使用 `Ajax` 提交时，这过程就变成人工的了，因此，使用 `FormData` 对象可以减少拼接 `queryString` 的工作量

1. 可以先创建一个空的 `FormData` 对象，然后利用 `append` 方法向该对象添加字段（`key/value`）

```js
var myForm = new FormData();

myForm.append('name', 'zhangsan');
myForm.append('name', 'lisi');
myForm.append('num', 222333);  // 数字会被转换成字符串
```

2. 或者可以取得 `form` 元素对象，然后将其作为参数传入 `FormData` 对象中

```js
var myForm = document.querySelector('#myForm');
var formdata = new FormData(myForm);
```

3. 利用 `getFormData` 生成

```js
var myForm = document.querySelector('#myForm');
var formdata = myForm.getFormData();
```

4. 使用 `FormData` 提交表单：

```js
function fsubmit() {
  var data = new FormData($('#myForm')[0]);
  $.ajax({
    url: 'upLoad.html',
    type: 'POST',
    data: data,
    dataType: 'JSON',
    cahce: false,
    processData: false,
    contentType: false,
    success: function () {
      // ...
    }
  })
}
```


#### 扩展：window.URL.createObjectURL

`window.URL.createObjectURL` 的作用是创建一个新的对象 `URL`,该对象 `URL` 可以代表某一个指定的 `File` 对象或 `Blob` 对象

关于 `Bold` 对象，见 [MDN -Bold](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)

大体的意思就是

* `File` 对象,就是一个文件，比如我用 `input type='file'` 标签来上传文件,那么里面的每个文件都是一个 `File` 对象

* `Blob` 对象,就是二进制数据,比如通过 `new Blob()` 创建的对象就是 `Blob` 对象.又比如,在 `XMLHttpRequest` 里,如果指定 `responseType` 为 `blob`,那么得到的返回值也是一个 `blob` 对象

```js
objectURL = window.URL.createObjectURL(blob);
// blob 参数是一个 File 对象或者 Blob 对象
// objectURL 是生成的对象 URL 通过这个 URL，可以获取到所指定文件的完整内容

```

每次调用 `createObjectURL` 的时候，一个新的 `URL` 对象就被创建了，即使你已经为同一个文件创建过一个 `URL`

如果你不再需要这个对象，要释放它，需要使用 `URL.revokeObjectURL()` 方法

当页面被关闭，浏览器会自动释放它，但是为了最佳性能和内存使用，当确保不再用得到它的时候，就应该释放它

利用 `window.URL.createObjectURL` 显示图片：

```html
<input type= 'file' id= 'fileElem' multiple accept= 'image/*' style= 'display:none' onchange= 'handleFiles(this.files)'>
<a href='#' id='fileSelect'>Select some files</a>

<div id='fileList'>
  <p>No files selected!</p>
</div>
```

```js
window.URL = window.URL || window.webkitURL;

var fileSelect = document.getElementById('fileSelect'),
  fileElem = document.getElementById('fileElem'),
  fileList = document.getElementById('fileList');

fileSelect.addEventListener('click', function (e) {
  if (fileElem) {
    fileElem.click();
  }
  e.preventDefault(); // prevent navigation to '#'
}, false);

function handleFiles(files) {
  if (!files.length) {
    fileList.innerHTML = '<p>No files selected!</p>';
  } else {
    fileList.innerHTML = '';
    var list = document.createElement('ul');
    fileList.appendChild(list);
    for (var i = 0; i < files.length; i++) {
      var li = document.createElement('li');
      list.appendChild(li);

      var img = document.createElement('img');
      img.src = window.URL.createObjectURL(files[i]);
      img.height = 60;
      img.onload = function () {
        window.URL.revokeObjectURL(this.src);
      }
      li.appendChild(img);
      var info = document.createElement('span');
      info.innerHTML = files[i].name + ': ' + files[i].size + ' bytes';
      li.appendChild(info);
    }
  }
}
```

如果有现成的 `'img'` 标签

```js
function upLoadImg() {
  var myPic = document.getElementById('myPic').files[0];
  document.getElementsByTagName('img')[0].src = window.URL.createObjectURL(myPic);
}
```


#### 分段读取进度

```js
var bar = document.getElementById('progress-bar');
var progress = document.getElementById('progress');

var input = document.getElementById('file');
var block = 1 * 1024 * 1024; // 每次读取 1M

// 当前文件对象
var file;

// 当前已读取大小
var fileLoaded;

// 文件总大小
var fileSize;

// 每次读取一个 block
function readBlob() {
  var blob;
  if (file.webkitSlice) {
    blob = file.webkitSlice(fileLoaded, fileLoaded + block + 1);
  } else if (file.mozSlice) {
    blob = file.mozSlice(fileLoaded, fileLoaded + block + 1);
  } else if (file.slice) {
    blob = file.slice(fileLoaded, fileLoaded + block + 1);
  } else {
    alert('不支持分段读取！');
    return false;
  }
  reader.readAsBinaryString(blob);
}

// 每个 blob 读取完毕时调用
function loadHandler(e) {
  fileLoaded += e.total;
  var percent = fileLoaded / fileSize;
  if (percent < 1) {
    // 继续读取下一块
    readBlob2();
  } else {
    // 结束
    percent = 1;
  }
  percent = Math.ceil(percent * 100) + '%';
  progress.innerHTML = percent;
  progress.style.width = percent;
}

function fileSelect(e) {
  file = this.files[0];
  if (!file) {
    alert('文件不能为空！');
    return false;
  }
  fileLoaded = 0;
  fileSize = file.size;
  bar.style.display = 'block';
  // 开始读取
  readBlob2();
}

var reader = new FileReader();
// 只需监听 onload 事件

reader.onload = loadHandler;
input.onchange = fileSelect
```


参考：

[leejersey](http://www.cnblogs.com/leejersey/p/4772504.html)

[HTML5 之 FileReader 的使用](http://blog.csdn.net/jackfrued/article/details/8967667)

[JavaScript File API](http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload/)





## promise

在学习 `Node.js` 过程中接触到了如何使用 `async` 来控制并发，`async` 的本质是一个流程控制

其实在异步编程中，还有一个更为经典的模型，叫做 `Promise/Deferred` 模型（当然还有更多相关解决方法，比如 `eventproxy`，`co` 等，到时候遇到在挖坑）

首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容

```js
var fs = require('fs');

fs.readFile('1.txt', 'utf8', function (err, data) {
    console.log(data);
});
```

看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容

```js
var fs = require('fs');

fs.readFile('1.txt', 'utf8', function (err, data) {
  console.log(data);
  fs.readFile('2.txt', 'utf8', function (err, data) {
    console.log(data);
  });
});
```

要是读取更多的文件呢?

```js
var fs = require('fs');
fs.readFile('1.txt', 'utf8', function (err, data) {
  fs.readFile('2.txt', 'utf8', function (err, data) {
    fs.readFile('3.txt', 'utf8', function (err, data) {
      fs.readFile('4.txt', 'utf8', function (err, data) {
        // ...
      });
    });
  });
});
```

这就是传说中的 `callback hell`，可以使用 `async` 来改善这段代码，但是在本例中我们要用 `promise/defer` 来改善它


#### promise 基本概念

首先它是一个对象，它和 `javascript` 普通的对象没什么区别，同时，它也是一种规范，跟异步操作约定了统一的接口，表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的

1. `promise` 只有三种状态，未完成，完成 (`fulfilled`) 和失败 (`rejected`)

2. `promise` 的状态可以由未完成转换成完成，或者未完成转换成失败

3. `promise` 的状态转换只发生一次


`promise` 有一个 `then` 方法，`then` 方法可以接受 `3` 个函数作为参数。**前两个**函数对应 `promise` 的两种状态 `fulfilled`, `rejected` 的回调函数。**第三个**函数用于处理进度信息

为了理解它，一些重要原理必须记牢：`.then()` 总是返回一个新的 `promise`，如下面代码：

```js
var promise = readFile()
var promise2 = promise.then(readAnotherFile, console.error)
```

这里 `then` 的参数 `readAnotherFile`, `console.error` 是代表异步操作成功后的动作 `onFulfilled` 或失败后的动作 `OnRejected`

也就是说，读取文件成功后执行 `readAnotherFile` 函数，否则失败打印记录错误。这种实现是两个中只有一种可能

也可以理解为：

```js
promiseSomething().then(function (fulfilled) {
  // 当 promise 状态变成 fulfilled 时，调用此函数
}, function (rejected) {
  // 当 promise 状态变成 rejected 时，调用此函数
}, function (progress) {
  // 当返回进度信息时，调用此函数
});
```

`Promise` 法则有两部分必须分离：

1. `then()` 总是返回一个**新的** `promise`，每次你调用它，它不管回调做什么，因为 `.then()` 在回调被调用之前已经给了你一个承诺 `promise`，回调的行为只影响承诺 `promise` 的实施，如果回调返回一个值，那么 `promise` 将使用那个值，如果这个值是一个 `promise`，返回这个 `promise` 实施后的值给这个值，如果回调抛出错误，`promise` 将拒绝错误

2. 被 `.then()` 返回的 `promise` 是一个新的 `promise` ，它不同于那些 `.then()` 被调用的 `promise`，`promise` 长长的链条有时会好些隐藏这个事实，不管如何，每次 `.then()` 调用都会产生一个新的 `promise`，这里必须注意的是你真正需要考虑的是你最后调用 `.then()` 可能代表失败，那么如果你不捕获这种失败，那么容易导致你的错误 `exception` 消失




#### Promises/A+ 规范

`promise` 代表一个异步操作的最终结果。主要通过 `promise` 的 `then` 方法订阅其最终结果的处理回调函数，和订阅因某原因无法成功获取最终结果的处理回调函数。

更对详细见：<a href="https://promisesaplus.com/" target="_blank">Promises/A+</a>

`A` 与 `A+` 的不同点

* `-A+` 规范通过术语 `thenable` 来区分 `promise` 对象

* `-A+` 定义 `onFulfilled/onRejectd` 必须是作为函数来调用，而且调用过程必须是异步的

* `-A+` 严格定义了 `then` 方法链式调用时，`onFulfilled/onRejectd` 的调用顺序










## call 和 apply 的第一个参数

`call` 和 `apply` 用来改变函数的执行上下文（`this`），它们的第一个参数 `thisArg` 是个对象，即作为函数内的 `this`

在多数时候你传递什么给函数，那么它就是什么

```js
function fun() {
  alert(this);
}

fun.call(1);                // 1

fun.call('a');              // a

fun.call(true);             // true

fun.call({name: 'aaa'});    // [object Object]
```

有两种情况需要注意，传递 `null` 或 `undefined` 时，执行环境会是全局的（`window/global`）

可以参考[规范 15.3.4.4](http://lzw.me/pages/ecmascript/#323)

```js
fun.call(null);       // window
fun.call(undefined);  // window
```

但是在严格模式下，给 `call` 和 `apply` 传入的任何参数不再会转换

```js
'use strict'
function fun() {
  alert(this);
}

fun.call(null);        // null
fun.call(undefined);   // undefined
```

另外一个例子

```js
function foo(x, y) {
  'use strict';
  console.log(x, y, this);
}

foo.apply(null);        // undefined undefined null
foo.apply(undefined);   // undefined undefined undefined
```
























## 判断是否是数组 isArray

```js
var isArray = function (value) {
  return value && typeof value === "object" && value.constructor === "Array";
}
```

上面这个方法在 从不同的窗口（`window / frame`）里构造的数组的时候会失败，所以我们不得不考虑更多

```js
var isArray = function (value) {
  return value && typeof value === "object"
    && typeof value.length === "number"
    && typeof value.slice === "function"
    && !(value.propertyIsEnumerable("length"));
}
```

首先，我们要判断这个值是否为真，不接受 `null` 和其他为假的值

其次判断 `typeof` 运算的结果是否为 `object`，对于对象，数组和 `null` 来说，返回的是 `true`（但是对于对象来说并非如此）

然后判断这个值是否包含一个 `splice` 的方法，对于数组来说，又将会得到 `true`

最后判断 `length` 属性是否是可枚举的，对于数组来说，将得到 `false`













## 从请求的异步回调函数中取值的解决办法

问题如下

```js
function load_val() {
  $.get('url', function (data) {
    // 如何把这里取到的 data 通过 load_val 函数返回出去？
  });
}
```

如果通过一个全局变量来获取，自然也不是不可以，不过这里就涉及到一点：如果使用了全局变量来获取后，该怎么使用呢？

还是上面这个例子，我们稍微改造一下

```js

var obj = '';

function load_val() {
  $.get('url', function (data) {
    // 在此处将 data 赋予全局变量
    obj = data;
  });
}

// 调用函数获取数据
load_val();

function use_val() {
  obj += 1;
  console.log(obj);
}

use_val();
```

上面这个例子很好理解，我们想通过 `obj` 这个全局变量获取 `ajax` 异步过来的 `data` 数据，然后在 `use_val` 这个函数中使用 `obj` 这个变量

看似没问题，实际上问题很严重

在 `use_val()` 中的 `obj` 真的是 `data` 的值么？答案是否定的，而是 `''`

因为就这段代码而言，`obj = data` 是在 `use_val()` 执行完才在异步回调函数内实现的，在此之前，`obj`一直是 `''`

于是又有人说，那我写个延时函数，等待 `obj = data` 后再执行呗，那样就太不优雅了，那么该如何解决呢？

```js
// 定义一个回调函数
function load_val(callback) {
  $.get('url', function (data) {
    // 将返回结果当作参数通过回调函数返回
    callback(data); 
  });
}

load_val(function (data) {
  // 这里可以得到值
  obj = data; 
  use_val();
});

function use_val() {
  obj += 1;
  console.log(obj);
}
```

也就是在所需要调用的回调函数外加一个函数，这个函数包含一个参数，该参数是个函数，然而这个函数有着依赖于回调函数给出的值的参数，所以经过这两层，就能将原本回调函数里的值给取出来




## 面向对象的五大基本原则

* 单一职责原则 SRP（`Single Responsibility Principle`）

  * 是指一个类的功能要单一，不能包罗万象，如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来

* 开放封闭原则 OCP（`Open－Close Principle`） 

  * 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的，比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能

  * 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来

* 替换原则（`the Liskov Substitution Principle LSP`） 

  * 子类应当可以替换父类并出现在父类能够出现的任何地方，比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工

  * 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了

* 依赖原则（`the Dependency Inversion Principle DIP`） 

  * 具体依赖抽象，上层依赖下层，假设 `B` 是较 `A` 低的模块，但 `B` 需要使用到 `A` 的功能

  * 这个时候，`B`不应当直接使用 `A` 中的具体类，而应当由 `B` 定义一抽象接口，并由 `A` 来实现这个抽象接口，`B` 只使用这个抽象接口
  
  * 这样就达到了依赖倒置的目的，`B` 也解除了对 `A` 的依赖，反过来是 `A` 依赖于 `B` 定义的抽象接口，通过上层模块难以避免依赖下层模块
  
  * 假如 `B` 也直接依赖 `A` 的实现，那么就可能造成循环依赖，一个常见的问题就是编译 `A` 模块时需要直接包含到 `B` 模块的 `cpp` 文件，而编译 `B` 时同样要直接包含到 `A` 的 `cpp` 文件

* 接口分离原则（`the Interface Segregation Principle ISP`） 

  * 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来




## 常用设计模式的实现思路

常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等


#### 单例，任意对象都是单例，无须特别处理

```js
var obj = { name: 'michaelqin', age: 30 };
```


#### 工厂，就是同样形式参数返回不同的实例

```js
function Person() { this.name = 'Person1'; }
function Animal() { this.name = 'Animal1'; }

function Factory() { }

Factory.prototype.getInstance = function (className) {
  return eval('new ' + className + '()');
}

var factory = new Factory();

var obj1 = factory.getInstance('Person');
var obj2 = factory.getInstance('Animal');

console.log(obj1.name); // Person1
console.log(obj2.name); // Animal1
```


#### 代理，就是新建个类调用老类的接口，包一下

```js
function Person() { }

Person.prototype.sayName = function () { console.log('michaelqin'); }
Person.prototype.sayAge = function () { console.log(30); }

function PersonProxy() {
  this.person = new Person();
  var that = this;
  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName);
    // 代理
    that.person[functionName]();
    console.log('after proxy:', functionName);
  }
}

var pp = new PersonProxy();

pp.callMethod('sayName'); // 代理调用 Person 的方法 sayName()
pp.callMethod('sayAge');  // 代理调用 Person 的方法 sayAge()
```


#### 观察者，就是事件模式，比如按钮的 onclick 这样的应用

```js
function Publisher() {
  this.listeners = [];
}

Publisher.prototype = {
  'addListener': function (listener) {
    this.listeners.push(listener);
  },

  'removeListener': function (listener) {
    delete this.listeners[listener];
  },

  'notify': function (obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  }
}; 

// 发布者
function Subscriber() { }

// 订阅者
Subscriber.prototype = {
  'process': function (obj) {
    console.log(obj);
  }
};

var publisher = new Publisher();

publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());

publisher.notify({ name: 'michaelqin', ageo: 30 });          // 发布一个对象到所有订阅者
publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者
```







## JavaScript 异步加载方案

最常见的莫过于 `defer` 与 `async`

#### defer

`HTML4` 为 `script` 标签定义了一个扩展属性 `defer`

`defer` 指明本元素所含的脚本不会修改 `dom`，因此代码能安全地延迟执行，但是该属性并不是一个理想的跨浏览器解决方案，该属性只有 `IE4+` 和 `firefox3.5+` 的浏览器支持，用法如下

```js
<script type='text/javascript' src='test.js' defer></script>
```

带有 `defer` 属性的 `script` 标签可以放置在文档的任何位置，当一个带有 `defer` 属性 `js` 文件下载时，它不会阻塞浏览器的其他进程

因此这类文件可以与页面中的其他资源并行下载，带有 `defer` 属性的 `script` 标签在 `dom` 加载完成（`onload` 事件触发前执行）

#### async 

`HTML5` 规范引入了 `async` 属性，用于异步加载脚本

```js
<script type='text/javascript' src='test.js' async></script>
```

`async` 与 `defer` 的相同点是采用并行下载，在下载的过程中不会产生阻塞，区别在于 `async` 是加载完成后自动执行，而 `defer` 需要等待页面完成后执行

#### 动态创建 script

主要原理 `javascript` 可以动态创建 `HTML` 中几乎所有的内容，所以我们可以利用 `javascript` 动态地创建 `script` 标签并添加到 `HTML` 中

```js
var script = document.createElement('script');

script.type = 'text/javasctipt';
script.src = 'file.js';

document.getElementByTagName('head')[0].appendChild(script)
```

我们可以使用如下方法跟踪并确保脚本下载完成并准备就绪

```js
function loadScript(url, callback) {

  // 创建标签
  var script = document.createElement("script");
  script.type = "text/javasctipt";

  // 如果是 IE
  if (script.readyState) {
    script.onreadystatechange = function () {
      if (script.readyState == 'loaded' || script.readyState == 'complete') {
        script.onreadystatechange = null;
        callback()
      }
    }
  } else {
    script.onload = function () {
      callback();
    }
  }

  // 赋值
  script.src = url;
  document.getElementByTagName("head")[0].appendChild(script)
}
```

调用方法

```js
loadScript('files.js',function(){
  console.log(`file is loaded`);
})
```

#### XMLHttpRequest 脚本注入

还可以通过 `XHR` 对象获取脚本并注入到页面

```js
// 获取 XMLHttpRequest 对象（考虑兼容性）
var getXmlHttp = function () {
  var obj;
  if (window.XMLHttpRequest)
    obj = new XMLHttpRequest();
  else
    obj = new ActiveXObject('Microsoft.XMLHTTP');
  return obj;
};

// 采用 Http 请求 get 方式，open() 方法的第三个参数表示采用异步（true）还是同步（false）来进行处理
var xmlHttp = getXmlHttp();
xmlHttp.open('GET', 'file3.js', true);

xmlHttp.onreadystatechange = function () {
  if (xmlHttp.readyState == 4) {
    if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 304) {
      var script = document.createElement('script');
      script.text = xmlHttp.responseText;
      document.body.appendChild(script);
    }
  }
}

xmlHttp.send(null);
```







## 简易事件模型

简单来说就是一个定顺序触发相应的响应函数

大致实现思路就是创建一个类或是匿名函数，在 `bind` 和 `trigger` 函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表

`bind` 时，如果字典没有则创建一个，`key` 是事件名称，`value` 是数组，里面放着当前注册的响应函数

如果字段中有，那么就直接 `push` 到数组即可，`trigger` 时调出来依次触发事件响应函数即可

不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用 `trigger` 的参数列表都传到响应函数中还要考虑到把 `arguments` 对象转化为纯数组才行等等


```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName];

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例
var emitter = new Emitter();

emitter.on('event', function (arg1, arg2) {
  console.log('get event', arg1, arg2);
})

console.log('emit event');
emitter.emit('event', 'arg1', 'arg2');
```




## 关于 'use strict'

严格模式是 `ECMAScript 5` 中的一项新特征，允许你把一段程序或功能放置在 `'strict'` 工作环境中，这种严格上下文环境防止某些行为被采取并引发更多的异常

严格的模式有助于几个方面

* 它捕获了一些常见的编码错误，抛出异常

* 它阻止，或抛出错误，当相对'不安全'的行为被采用（例如获取全局对象）

* 它禁用那些混淆的或者考虑不周的特征

```js
// 非严格的代码...

(function () {
  'use strict';

  // 严格定义你的库...
})();

// 非严格的代码
```



## 检测是否有元素被隐藏

```js
// 检查 display: [none | block], 忽略 visible: [true | false]
$(element).is(":visible");

// 匹配的是隐藏的所有元素
$('element:hidden')

// 匹配所有可见的元素
$('element:visible')
```



## 鼠标长按事件

只要长按时间到达 `1000` 毫秒，无论是否弹起鼠标，都会触发，反之如果不到 `1000` 毫秒，鼠标弹起的时候会结束

```js
// 申明全局变量
var timeStart, timeEnd, time;

// 获取此刻时间
function getTimeNow() {
  var now = new Date();
  return now.getTime();
}

// 鼠标按下时触发
function holdDown() {
  // 获取鼠标按下时的时间
  timeStart = getTimeNow();

  // setInterval 会每 100 毫秒执行一次，也就是每 100 毫秒获取一次时间
  time = setInterval(function () {
    timeEnd = getTimeNow();

    // 如果此时检测到的时间与第一次获取的时间差有 1000 毫秒
    if (timeEnd - timeStart > 1000) {
      // 便不再继续重复此函数 （clearInterval 取消周期性执行）
      clearInterval(time);
      // 字体变红
      // 一些逻辑
    }
  }, 100);
}

function holdUp() {
  // 如果按下时间不到 1000 毫秒便弹起
  clearInterval(time);
}
```







## 如何判断一个对象是否为空

1. 最常见的思路，`for...in` 遍历属性，为真则为'非空数组'，否则为'空数组'

```js
// 如果不为空，则会执行到这一步，返回 true
for (var i in obj) {
  return true
}

// 如果为空，返回 false
return false 
```

2. 通过 `JSON` 自带的 `stringify()` 方法来判断

`JSON.stringify()` 方法用于将 `JavaScript` 值转换为 `JSON` 字符串

```js
if (JSON.stringify(data) === '{}') {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```

这里需要注意为什么不用 `toString()`，因为它返回的不是我们需要的

```js
var a = {}
a.toString() // "[object Object]"
```


3. `ES6` 新增的方法 `Object.keys()`

`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举属性组成的数组

如果我们的对象为空，他会返回一个空数组，如下

```js
var a = {}
Object.keys(a) // []
```

我们可以依靠 `Object.keys()` 这个方法通过判断它的长度来知道它是否为空

```js
if (Object.keys(object).length === 0) {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```


## 如何快速判断 DOM 元素位于 viewport 以外

```js
ele.getBoundingClientRect().top > window.innerHeight  // 元素在当前屏下面

ele.getBoundingClientRect().bottom < 0                // 元素在当前屏上面
```





## 检测对象改变的几种方式

方法一，可以通过 getter 和 setter 实现

```js
var obj = {
  get foo() {
    console.log({ name: 'foo', object: obj, type: 'get' });
    return obj._foo;
  },
  set bar(val) {
    console.log({ name: 'bar', object: obj, type: 'set', oldValue: obj._bar });
    return obj._bar = val;
  }
};

obj.bar = 2;
// {name: "bar", object: {_bar: 2}, type: "set", oldValue: undefined}

obj.foo;
// {name: "foo", object: <_bar: 2>, type: 'get'}
```

方法二，在支持 Proxies（代理）的浏览器中更为通用的方法

```js
var obj = {
  foo: 1,
  bar: 2
}

var proxied = new Proxy(obj, {
  get: function (target, prop) {
    console.log({ type: 'get', target, prop });
    return Reflect.get(target, prop);
  },
  set: function (target, prop, value) {
    console.log({ type: 'set', target, prop, value });
    return Reflect.set(target, prop, value);
  }
})

proxied.bar = 2;
// {type: "set", target: { foo: 1, bar: 2 }, prop: "bar", value: 2}

proxied.foo;
// {type: "get", target: { foo: 1, bar: 2 }, prop: "foo"}
```

方法三，使用 Object.defineProperties

```js
var obj = Object.defineProperties({}, {
  'foo': {
    get: function () {
      console.log('Get Foo: ' + this.value);
    },
    set: function (val) {
      console.log('Set Foo: ' + val);
      this.value = val;
    }
  },

  'bar': {
    get: function () {
      console.log('Get Bar: ' + this.value);
    },
    set: function (val) {
      console.log('Set Bar: ' + val);
      this.value = val;
    }
  }
});

obj.foo = 2;
// Set Foo: 2

obj.bar;
// Get Bar: undefined
```












## Property 'style' does not exist on type 'Element'

这个问题一般会在 `TS` 当中使用 `document.querySelector` 去获取元素的时候发生

根据规范可知（[MDN Element 规范](https://developer.mozilla.org/en-US/docs/Web/API/Element)），`Element` 接口确实没有 `style` 属性

如果不是用来操作 `SVG` 元素，而是仅仅使用 `TS` 的话，可以像下面这样操作

```js
(document.querySelector('xxx') as HTMLElement).style.color = 'red';
```





## table 表单中的 .rows 属性

如下

```js
var tr = cartTable.children[1].rows;
```

为表单元素特有的属性，存放节点所有的 `tr` 元素，操作的话可以使用如下方式

```js
price += tr[i].cells[4].innerHTML
```

> `cells` 也是 表单元素特有的属性，里面存放的是这个表格没一行下面的所有的单元格，也就是 `td` 元素，也就是说这一行下面所有的 `td`





## offsetLeft 与 style.left 的区别

`offsetLeft` 获取的是相对于父对象的左边距

`left` 获取或设置相对于 具有定位属性（`position` 定义为 `relative`）的父对象的左边距

如果父 `div` 的 `position` 定义为 `relative`，子 `div` 的 `position` 定义为 `absolute`

那么子 `div` 的 `style.left` 的值是相对于父 `div` 的值，这同 `offsetLeft` 是相同的，区别在于

* `style.left` 返回的是字符串，如 `28px`，`offsetLeft` 返回的是数值 `28`，如果需要对取得的值进行计算，还用 `offsetLeft` 比较方便

* `style.left` 是读写的，`offsetLeft` 是只读的，所以要改变 `div` 的位置，只能修改 `style.left`

* `style.left` 的值需要事先定义，否则取到的值为空，而且必须要定义在 `html` 里,如果定义在 `css` 里，`style.left` 的值仍然为空

`offsetLeft` 则仍然能够取到，无需事先定义 `div` 的位置



## Reflect 对象

`Reflect` 对象与 `Proxy` 对象一样，也是 `ES6` 为了操作对象而提供的新 `API`

简单来说两点，一个就是将 `Object` 对象的一些明显属于语言内部的方法（比如 `Object.defineProperty`），放到 `Reflect` 对象上

另一个就是让 `Object` 操作都变成函数行为，因为 `ES5` 很多 `Object` 操作都是命令式的（另外一个原因就是这些方法可能是全局的，或者要通过原型来调用，统一起来）

这里只简单的介绍几个常用的方法，详细的可见 [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/reflect) 和 [Reflect - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)


#### Reflect.apply(target, thisArgument, argumentsList)

与 `ES5` 的 `Function.prototype.apply` 方法是类似的

比如查找数组中最大数

```js
// ES6 
Reflect.apply(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5

// ES5
Math.max.apply(undefined, [1, 2, 3, 4, 5]);  // 5

Function.prototype.apply.call(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5
```

切割字符串

```js
// ES6 
Reflect.apply(String.prototype.slice, 'hello world', [2, 8]);  // "llo wo"

// ES5 
'hello world'.slice(2, 8);  // "llo wo"

String.prototype.slice.apply('hello world', [2, 8]);  // "llo wo"
```



#### Reflect.construct(target, argumentsList[, newTarget])

与使用 ·new target(...args)· 方法类似，相当于提供了一种新的不使用 ·new· 来调用构造函数的方法

* `target` 表示被运行的目标函数

* `argumentsList` 调用构造函数传递的参数数组或者伪数组

* `newTarget` 参数为构造函数，表示使用 `Reflect.construct` 后生成的对象是谁的实例

* 如果没有传递第三个参数，默认和 `target` 一样

如果没有传递第三个参数，那么 `target` 就是唯一的构造函数，但是如果传递了第三个参数，那就表示实例将由两部分组成，实力的属性部分（constructor）由第一个参数部分生成，实例的方法部分由第三个参数生成

```js
class A1 {
  constructor(name) {
    console.log('Class A1 is invoked!');
    this.name = name;
  }
  getName() {
    console.log(this.name);
    return this.name;
  }
}

class B1 {
  constructor(age) {
    console.log('Class B1 is invoked!');
    this.age = age;
  }
  getAge() {
    console.log(this.age);
    return this.age;
  }
}

// 使用 A1 类作为构造函数
let a1 = Reflect.construct(A1, ['happy']);

// 使用 B1 类作为构造函数
let b1 = Reflect.construct(A1, ['happy'], B1);

console.log(a1);
console.log(b1);

// A1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class A1
//     getName: ƒ getName()
//     __proto__: Object

// B1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class B1
//     getAge: ƒ getAge()
//     __proto__: Object
```



#### Reflect.defineProperty(target, propertyKey, attributes)

与 `Object.defineProperty` 相似，不过如果 `Object.defineProperty` 的属性定义失败了，就会抛出一个错误，而 `Reflect.defineProperty` 如果定义属性失败的话就会返回 `false`

```js
let obj = {};

let result = Reflect.defineProperty(obj, 'name', {
  configurable: true,
  enumerable: true,
  value: 'happy'
});

console.log(result)  // true
```



#### Reflect.getPrototypeOf(target)

与 `Object.getPrototypeOf` 方法是一样的，都是返回一个对象的原型，也就是内部的 `[[Prototype]]` 属性的值

如果要获取原型的那个值不是一个对象，那么函数 `Reflect.getPrototypeOf` 会抛出一个异常

对于给定对象的原型，如果没有继承的属性，则返回 `null`



#### Reflect.ownKeys(target)

返回由目标对象自身的属性键组成的数组，包括 `symbol` 的值

```js
let a = Symbol.for('a');
let b = Symbol.for('b');

let obj = {
  [a]: 10,
  [b]: 20,
  key1: 30,
  key2: 40
};

let arr1 = Object.getOwnPropertyNames(obj);
console.log(arr1); // [ 'key1', 'key2' ]

let arr2 = Object.getOwnPropertySymbols(obj);
console.log(arr2); // [ Symbol(a), Symbol(b) ]

let arr3 = Reflect.ownKeys(obj);
console.log(arr3); // [ 'key1', 'key2', Symbol(a), Symbol(b) ]
```













