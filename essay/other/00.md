## 缓存穿透和缓存雪崩

分布式缓存系统面临的问题

#### 缓存一致性问题

* 缓存系统与底层数据的一致性

  * 这点在底层系统是 "可读可写" 时，写得尤为重要 

* 有继承关系的缓存之间的一致性

  * 为了尽量提高缓存命中率，缓存也是分层的，分为全局缓存和二级缓存，他们是存在继承关系的，全局缓存可以有二级缓存来组成

* 多个缓存副本之间的一致性

  * 为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如 ```MemCache```，```Redis``` 等）

#### 缓存穿透和缓存雪崩

* **缓存穿透**

  * 一般的缓存系统，都是按照 ```key``` 去缓存查询，如果不存在对应的 ```value```，就应该去后端系统查找（比如 ```DB```），如果 ```key``` 对应的 ```value``` 是一定不存在的，并且对该 ```key``` 并发请求量很大，就会对后端系统造成很大的压力，这就叫做**缓存穿透**
 
* **如何避免**

  * 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 ```key``` 对应的数据 `insert` 了之后清理缓存

  * 对一定不存在的 ```key``` 进行过滤，可以把所有的可能存在的 ```key``` 放到一个大的 ```Bitmap``` 中，查询时通过该 ```Bitmap``` 过滤


* **缓存雪崩**


  * 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如 ```DB```）带来很大压力


* **如何避免**


* 在缓存失效后，通过**加锁**或者队列来控制读数据库写缓存的线程数量，比如对某个 ```key``` 只允许一个线程查询数据和写缓存，其他线程等待

* 不同的 ```key``` ，设置不同的过期时间，让缓存失效的时间点尽量均匀

* 做二级缓存，```A1``` 为原始缓存，```A2``` 为拷贝缓存，```A1``` 失效时，可以访问 ```A2```，```A1``` 缓存失效时间设置为短期，```A2``` 设置为长期（此点为补充）

 
#### 缓存数据的淘汰

策略有两种： 

* 定时去清理过期的缓存

* 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存

两者各有优劣，第一种的缺点是维护大量缓存的 ```key``` 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，可以根据自己的应用场景来权衡
 
* 预估失效时间 

* 版本号（必须单调递增，时间戳是最好的选择）

* 提供手动清理缓存的接口



## 进程与线程

对于操作系统来说，一个任务就是进程（`Process`），比如打开一个浏览器就是启动了一个浏览器进程，打开一个记事本就启动了一个记事本进程

有些进程还不止同时干一件事，比如 `Word`，它可以同时进行打字、拼写检查，打印等，在一个进程的内部，要同时干多件事，就需要同时运行多个 "子任务"，我们把进程内的这些 "子任务" 称为线程（`Thread`）

由于每个进程至少要干一件事，所以，一个进程至少有一个线程，当然也可以有多个，也可以多个线程同时执行

> 简单来说就是，线程是最小的执行单元，而进程由至少一个线程组成

#### 关系和共性

* 关系：进程中包含着至少一个线程

  * 在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程
  
  * 但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作，在整个进程完成工作之后，其中的线程会被销毁，释放资源

* 共性：都包含三个状态，就绪、阻塞、运行

  * 阻塞就是资源未到位，等待资源中
  
  * 就绪，就是资源到位了，但是 ```CPU``` 未到位，还在运行其他

#### 线程的好处

之所以设置线程这个单位

* 在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型

* 线程较进程来讲，更轻

* 线程虽然微观并行，但是在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞，提高了 ```CPU``` 的利用率



## JavaScript 中的单线程执行机制

#### 单线程和多线程

* 本质上指在**一个进程内**的单线程和多线程

* 单线程：单线程就是一个进程中只有一个线程，程序顺序执行，前面的执行完，才会执行后面的程序

* 多线程：多线程就是一个进程中只有多个线程，在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的

#### JavaScript 中的单线程执行机制

```JavaScript``` 的单线程本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中，但是浏览器是**事件驱动**的、**异步**的、**多线程**的

浏览器内部有一个事件轮询（```event loop```），是一个大的内部消息循环，会轮询大的消息队列，并执行，也就是 ```JavaScript``` 要处理的事件队列，是浏览器维护的

浏览器至少有四个线程（不同浏览器会有差异）：```JavaScript``` 引擎线程、界面渲染线程、浏览器事件触发线程、```http``` 请求线程

#### setTimeout 和 ajax

* ```setTimeout```：```JavaScript``` 在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由 ```JavaScript``` 引擎执行，都是在浏览器空闲了才会执行

* ```ajax```：是真正的异步，在调用 ```ajax``` 的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中，再由 ```JavaScript``` 引擎执行


## JavaScript 中的阻塞

浏览器虽然是多线程，但是由于 ```JavaScript``` 具有阻塞特性（比如 ```alert```），无论外链还是内嵌脚本，在浏览器执行解释 ```JavaScript``` 脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到 ```JavaScript``` 下载并执行完毕

这样一来，```JavaScript``` 脚本的下载、解释执行，会反使页面的继续绘制，给用户带来不良的体验，所以避免此类情况的话可以

* 将 ```<script>``` 内嵌和外链，在可以的情况下，放在 ```<body>``` 底部（对于 ```css```，浏览器是并行下载）

* 在页面 ```onload``` 后，加载 ```JavaScript```

* 可以使用 ```html5``` 的  ```<script>```标签的```defer```属性，在页面加载完成后下载

* 使用创建 ```<script>``` 标签的方式，在页面加载完成后添加进去（createElement）

简单来说就是一句话，先让页面渲染完，再加载 ```JavaScript```

> ```Node.js``` 的运行机制是基于事件轮询 （```event loop```）



## 关于线程同步

线程同步是指多线程通过特定的东西（如互斥量）来控制线程之间的执行顺序（同步），也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步那线程之间是各自运行各自的

#### 方式和机制

主要有临界区（```Critical Section```）、互斥量（```Mutex```）、信号量（```Semaphore```）、事件（```Event```）四种方式，区别如下：

* 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问，在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占

* 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问，互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享

* 信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

* 事件：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作


## 数据库中的事务和锁

#### 事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消，也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做

事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交，如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作

#### 事务的 ACID 

* A （```Atomicity```）  原子性

事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行

* C （```Consistency```） 一致性

事务在完成时，必须使所有的数据都保持一致状态，在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性，事务结束时，所有的内部数据结构（如 ```B``` 树索引或双向链表）都必须是正确的

* I （```Isolation```）   隔离性 

并发事务所做的修改必须与任何其他并发事务所做的修改隔离，事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态，事务不会识别中间状态的数据

* D （```Durability```）  持久性

事务完成之后，它对于系统的影响是永久性的，该修改即使出现系统故障也将一直保持


#### 锁

在事务获取数据块当前状态的依赖关系（比如通过读取或修改数据）之前，它必须保护自己不受其他事务对同一数据进行修改的影响，事务通过请求锁定数据块来达到此目的，锁有多种模式，如共享或独占

锁模式定义了事务对数据所拥有的依赖关系级别，如果某个事务已获得特定数据的锁，则其他事务不能获得会与该锁模式发生冲突的锁，如果事务请求的锁模式与已授予同一数据的锁发生冲突，则数据库引擎实例将暂停事务请求直到第一个锁释放

引入锁的机制主要是用来处理多个用户同时对数据库的并发操作时会带来以下几种数据不一致的问题（四大冲突问题）

* 脏读

  * 某个事务读取的数据是另一个事务正在处理的数据，而另一个事务可能会回滚，造成第一个事务读取的数据是错误的

* 不可重复读

  * 在一个事务里两次读入数据，但另一个事务已经更改了第一个事务涉及到的数据，造成第一个事务读入旧数据

* 幻读

  * 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据，那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样

* 更新丢失

  * 多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失


#### 锁模式

* 共享锁

  * 共享锁（```S``` 锁）允许并发事务在封闭式并发控制下读取 （```SELECT```）资源，资源上存在共享锁（```S``` 锁）时，任何其他事务都不能修改数据，读取操作一完成，就立即释放资源上的共享锁（```S``` 锁），除非将事务隔离级别设置为可重复读或更高级别，或者在事务持续时间内用锁定提示保留共享锁（```S``` 锁）

* 更新锁（```U``` 锁）

  * 更新锁在共享锁和排他锁的杂交，更新锁意味着在做一个更新时，一个共享锁在扫描完成符合条件的数据后可能会转化成排他锁

  * 这里面有两个步骤：

    * 扫描获取 ```Where``` 条件时，这部分是一个更新查询，此时是一个更新锁

    * 如果将执行写入更新，此时该锁升级到排他锁，否则，该锁转变成共享锁

  * 更新锁可以防止常见的死锁

* 排他锁

  * 排他锁（```X``` 锁）可以防止并发事务对资源进行访问，排他锁不与其他任何锁兼容，使用排他锁（```X``` 锁）时，任何其他事务都无法修改数据，仅在使用 ```NOLOCK``` 提示或未提交读隔离级别时才会进行读取操作




## JavaScript 中的栈和堆

首先要先说一下耳熟能详的「堆栈」，要区分数据结构和内存中各自「堆栈」的含义

数据结构中的堆和栈是两种不同的、数据项按序排列的数据结构，这里主要介绍的是内存中的堆区与栈区

#### 内存中的堆区与栈区

在 `C` 语言中，各个区的区别如下

* 栈区是分配局部变量的空间

* 堆区是地址向上增长的用于分配我们申请的内存空间

* 另外还有静态区是分配静态变量、全局变量空间的

* 只读区是分配常量和程序代码空间的

一个简单的例子

```c#
int a = 0;                  // 全局初始化区
char *p1;                   // 全局未初始化区

main() {
  int b;                    // 栈
  char s[] = "abc";         // 栈
  char *p2;                 // 栈
  char *p3 = "123";         // 在常量区，p3 在栈上
  static int c =0；         // 全局（静态）初始化区
  p1 = (char *)malloc(10);  // 堆
  p2 = (char *)malloc(20);  // 堆
}
```

而 `JavaScript` 是高级语言，底层依靠 `C/C++` 来编译实现，其变量划分为基本数据类型和引用数据类型

基本数据类型包括 `Undefined`，`Null`，`Boolean`，`Number`、`String`

这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值访问、拷贝和比较

引用类型包括 `object`，`array`，`function`，`error`，`date`

这些类型大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的（和 `C` 语言的指针类似）

对于引用类型的变量，栈内存中存放的只是该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存在栈内存中

但是内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中

这样一来，当查询引用类型的变量的时候，就会先从栈中读取堆内存地址，然后在根据地址取出对应的值

显而易见的是，`JavaScript` 中所有引用类型创建实例的时候，都是显示或者隐式的 `new` 出对应类型的实例，实际上就是对应 `C` 语言的 `malloc` 分配内存函数


#### 栈和队列的区别

* 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的

* 队列先进先出，栈先进后出

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除


#### 栈和堆的区别

* 栈区（`stack`） -- 由编译器自动分配释放，存放函数的参数值，局部变量的值等

* 堆区（`heap`） -- 一般由程序员分配释放，若程序员不释放，程序结束时可能由 `OS` 回收

* 堆（数据结构）：堆可以被看成是一棵树，如：堆排序

* 栈（数据结构）：一种先进后出的数据结构








## 字符编码

这里主要介绍 `ASCII`，`UTF-8`，`GBK`，`GB2312` 和 `Unicode`

#### ASCII

由于计算机是美国人发明的，因此，最早只有 `127` 个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 `ASCII` 编码，比如大写字母 `A` 的编码是 `65`，小写字母 `z` 的编码是 `122`

但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和 `ASCII` 编码冲突

#### Unicode 编码

因此，`Unicode` 应运而生，`Unicode` 把所有语言都统一到一套编码里，`Unicode` 只是一个符号集，`Unicode` 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求

我们常见的 `UTF-8` 就是 `Unicode` 其中一个**实现方式**（还有 `utf-16`、`utf-10` 等）


#### UTF-8 编码

`ASCII` 编码是 `1` 个字节，而 `Unicode` 编码通常是 `2` 个字节，如果统一成 `Unicode` 编码，乱码问题从此消失了

但是，如果你写的文本基本上全部是英文的话，用 `Unicode` 编码比 `ASCII` 编码需要多一倍的存储空间，在存储和传输上就十分不划算

因此，又出现了把 `Unicode` 编码转化为 "可变长编码" 的 `UTF-8` 编码，`UTF-8` 编码把一个 `Unicode` 字符根据不同的数字大小编码成 `1 - 6` 个字节，常用的英文字母被编码成 `1` 个字节，汉字通常是 `3` 个字节，只有很生僻的字符才会被编码成 `4 - 6` 个字节

再次强调：**unicode 是一种编码方式，和 ASCII 是同一个概念，而 UTF-8，UTF-16 等是一种存储方式，在存储和传输上节约空间、提高性能的一种编码形式**


#### GBK 和 GB2312

总体说来，`GBK` 包括所有的汉字，包括简体和繁体，而 `GB2312` 则只包括简体汉字

`GBK` 是 `GB2312` 的扩展，除了兼容 `GB2312` 外，它还能显示繁体中文，还有日文的假名


## JavaScript 中的垃圾回收机制

> 《JavaScript 权威指南》

* 由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配

* `JavaScript` 程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体

* 只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，`JavaScript` 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃

现在各大浏览器通常用采用的垃圾回收有两种方法：**标记清除**、**引用计数**

#### 标记清除

这是 `javascript` 中最常用的垃圾回收方式

当变量进入执行环境是，就标记这个变量为 "进入环境"，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们，当变量离开环境时，则将其标记为 "离开环境"

#### 引用计数

另一种不太常见的垃圾回收策略是引用计数（有时候会造成内存泄漏，一般发生在循环引用）

引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 `1`

相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 `1`

当这个引用次数变成 `0` 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来

这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 `0` 的值所占的内存




## GIT 和 SVN 的区别

#### GIT 是分布式的，SVN 不是

`GIT` 跟 `SVN` 一样有自己的集中式版本库或服务器，但 `GIT` 更倾向于被使用于分布式模式，也就是每个开发人员从 中心版本库/服务器 上 `chect out` 代码后会在自己的机器上克隆一个自己的版本库，当遇到没有网络的环境时，仍然能够提交文件，查看历史版本记录，创建项目分支等

#### GIT 把内容按元数据方式存储，而 SVN 是按文件

所有的资源控制系统都是把文件的元信息隐藏在一个类似 `.svn`，`.cvs` 等的文件夹里，`.git` 目录是是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等

#### GIT 分支和 SVN 的分支不同

`SVN` 如果想知道是否合并了一个分支，需要手工运行像这样的命令 `svn propget svn:mergeinfo`，来确认代码是否被合并，所以，经常会发生有些分支被遗漏的情况

`GIT` 的分支可以从同一个工作目录下快速的在几个分支间切换，你很容易发现未被合并的分支，你能简单而快捷的合并这些文件

#### GIT 没有一个全局的版本号，而 SVN 有

`SVN` 的版本号实际是任何一个相应时间的源代码快照

#### GIT 的内容完整性要优于 SVN

`GIT` 的内容存储使用的是 `SHA-1` 哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏


## 面向对象的五大基本原则

* 单一职责原则 SRP（`Single Responsibility Principle`）

  * 是指一个类的功能要单一，不能包罗万象，如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来

* 开放封闭原则 OCP（`Open－Close Principle`） 

  * 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的，比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能

  * 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来

* 替换原则（`the Liskov Substitution Principle LSP`） 

  * 子类应当可以替换父类并出现在父类能够出现的任何地方，比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工

  * 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了

* 依赖原则（`the Dependency Inversion Principle DIP`） 

  * 具体依赖抽象，上层依赖下层，假设 `B` 是较 `A` 低的模块，但 `B` 需要使用到 `A` 的功能

  * 这个时候，`B`不应当直接使用 `A` 中的具体类，而应当由 `B` 定义一抽象接口，并由 `A` 来实现这个抽象接口，`B` 只使用这个抽象接口
  
  * 这样就达到了依赖倒置的目的，`B` 也解除了对 `A` 的依赖，反过来是 `A` 依赖于 `B` 定义的抽象接口，通过上层模块难以避免依赖下层模块
  
  * 假如 `B` 也直接依赖 `A` 的实现，那么就可能造成循环依赖，一个常见的问题就是编译 `A` 模块时需要直接包含到 `B` 模块的 `cpp` 文件，而编译 `B` 时同样要直接包含到 `A` 的 `cpp` 文件

* 接口分离原则（`the Interface Segregation Principle ISP`） 

  * 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来




## 常用设计模式的实现思路

常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等


#### 单例，任意对象都是单例，无须特别处理

```js
var obj = { name: 'michaelqin', age: 30 };
```


#### 工厂，就是同样形式参数返回不同的实例

```js
function Person() { this.name = 'Person1'; }
function Animal() { this.name = 'Animal1'; }

function Factory() { }

Factory.prototype.getInstance = function (className) {
  return eval('new ' + className + '()');
}

var factory = new Factory();

var obj1 = factory.getInstance('Person');
var obj2 = factory.getInstance('Animal');

console.log(obj1.name); // Person1
console.log(obj2.name); // Animal1
```


#### 代理，就是新建个类调用老类的接口，包一下

```js
function Person() { }

Person.prototype.sayName = function () { console.log('michaelqin'); }
Person.prototype.sayAge = function () { console.log(30); }

function PersonProxy() {
  this.person = new Person();
  var that = this;
  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName);
    // 代理
    that.person[functionName]();
    console.log('after proxy:', functionName);
  }
}

var pp = new PersonProxy();

pp.callMethod('sayName'); // 代理调用 Person 的方法 sayName()
pp.callMethod('sayAge');  // 代理调用 Person 的方法 sayAge()
```


#### 观察者，就是事件模式，比如按钮的 onclick 这样的应用

```js
function Publisher() {
  this.listeners = [];
}

Publisher.prototype = {
  'addListener': function (listener) {
    this.listeners.push(listener);
  },

  'removeListener': function (listener) {
    delete this.listeners[listener];
  },

  'notify': function (obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  }
}; 

// 发布者
function Subscriber() { }

// 订阅者
Subscriber.prototype = {
  'process': function (obj) {
    console.log(obj);
  }
};

var publisher = new Publisher();

publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());

publisher.notify({ name: 'michaelqin', ageo: 30 });          // 发布一个对象到所有订阅者
publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者
```