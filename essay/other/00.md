


## GIT 和 SVN 的区别

#### GIT 是分布式的，SVN 不是

`GIT` 跟 `SVN` 一样有自己的集中式版本库或服务器，但 `GIT` 更倾向于被使用于分布式模式，也就是每个开发人员从 中心版本库/服务器 上 `chect out` 代码后会在自己的机器上克隆一个自己的版本库，当遇到没有网络的环境时，仍然能够提交文件，查看历史版本记录，创建项目分支等

#### GIT 把内容按元数据方式存储，而 SVN 是按文件

所有的资源控制系统都是把文件的元信息隐藏在一个类似 `.svn`，`.cvs` 等的文件夹里，`.git` 目录是是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等

#### GIT 分支和 SVN 的分支不同

`SVN` 如果想知道是否合并了一个分支，需要手工运行像这样的命令 `svn propget svn:mergeinfo`，来确认代码是否被合并，所以，经常会发生有些分支被遗漏的情况

`GIT` 的分支可以从同一个工作目录下快速的在几个分支间切换，你很容易发现未被合并的分支，你能简单而快捷的合并这些文件

#### GIT 没有一个全局的版本号，而 SVN 有

`SVN` 的版本号实际是任何一个相应时间的源代码快照

#### GIT 的内容完整性要优于 SVN

`GIT` 的内容存储使用的是 `SHA-1` 哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏





## 面向对象的五大基本原则

* 单一职责原则 SRP（`Single Responsibility Principle`）

  * 是指一个类的功能要单一，不能包罗万象，如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来

* 开放封闭原则 OCP（`Open－Close Principle`） 

  * 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的，比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能

  * 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来

* 替换原则（`the Liskov Substitution Principle LSP`） 

  * 子类应当可以替换父类并出现在父类能够出现的任何地方，比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工

  * 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了

* 依赖原则（`the Dependency Inversion Principle DIP`） 

  * 具体依赖抽象，上层依赖下层，假设 `B` 是较 `A` 低的模块，但 `B` 需要使用到 `A` 的功能

  * 这个时候，`B`不应当直接使用 `A` 中的具体类，而应当由 `B` 定义一抽象接口，并由 `A` 来实现这个抽象接口，`B` 只使用这个抽象接口
  
  * 这样就达到了依赖倒置的目的，`B` 也解除了对 `A` 的依赖，反过来是 `A` 依赖于 `B` 定义的抽象接口，通过上层模块难以避免依赖下层模块
  
  * 假如 `B` 也直接依赖 `A` 的实现，那么就可能造成循环依赖，一个常见的问题就是编译 `A` 模块时需要直接包含到 `B` 模块的 `cpp` 文件，而编译 `B` 时同样要直接包含到 `A` 的 `cpp` 文件

* 接口分离原则（`the Interface Segregation Principle ISP`） 

  * 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来


