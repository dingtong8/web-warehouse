## 在有序（无序）列表中插入 3 个，300 个，3000 个 li，并绑定事件

基本模版如下

```html
<ul id='list'></ul>
```

#### 插入 3 个 li

```js
// ...

for (var i = 0; i < 3; i++) {
  var item = document.createElement('li');
  item.innerText = i + 1;
  item.addEventListener('click', function () {
    alert(this.innerText)
  }, false)
  body.appendChild(item)
}

// ...
```

#### 插入 300 个 li，并且绑定点击事件

这个时候可以使用事件委托

```js
// ...

for (var i = 0; i < 300; i++) {
  var item = document.createElement('li');
  item.innerText = i + 1;
  ul.appendChild(item)
}

ul.addEventListener('click', function (e) {
  if (e.target.tagName === 'LI') {
    alert(target.innerHTML)
  }
}, false)

// ...
```

#### 插入 3000 个 li，并且绑定点击事件

当数据量很大的时候，这个时候可以使用 ```fragment + requestAnimationFrame``` 来分批插入数据

目的是减少 ```DOM``` 操作次数、缩短循环时间，每次插入的时机是在页面重新渲染之前

```js
var total = 3000;

// 每次插入多少
var listSize = 4;

// 分多少次插入
var listCount = total / listSize;

// 已经完成的批次
var listDone = 0;

function appendItems() {
  var fragment = document.createDocumentFragment();

  for (let i = 0; i < listSize; i++) {
    var item = document.createElement('li');
    item.innerText = (listSize * listDone + i) + 1;
    fragment.appendChild(item)
  }

  // 每批次只修改一次 DOM
  ul.appendChild(fragment)

  listDone += 1;
  listAppend()
}

function listAppend() {
  if (listDone < listCount) {
    window.requestAnimationFrame(appendItems);
  }
}

listAppend()

ul.addEventListener('click', function (e) {
  if (e.target.tagName === 'LI') {
    alert(this.innerHTML)
  }
}, false)
```


## 生成一个 20 X 12 的表格，并且设定指定格子的背景颜色

核心代码如下

```html
<style>
  td {
    border: 1px solid red;
    margin: 10px;
    width: 20px;
    height: 20px;
  }
</style>

<body>

  <table id="box"></table>

  <script>
    "use strict";

    var table = document.getElementById("box");

    var result = [];
    for (var i = 0; i < 20; i++) {
      var temp = [];
      var tr = document.createElement("tr");
      for (var j = 0; j < 12; j++) {
        var td = document.createElement("td");
        tr.appendChild(td);
        temp.push(td);
      }
      result.push(temp);
      table.appendChild(tr);
    }

    // 这个表示第三行第三列的表格颜色为红色
    // 因为下标是从 0 开始的
    result[2][2].style.background = "red";
  </script>
</body>
```

## 正则中的 test() 与 全局选项 /g

先看一个示例：

```js
var i = 0, m = 20, a = [], r = /^\d+$/g;

for (i = 0; i < m; i++) {
  a.push('' + i);
}

m = a.length;

for (i = 0; i < m; i++) {
  if (r.test(a[i])) {
    document.write(a[i] + 'true<br />');
  } else {
    document.write(a[i] + 'false<br />');
  }
}
```

也许你期待的结果应该全是 `true`，可是实际结果呢？

`true` 和 `false` 交替出现，0 是 `true`，1 是 `false`，2 是 `true`，3 是 `false`……

解决办法也很简单，把正则表达式中的全局选项 `'g'`，去掉就好了

可是为什么有 `'g'` 就会出错呢？

原因其实很简单，当一个模式具有全局选项时，和 `exec` 一样，每次 `test` 都会保留上次匹配的位置——即 `lastIndex`

很显然，当第一次匹配之后，第二次匹配时的 `lastIndex` 已经到了字符串末尾，尽管这个时候字符串已经是一个新的字符串了，但是这个 `lastIndex` 的位置并没有重新初始化，所以会从末尾开始匹配——当然会匹配失败了

## 常见的数组排序方式

#### 第一种 sort

也是比较常见的一种方式

```js
arr.sort(function (a, b) {
  // b - a 则相反
  return a - b;
})
```

#### 第二种 冒泡排序

比较相邻的元素，如果第一个比第二个大，就交换他们两个

```js
function bubbleSort(arr) {
  // i 表示所需循环的趟数
  // j 表示这一趟需要比较的次数
  var i = arr.length, j;
  while (i > 0) {
    for (j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    i--;
  }
  return arr;
}
```


#### 第三种 快速排序

找基准（一般是以中间项为基准）然后遍历数组，小于基准的放在 ```left```，大于基准的放在 ```right```，最后递归调用

```js
function quickSort(arr) {
  // 如果数组 <=1，则直接返回
  if (arr.length <= 1) { return arr; }

  // 以中间点为基准
  var pivotIndex = Math.floor(arr.length / 2);

  // 利用 splice() 方法得到基准值，用于最后的拼接还原
  var pivot = arr.splice(pivotIndex, 1)[0];

  // 定义左右数组
  var left = [];
  var right = [];

  // 比基准小的放在 left，比基准大的放在 right
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] <= pivot) {
      left.push(arr[i]);
    }
    else {
      right.push(arr[i]);
    }
  }

  // 递归
  return quickSort(left).concat([pivot], quickSort(right));
}
```

#### 第四种 插入排序

每步将一个待排序的对象，按其排序码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止

```js
function insertSort(array) {
  var i = 1,
    j, step, key, len = array.length;

  for (; i < len; i++) {
    step = j = i;
    key = array[j];
    while (--j > -1) {
      if (array[j] > key) {
        array[j + 1] = array[j];
      } else {
        break;
      }
    }
    array[j + 1] = key;
  }

  return array;
}
```


#### 扩展：对象排序

```js
var arr = [
  { 'x': 30, 'y': 15, 'z': 22 },
  { 'x': 15, 'y': 35, 'z': 21 },
  { 'x': 12, 'y': 55, 'z': 82 }
]

arr.sort(function (a, b) {
  return a.x > b.x
})

console.log(arr)
```


## 数组去重的几种方式

#### 第一种 Set

利用 ```ES6``` 提供的新数据类型 ```Set```，它不允许重复元素出现，如果你重复添加同一个元素的话，```Set``` 中只会存在一个

```js
var newArr = [...new Set(arr)]
```

#### 第二种 对象键值对法（速度最快，占用空间最多）

创建一个空对象和一个用于存放结果的新数组，在 ```for``` 循环的时候，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为 ```1```（这个值可以自定义），存入到创建的对象中

```js
function unique(arr) {
  // 结果数组
  var res = [];

  // 创建一个辅助空对象
  var json = {};

  for (var i = 0; i < arr.length; i++) {
    // 遍历原数组，和对象里面的键进行比对，不存在就存入新数组
    if (!json[arr[i]]) {
      res.push(arr[i]);
      json[arr[i]] = 1;
    }
  }

  return res;
}
```

#### indexOf

使用 ```indexOf```，新建一个结果数组，循环传入的数组，筛选出匹配元素放入结果数组（返回 ```-1``` 就是没找到，也就是不重复）

```js
Array.prototype.unique = function () {
  var arr = [];
  for (var i = 0; i < this.length; i++) {
    if (arr.indexOf(this[i]) == -1) {
      arr.push(this[i]);
    }
  }
  return arr;
}
```

#### 相邻进行比较

先将原数组排序（排序后重复的元素应该位于相邻的位置），取第一项（下标为 ```0```）放入结果数组，依次与后面相邻的进行比较（循环是从第二项开始），不同的话则存入新数组

```js
Array.prototype.unique = function () {
  this.sort();
  var arr = [this[0]];
  for (var i = 1; i < this.length; i++) {
    if (this[i] !== arr[arr.length - 1]) {
      arr.push(this[i]);
    }
  }
  return arr;
}
```


#### indexOf + filter

利用了 ```filter``` 方法，过滤掉重复元素（```arr.filter(元素的值，元素的索引，被遍历的数组)```）

利用 ```indexOf``` 特性，几个相同的元素 ```indexOf``` 总是返回最先找到的那一个的下标

```js
arr.filter((el, index, _this) => {
  return _this.indexOf(el) === index;
})
```




## 字符串去重的几种方式

#### for 遍历

```js
function unique1(str) {
  var newStr = '';
  var flag;
  for (var i = 0; i < str.length; i++) {
    flag = 1;
    for (var j = 0; j < newStr.length; j++) {
      if (str[i] == newStr[j]) {
        flag = 0;
        break;
      }
    }
    if (flag) newStr += str[i];
  }
  return newStr;
} 
```


#### indexOf

```js
function unique2(str) {
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (newStr.indexOf(str[i]) == -1) {
      newStr += str[i];
    }
  }
  return newStr;
}  
```

#### search() 方法（同上面类似）

同上面类似

```js
function unique3(str) {
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (newStr.search(str[i]) == -1)
      newStr += str[i];

  }
  return newStr;
}  
```


#### 利用对象属性

```js
function unique4(str) {
  var obj = {};
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (!obj[str[i]]) {
      newStr += str[i];
      obj[str[i]] = 1;
    }
  }
  return newStr;
} 
```



## 常见的数组的几种复制方法

#### 第一种 slice

```js
var arr = [1, 2, 3];
var copyArr = arr.slice();
```


#### 第二种 concat

```js
var arr = [1, 2, 3];
var copyArr = arr.concat();
```

#### 第三种 for 循环

```js
var arr = [1, 2, 3];
var newArr = [];

for (var i = 0; i < arr.length; i++) {
  newArr.push(arr[i])
}
```

#### 第四种 扩展运算符

```js
var arr = [1, 2, 3];
var newArr = [...arr];
```

#### 第五种 Array.form()

```js
var arr = [1, 2, 3];
var newArr = Array.from(arr)
```

#### 第六种 Array.of()

```js
var arr = [1, 2, 3];
var newArr = Array.of(...arr)
```




## 数组操作 - 生成一个 m 长度，内容都为 n 的数组

#### 方法一

利用 `for` 循环，生成指定内容的数组

```js
function creatAry(m, n) {
  var ary = [];
  function aryPush(m, n) {
    if (ary.length == m) return ary;
    ary.push(n);
    return aryPush(m, n);
  }
  return (aryPush(m, n))
}
```

#### 方法二

利用 `fill` 填充数组

```js
function creatAry (m, n) {
  return new Array(m).fill(n)
}
```



## 生成 20 个 40 - 80 之间的随机数，并排序和乱序

```js
var arr = [];

for (var i = 0; i < 20; i++) {
  arr.push(randomNum(40, 80))
}

// 排序
console.log(arr.sort(function (a, b) { return a - b }))

// 乱序
console.log(arr.sort(function () { return 0.5 - Math.random() }))

// 范围 n ~ m
// 原理为：40 ~ 80 随机数即 40 + (80 - 40) * Math.random
function randomNum(n, m) {
  return parseInt(Math.random() * (m - n) + n)
}
```



## 常见的字符串算法

#### 短横变驼峰

比如将 `border-color` 变为 `borderColor`

一般常见的有两种方式，先使用 `split()` 方法将字符串分割为数组，然后遍历数组，将除去第一项之外的每一项的首字母变为大写（`toUpperCase()`），然后在使用 `join()` 方法还原为字符串

```js
var str = 'border-right-color'

toHump(str, '-')

function toHump(str, separator) {
  if (!(typeof str == 'string')) {
    throw new Error(`str need to be a string`)
  };
  var strArr = str.split(separator);
  for (var i = 1; i < strArr.length; i++) {
    strArr[i] = strArr[i][0].toUpperCase() + strArr[i].slice(1)
  }
  return strArr.join('')
}
```

另一种方式就是使用正则表达式

```js
var str = 'border-right-color'

toHump(str)

function toHump(str) {
  return str.replace(/\-(\w)/g, function (match, $1) {
    return $1.toUpperCase();
  })
}
```

#### 千位分隔符

同样有两种方式，利用 `slice()` 方法，每隔三位一分离

```js
thousandSeparator(12345)

function thousandSeparator(num) {
  if (!(typeof num == 'number')) {
    throw new Error(`num need to be a number`)
  };
  // 转换为字符串方便计算位数
  num = num.toString();
  var start = -3;
  var end = -Math.ceil(num.length / 3) * 3;

  // 第一次分隔不能添加第二个参数 slice(-3)
  // 所以先将其添加进数组
  var result = [num.slice(-3)]
  for (var i = start - 3; i >= end; i -= 3) {
    result.unshift(num.slice(i, i + 3))
  }

  return result.join(',');
}
```

另一种是同样的使用正则表达式

```js
// 使用 commafy(1234567.90)
function commafy(num) {
  return num && num
    .toString()
    // 也可以使用正则 /\B(?=(\d{3})+$)/g
    .replace(/(\d)(?=(\d{3})+\.)/g, function ($0, $1) {
      return $1 + ',';
    });
}
```

正则中的 `(?=)` 语法表示捕获，位置描述，简单来说就是过滤匹配中的内容

比如上面的匹配了 `(\d)`，然后过滤出什么样子的数字，后面就是描述（`\.` 表示任意单字符）

上面的正则简单来说就是匹配数字（`(\d)`），然后匹配什么样的数字（使用 `(?=)` 来描述）

`(\d{3})+` 表示有三个或多个三个连续的数字（`+` 表示一个或多个）


## 取两个数组的差集

可以利用对象的索引方法来处理

```js
var arr1 = [1, 2, 3, 4, 5, 6];
var arr2 = [3, 4, 5, 6, 7, 8, 9, 3, 4, 5];

// 创建一个临时对象
var temp = {};

// 然后遍历 arr2 数组，创建索引对象
for (var i = 0; i < arr2.length; i++) {
  temp[arr2[i]] = 1;
}

// 创建一个结果数组，再遍历 arr1，看 arr2 的索引对象中是否含有这个属性
var result = [];
for (var i = 0; i < arr1.length; i++) {
  if (!temp[arr1[i]]) {
    result.push(arr1[i])
  }
}

console.log(result)
```


## 数组的常用方法分析及内部实现原理

#### Array.prototype.splice()

```js
Array.prototype.splice = function (start, deleteCount) {
  var max = Math.max,
    min = Math.min,
    delta,              // 偏移量
    element,
    insertCount = max(arguments.length - 2, 0),   // 排除掉 arguments 参数中 start 和 deleteCount，剩余是待插入元素
    k = 0,
    len = this.length,  // 对 array 调用时，this 指向当前数组
    new_len,
    result = [],        // 返回数组
    shift_count;        // 需移位的数量

  start = start || 0;     // start 默认值为 0
  if (start < 0) start += len;        // start < 0 时，从数组后端开始
  start = max(min(start, len), 0);    // 经过处理，0 <= start <= len
  deleteCount = typeof deleteCount === 'number' ? deleteCount : len;  // deleteCount 默认值是 len
  deleteCount = min(deleteCount, len - start);    // deleteCount <= 可删除数量
  deleteCount = max(deleteCount, 0);  // 0 <= deleteCount <= 可删除数量

  delta = insertCount - deleteCount;
  new_len = len + delta;

  // 获取删除元素
  while (k < deleteCount) {
    element = this[start + k];
    if (element != undefined) {
      result[k] = element;
    }
    k += 1;
  }

  shift_count = len - start - deleteCount;

  // 待插入数量小于删除数量，原数组后续元素依次向左偏移
  if (delta < 0) {
    k = start + insertCount;    // 从 start 至 start + insertCount 留给待插入元素
    while (shift_count) {
      this[k] = this[k - delta];
      k += 1;
      shift_count -= 1;
    }
    this.length = new_len;

  // 待插入数量大于删除数量，原数组后续元素依次向右偏移
  // delta === 0 时，待插入数量等于删除数量，无需偏移
  } else if (delta > 0) {
    k = 1;
    while (shift_count) {
      this[new_len - k] = this[len - k];
      k + 1;
      shift_count -= 1;
    }
    // 非必须，因给一开始 this[new_len - k] 赋值时，length 属性已经自动设置为数组最后元素下标值
    // this.length = new_len;
  }

  // 最后将待插入元素插入原数组
  for (k = 0; k < insertCount; k += 1) {
    // 排除掉 arguments 参数中 start 和 deleteCount
    this[start + k] = arguments[k + 2];
  }

  return result;
};
```




#### Array.prototype.push()

```js
Array.prototype.push = function () {

  // 对 arguments 对象通过 array.slice 方法转换成数组
  var args = Array.prototype.slice.apply(arguments);

  // 通过 array.concat 连接两个数组
  var params = [this.length, 0].concat(args);

  // 对数组调用 splice 方法
  // start = this.length
  // deleteCount = 0
  // insertItems = args
  this.splice.apply(this, params);

  // 返回新的数组 length
  return this.length;
};

// 上述步骤合并，简写为下面方式（简单来说就是利用 concat 拼接两个数组）
Array.prototype.push = function () {

  this.splice.apply(this, [this.length, 0].concat(Array.prototype.slice.apply(arguments)));

  return this.length;

};
```




#### Array.prototype.pop()

```js
// 删除并返回数组的最后一个元素
Array.prototype.pop = function () {
  return this.splice(this.length - 1, 1)[0];
}
```




#### Array.prototype.shift()

```js
// 和上面一样，但是删除并返回数组的第一个元素
Array.prototype.shift = function () {
  return this.splice(0, 1)[0];
}
```




#### Array.prototype.unshift()

```js
// 向数组的开头添加一个或更多元素，并返回新的长度
Array.prototype.unshift = function () {
  this.splice.apply(this, [0, 0].concat(Array.prototype.slice.apply(arguments)));
  return this.length;
};
```


----

----



#### 数组常用方法

```js
var arr = [];
 
// 删除第一项
arr.shift();
 
// 添加第一项
arr.unshift();
 
// 删除最后一项
arr.pop();
 
// 添加最后一项
arr.push();
 
// concat() 方法用于连接两个或多个字符串
stringObject.concat(stringX, stringX, ..., stringX)
 
// 利用 concat 来复制
arr.concat(arr);
 
// join() 方法 把数组中的所有元素放入一个字符串（可以指定分隔符）
arr.join();
 
// splice() 从数组中 添加/删除 项目，然后返回被删除的项目
// index              必需，整数，规定 添加/删除 项目的位置，使用负数可从数组结尾处规定位置
// howmany            必需，要删除的项目数量，如果设置为 0，则不会删除项目
// item1, ..., itemX  可选，向数组添加的新项目
arr.splice(index, howmany, item1, ..., itemX)
```





#### String 常用方法

```js
var str;
 
// charAt() 方法 返回指定位置的字符
// 字符串中第一个字符的下标是 0，如果参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串
str.charAt(index);
 
// indexOf()    方法 返回某个指定的字符串值在字符串中首次出现的位置
// searchvalue  必需，规定需检索的字符串值
// fromindex    可选的整数参数，规定在字符串中开始检索的位置，它的合法取值是 0 到 str.length - 1，如省略该参数，则将从字符串的首字符开始检索
str.indexOf(searchvalue, fromindex)
 
// replace() 方法 用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串
str.replace(regexp/substr, replacement)
 
// split()    方法 把一个字符串分割成字符串数组
// howmany    可选参数 指定返回的数组的最大长度，如果设置了该参数，返回的子串不会多于这个参数指定的数组，如果没有设置该参数，整个字符串都会被分割，不考虑它的长度
str.split(separator, howmany)
 
// slice() 方法 提取字符串的某个部分，并以新的字符串返回被提取的部分
// 从 start 开始（包括 start）到 end 结束（不包括 end）
str.slice(start, end)
 
// substr() 方法 可在字符串中抽取从 start 下标开始的指定数目的字符
// start也可接受负数，也表示从字符串尾部计数，这点和 slice 相同；但 substr 的 length 则不能小于 1，否则返回空字符串
str.substr(start,length)

```






#### Math 常用方法

```js
// 返回数的绝对值
Math.abs(x)
 
// 向上取舍
Math.ceil(x)
 
// 向下取舍
Math.floor(x)
 
// 四舍五入
Math.round(x)
 
// 随机数 0.0 ~ 1.0 之间的一个伪随机数
Math.random()
```




#### 全局对象

```js
// parseFloat() 函数可解析一个字符串，并返回一个浮点数
// 指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串
parseFloat(string)
 
// parseInt() 函数可解析一个字符串，并返回一个整数
// radix 为进制，如果省略该参数或其值为 0，则数字将以 10 为基础来解析
parseInt(string, radix)

```



#### 关于 slice，substr 和 substring 的区别

> 对于 `substr()` 方法，需要注意的是 `ECMAscript` 没有对该方法进行标准化，因此反对使用它

```js
substr(start [, length])

substring(start [, end])

slice(start [, end])
```

从定义上看 `substring` 和 `slice` 是同类的，参数都是字符串的某个（开始）位置到某个（结束）位置（但（结束）位置的字符不包括在结果中）

而 `substr` 则是字符串的某个（开始）位置起，数 `length` 个长度的字符才结束

共性为：从 `start` 开始，如果没有第 `2` 个参数，都是直到字符串末尾



#### substring 和 slice 的区别

`slice` 可以接受"负数"，表示从字符串尾部开始计数，而 `substring` 则把负数或其它无效的数，当作 `0`

```js
'hello world!'.slice(-6, -1)        // 'world'
'hello world!'.substring('abc', 5)  // 'hello' 
```

`substr` 的 `start` 也可接受负数，也表示从字符串尾部计数，这点和 `slice` 相同，但 `substr` 的 `length` 则不能小于 `1`，否则返回空字符串

```js
'hello world!'.substr(-6, 5) // 'world'
'hello world!'.substr(0, -1) // '' 
```

所以很多人认为 `substring` 是多余的：如果只知道位置，那么用 `slice`，如果知道长度则用 `substr`



## JavaScript 获得随机 unicode 字符

```js
String.fromCharCode(Math.floor(Math.random()*9999));
```

## getElementsByClassName 方法实现

```js
function getElementsByClassName(classname) {
  if (document.querySelectorAll) {
    return document.querySelectorAll('.' + classname);
  } else {
    var elements = document.getElementsByTagName('*');
    var reg = new RegExp('(^|\\s)' + classname + '(\\s|$)');
    var results = [];
    for (let i = 0, length = elements.length; i < length; i++) {
      if (reg.test(elements[i].className)) {
        results.push(elements[i]);
      }
    }
  }

  return results;
}
```

## 提取数字中的整数部分

```js
function integer(num) {
  return Math[num < 0 ? 'ceil' : 'floor'](num);
}

console.log(integer(-10 / 3))
```

## 实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制

```js
Object.prototype.clone = function () {
  var o = this.constructor === Array ? [] : {};
  for (var e in this) {
    o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
  }
  return o;
}
```

## 深度克隆

```js
// 方式一
function extendDeepCopy01(obj, newobj) {
  var newobj = newobj || {};
  for (var i in obj) {
    if (typeof obj[1] == "object") {
      newobj[i] = (obj[i].constructor === Array) ? [] : {};
      extendDeepCopy(obj[i], newobj[i]);
    } else {
      newobj[i] = obj[i];
    }
  }
  return newobj;
}

// 方式二
function extendDeepCopy02(Obj) {
  var buf;

  if (Obj instanceof Array) {
    // 创建一个空的数组
    buf = [];
    var i = Obj.length;

    while (i--) {
      buf[i] = extendDeepCopy02(Obj[i]);
    }

    return buf;

  } else if (Obj instanceof Object) {
    // 创建一个空对象
    buf = {};

    // 为这个对象添加新的属性
    for (var k in Obj) {
      buf[k] = extendDeepCopy02(Obj[k]);
    }
    return buf;

  } else {
    return Obj;
  }
}

var user = {
  name: 'aaa',
  tag: ['tag1', 'tag2'],
  username: 'test',
  password: 'password'
}

var user1 = extendDeepCopy01(user);

user1.name = 'bbb';
user1.username = 'username1';
user1.password = 'password1';
user1.tag.push('tag3');

console.log(user1)
```

## 生成 [0, 1, 2, 3 ... N - 1] 的数组

在 ES5 当中可以使用如下方式

```js
Array.apply(null, { length: N }).map(Function.call, Number);
```

* `Array.apply(null, {length: N})` 将返回一个由 `undefined` 填充的长度为 `N` 的数组

* `.map(Function.call, Number)` 将返回一个长度为 `N` 的数组，它的索引为 `I` 的元素为 `Function.call.call(Number, undefined, I, A)` 的结果

* `Function.call.call(Number, undefined, I, A)` 可转化为 `Number(I)`，正好就是 `I`


在 ES6 当中的话则可以使用下面这种方式

```js
Array.from(new Array(N), (val, index) => index);
```

* `new Array(N)` 返回一个由 `undefined` 组成的长度为 `N` 的数组（类似于 `[, , , ...]`）

* `(val, index) => index` 即 `function F (val, index) { return index; }`

* `Array.from(A, F)` 返回一个长度为 `N` 的数组，它的索引为 `I` 的元素为 `F(A[I], I)` 的结果，也就是 `I`


如果想要生成 `[1, 2, 3, 4 ... N]` 这样的序列

针对方法一可以使用

```js
Array.apply(null, { length: N }).map(function(value, index){
  return index + 1;
});
```

针对方法二可以使用

```js
Array.from(new Array(N), (val, index) => index + 1);
```


## 找出数字数组中最大的元素

```js
Math.max.apply(null, arr);
```








## 转化一个数字数组为 function 数组（每个 function 都弹出相应的数字）

```js
var arr = [1, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
  var index = arr[i];
  (function (index) {
    arr[i] = function () {
      alert(index);
    }
  })(index)
}

arr[0]();
```


## 给 object 数组进行排序（排序条件是每个元素对象的属性个数）

```js
Object.prototype.getLength = function () {
  var num = 0;
  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      num++;
    }
  }
  return num;
}

var a = {
  name: 'a',
  age: 10,
  location: 'b'
};

var b = {
  name: 'c'
};

var c = {
  name: 'd',
  sex: 'e'
};

var arr = [a, b, c];

arr.sort(function (a, b) {
  return a.getLength() > b.getLength();
})

console.log(arr);
```


## 打印 Fibonacci 数（不使用全局变量）

```js
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
function fn(n) {
  var a = [];
  a[0] = 0, a[1] = 1;
  for (var i = 2; i < n; i++) {
    a[i] = a[i - 1] + a[i - 2];
  }
  for (var i = 0; i < n; i++) {
    console.log(a[i]);
  }
}

fn(20);
```


## 实现如下语法的功能 var a = (5).plus(3).minus(6);

```js
Number.prototype.plus = function (a) {
  return this + a;
};

Number.prototype.minus = function (a) {
  return this - a;
};

var a = (5).plus(3).minus(6);

console.log(a);
```


## 实现如下语法的功能 var a = add(2)(3)(4);

```js
function add(a) {
  var temp = function (b) {
    return add(a + b);
  }
  temp.valueOf = temp.toString = function () {
    return a;
  };
  return temp;
}
var ans = add(2)(3)(4);

console.log(ans);
```


## 使用 filter 确保 Observable 当中流中的值不为空

```js
dialogRef.afterClosed()
  .take(1)
  .filter(n => n)
```




## 将数组转为字典对象

```js
// obj 为传入的值
const userEntities = obj.reduce((el, c) => ({...el, c}), {})
```




## 从列表当中删除掉指定项

```js
// 从 items 中取出 id 集合
const ids = this.items.map(item => item.id);
// 然后筛选需要删除的项在数组当中所处的位置
const i = ids.indexOf(member.id);
// 进行删除
this.items = [...this.items.slice(0, i), ...this.items.slice(i + 1)]
```




## 查找列表当中指定的项

```js
export class ItemsService {
  private items: any[];

  getItem(id: number) {
    return this.items.find((item) => item.id === id);
  }
}
```


## 去除所有的 html

```js
var con = content.replace(/<[^>]+>/g,'');
```



## 去除空格

```js
var con = content.replace(/\s/g,'');
```



## 判断输入的是否为数字

```js
var reg=/^\d+(\.\d+)?$/;
​
if(reg.test(title) == true){
  alert("内容不能为纯数字，请从新输入！");
  return false;
}
```


## 取括号中的数值

```js
/\(([^()]+)\)/g.exec('add(18)')
```


## 千位分隔符（整数）

```js
var a = "-1234454654645645";

a = a.replace(/(\d)(?=(\d{3})+$)/g,"$1,");

console.log(a);
```

