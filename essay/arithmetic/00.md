## [1, 2, 3, 4, 5] => [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]

```js
const a = [1, 2, 3, 4, 5]

// 补齐这里

a.multiply();
console.log(a);  // [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]
```

#### 解决方式

两种方式，不过原理都是利用 `map` 来计算乘积在进行返回

```js
// 方法一
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return this.push(...this.map(x => x * x));
}

a.multiply();
console.log(a);

// 方法二
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return Object.assign(this, [...this, ...this.map(x => x * x)]);

  // 或者使用下面这样
  return Object.assign(this, this.concat(...this.map(x => x * x)));
}

a.multiply();
console.log(a);
```


## 生成一个 20 X 12 的表格，并且设定指定格子的背景颜色

核心代码如下

```html
<style>
  td {
    border: 1px solid red;
    margin: 10px;
    width: 20px;
    height: 20px;
  }
</style>

<body>

  <table id="box"></table>

  <script>
    "use strict";

    var table = document.getElementById("box");

    var result = [];
    for (var i = 0; i < 20; i++) {
      var temp = [];
      var tr = document.createElement("tr");
      for (var j = 0; j < 12; j++) {
        var td = document.createElement("td");
        tr.appendChild(td);
        temp.push(td);
      }
      result.push(temp);
      table.appendChild(tr);
    }

    // 这个表示第三行第三列的表格颜色为红色
    // 因为下标是从 0 开始的
    result[2][2].style.background = "red";
  </script>
</body>
```



## 常见的数组排序方式

#### 第一种 sort

也是比较常见的一种方式

```js
arr.sort(function (a, b) {
  // b - a 则相反
  return a - b;
})
```

#### 第二种 冒泡排序

比较相邻的元素，如果第一个比第二个大，就交换他们两个

```js
function bubbleSort(arr) {
  // i 表示所需循环的趟数
  // j 表示这一趟需要比较的次数
  var i = arr.length, j;
  while (i > 0) {
    for (j = 0; j < i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        var temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    i--;
  }
  return arr;
}
```


#### 第三种 快速排序

找基准（一般是以中间项为基准）然后遍历数组，小于基准的放在 ```left```，大于基准的放在 ```right```，最后递归调用

```js
function quickSort(arr) {
  // 如果数组 <=1，则直接返回
  if (arr.length <= 1) { return arr; }

  // 以中间点为基准
  var pivotIndex = Math.floor(arr.length / 2);

  // 利用 splice() 方法得到基准值，用于最后的拼接还原
  var pivot = arr.splice(pivotIndex, 1)[0];

  // 定义左右数组
  var left = [];
  var right = [];

  // 比基准小的放在 left，比基准大的放在 right
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] <= pivot) {
      left.push(arr[i]);
    }
    else {
      right.push(arr[i]);
    }
  }

  // 递归
  return quickSort(left).concat([pivot], quickSort(right));
}
```

#### 第四种 插入排序

每步将一个待排序的对象，按其排序码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止

```js
function insertSort(array) {
  var i = 1,
    j, step, key, len = array.length;

  for (; i < len; i++) {
    step = j = i;
    key = array[j];
    while (--j > -1) {
      if (array[j] > key) {
        array[j + 1] = array[j];
      } else {
        break;
      }
    }
    array[j + 1] = key;
  }

  return array;
}
```


#### 扩展：对象排序

```js
var arr = [
  { 'x': 30, 'y': 15, 'z': 22 },
  { 'x': 15, 'y': 35, 'z': 21 },
  { 'x': 12, 'y': 55, 'z': 82 }
]

arr.sort(function (a, b) {
  return a.x > b.x
})

console.log(arr)
```


## 数组去重的几种方式

#### 第一种 Set

利用 `ES6` 提供的新数据类型 `Set`，它不允许重复元素出现，如果你重复添加同一个元素的话，`Set` 中只会存在一个

```js
var newArr = [...new Set(arr)]
```

#### 第二种 对象键值对法（速度最快，占用空间最多）

创建一个空对象和一个用于存放结果的新数组，在 `for` 循环的时候，每次取出一个元素与对象进行对比

如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为 `1`（这个值可以自定义），存入到创建的对象中

```js
function unique(arr) {
  // 结果数组
  var res = [];

  // 创建一个辅助空对象
  var json = {};

  for (var i = 0; i < arr.length; i++) {
    // 遍历原数组，和对象里面的键进行比对，不存在就存入新数组
    if (!json[arr[i]]) {
      res.push(arr[i]);
      json[arr[i]] = 1;
    }
  }

  return res;
}
```

#### indexOf

使用 `indexOf`，新建一个结果数组，循环传入的数组，筛选出匹配元素放入结果数组（返回 `-1` 就是没找到，也就是不重复）

```js
Array.prototype.unique = function () {
  var arr = [];
  for (var i = 0; i < this.length; i++) {
    if (arr.indexOf(this[i]) == -1) {
      arr.push(this[i]);
    }
  }
  return arr;
}
```

#### 相邻进行比较

先将原数组排序（排序后重复的元素应该位于相邻的位置），取第一项（下标为 `0`）放入结果数组

依次与后面相邻的进行比较（循环是从第二项开始），不同的话则存入新数组

```js
Array.prototype.unique = function () {
  this.sort();
  var arr = [this[0]];
  for (var i = 1; i < this.length; i++) {
    if (this[i] !== arr[arr.length - 1]) {
      arr.push(this[i]);
    }
  }
  return arr;
}
```

#### 利用 reduce

方法同上面的相邻进行比较有些类似，也是依次与后面相邻的进行比较，不同的话存入新数组

```js
function unique(arr) {
  var init = []
  var result = arr.sort().reduce((init, current) => {
    console.log(init, current)
    if (init.length === 0 || init[init.length - 1] !== current) {
      init.push(current);
    }
    return init;
  }, []);
  return result;
}
```


#### indexOf + filter

利用了 `filter` 方法，过滤掉重复元素（`arr.filter(元素的值，元素的索引，被遍历的数组)`）

利用 `indexOf` 特性，几个相同的元素 `indexOf` 总是返回最先找到的那一个的下标

```js
arr.filter((el, index, _this) => {
  return _this.indexOf(el) === index;
})
```




## 字符串去重的几种方式

#### for 遍历

```js
function unique1(str) {
  var newStr = '';
  var flag;
  for (var i = 0; i < str.length; i++) {
    flag = 1;
    for (var j = 0; j < newStr.length; j++) {
      if (str[i] == newStr[j]) {
        flag = 0;
        break;
      }
    }
    if (flag) newStr += str[i];
  }
  return newStr;
} 
```


#### indexOf

```js
function unique2(str) {
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (newStr.indexOf(str[i]) == -1) {
      newStr += str[i];
    }
  }
  return newStr;
}  
```

#### search() 方法（同上面类似）

同上面类似

```js
function unique3(str) {
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (newStr.search(str[i]) == -1)
      newStr += str[i];

  }
  return newStr;
}  
```


#### 利用对象属性

```js
function unique4(str) {
  var obj = {};
  var newStr = '';
  for (var i = 0; i < str.length; i++) {
    if (!obj[str[i]]) {
      newStr += str[i];
      obj[str[i]] = 1;
    }
  }
  return newStr;
} 
```



## 常见的数组的几种复制方法

#### 第一种 slice

```js
var arr = [1, 2, 3];
var copyArr = arr.slice();
```


#### 第二种 concat

```js
var arr = [1, 2, 3];
var copyArr = arr.concat();
```

#### 第三种 for 循环

```js
var arr = [1, 2, 3];
var newArr = [];

for (var i = 0; i < arr.length; i++) {
  newArr.push(arr[i])
}
```

#### 第四种 扩展运算符

```js
var arr = [1, 2, 3];
var newArr = [...arr];
```

#### 第五种 Array.form()

```js
var arr = [1, 2, 3];
var newArr = Array.from(arr)
```

#### 第六种 Array.of()

```js
var arr = [1, 2, 3];
var newArr = Array.of(...arr)
```




## 数组操作 - 生成一个 m 长度，内容都为 n 的数组

#### 方法一

利用 `for` 循环，生成指定内容的数组

```js
function creatAry(m, n) {
  var ary = [];
  function aryPush(m, n) {
    if (ary.length == m) return ary;
    ary.push(n);
    return aryPush(m, n);
  }
  return (aryPush(m, n))
}
```

#### 方法二

利用 `fill` 填充数组

```js
function creatAry (m, n) {
  return new Array(m).fill(n)
}
```



## 生成 20 个 40 - 80 之间的随机数，并排序和乱序

```js
var arr = [];

for (var i = 0; i < 20; i++) {
  arr.push(randomNum(40, 80))
}

// 排序
console.log(arr.sort(function (a, b) { return a - b }))

// 乱序
console.log(arr.sort(function () { return 0.5 - Math.random() }))

// 范围 n ~ m
// 原理为：40 ~ 80 随机数即 40 + (80 - 40) * Math.random
function randomNum(n, m) {
  return parseInt(Math.random() * (m - n) + n)
}
```



## 常见的字符串算法

#### 短横变驼峰

比如将 `border-color` 变为 `borderColor`

一般常见的有两种方式，先使用 `split()` 方法将字符串分割为数组，然后遍历数组，将除去第一项之外的每一项的首字母变为大写（`toUpperCase()`），然后在使用 `join()` 方法还原为字符串

```js
var str = 'border-right-color'

toHump(str, '-')

function toHump(str, separator) {
  if (!(typeof str == 'string')) {
    throw new Error(`str need to be a string`)
  };
  var strArr = str.split(separator);
  for (var i = 1; i < strArr.length; i++) {
    strArr[i] = strArr[i][0].toUpperCase() + strArr[i].slice(1)
  }
  return strArr.join('')
}
```

另一种方式就是使用正则表达式

```js
var str = 'border-right-color'

toHump(str)

function toHump(str) {
  return str.replace(/\-(\w)/g, function (match, $1) {
    return $1.toUpperCase();
  })
}
```

#### 千位分隔符

同样有两种方式，利用 `slice()` 方法，每隔三位一分离

```js
thousandSeparator(12345)

function thousandSeparator(num) {
  if (!(typeof num == 'number')) {
    throw new Error(`num need to be a number`)
  };
  // 转换为字符串方便计算位数
  num = num.toString();
  var start = -3;
  var end = -Math.ceil(num.length / 3) * 3;

  // 第一次分隔不能添加第二个参数 slice(-3)
  // 所以先将其添加进数组
  var result = [num.slice(-3)]
  for (var i = start - 3; i >= end; i -= 3) {
    result.unshift(num.slice(i, i + 3))
  }

  return result.join(',');
}
```

另一种是同样的使用正则表达式

```js
// 使用 commafy(1234567.90)
function commafy(num) {
  return num && num
    .toString()
    // 也可以使用正则 /\B(?=(\d{3})+$)/g
    .replace(/(\d)(?=(\d{3})+\.)/g, function ($0, $1) {
      return $1 + ',';
    });
}
```

正则中的 `(?=)` 语法表示捕获，位置描述，简单来说就是过滤匹配中的内容

比如上面的匹配了 `(\d)`，然后过滤出什么样子的数字，后面就是描述（`\.` 表示任意单字符）

上面的正则简单来说就是匹配数字（`(\d)`），然后匹配什么样的数字（使用 `(?=)` 来描述）

`(\d{3})+` 表示有三个或多个三个连续的数字（`+` 表示一个或多个）


## 取两个数组的差集

可以利用对象的索引方法来处理

```js
var arr1 = [1, 2, 3, 4, 5, 6];
var arr2 = [3, 4, 5, 6, 7, 8, 9, 3, 4, 5];

// 创建一个临时对象
var temp = {};

// 然后遍历 arr2 数组，创建索引对象
for (var i = 0; i < arr2.length; i++) {
  temp[arr2[i]] = 1;
}

// 创建一个结果数组，再遍历 arr1，看 arr2 的索引对象中是否含有这个属性
var result = [];
for (var i = 0; i < arr1.length; i++) {
  if (!temp[arr1[i]]) {
    result.push(arr1[i])
  }
}

console.log(result)
```


## 数组的常用方法

```js
var arr = [];
 
// 删除第一项
arr.shift();
 
// 添加第一项
arr.unshift();
 
// 删除最后一项
arr.pop();
 
// 添加最后一项
arr.push();
 
// concat() 方法用于连接两个或多个字符串
stringObject.concat(stringX, stringX, ..., stringX)
 
// 利用 concat 来复制
arr.concat(arr);
 
// join() 方法 把数组中的所有元素放入一个字符串（可以指定分隔符）
arr.join();
 
// splice() 从数组中 添加/删除 项目，然后返回被删除的项目
// index              必需，整数，规定 添加/删除 项目的位置，使用负数可从数组结尾处规定位置
// howmany            必需，要删除的项目数量，如果设置为 0，则不会删除项目
// item1, ..., itemX  可选，向数组添加的新项目
arr.splice(index, howmany, item1, ..., itemX)
```





#### String 常用方法

```js
var str;
 
// charAt() 方法 返回指定位置的字符
// 字符串中第一个字符的下标是 0，如果参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串
str.charAt(index);
 
// indexOf()    方法 返回某个指定的字符串值在字符串中首次出现的位置
// searchvalue  必需，规定需检索的字符串值
// fromindex    可选的整数参数，规定在字符串中开始检索的位置，它的合法取值是 0 到 str.length - 1，如省略该参数，则将从字符串的首字符开始检索
str.indexOf(searchvalue, fromindex)
 
// replace() 方法 用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串
str.replace(regexp/substr, replacement)
 
// split()    方法 把一个字符串分割成字符串数组
// howmany    可选参数 指定返回的数组的最大长度，如果设置了该参数，返回的子串不会多于这个参数指定的数组，如果没有设置该参数，整个字符串都会被分割，不考虑它的长度
str.split(separator, howmany)
 
// slice() 方法 提取字符串的某个部分，并以新的字符串返回被提取的部分
// 从 start 开始（包括 start）到 end 结束（不包括 end）
str.slice(start, end)
 
// substr() 方法 可在字符串中抽取从 start 下标开始的指定数目的字符
// start也可接受负数，也表示从字符串尾部计数，这点和 slice 相同；但 substr 的 length 则不能小于 1，否则返回空字符串
str.substr(start,length)

```






#### Math 常用方法

```js
// 返回数的绝对值
Math.abs(x)
 
// 向上取舍
Math.ceil(x)
 
// 向下取舍
Math.floor(x)
 
// 四舍五入
Math.round(x)
 
// 随机数 0.0 ~ 1.0 之间的一个伪随机数
Math.random()
```




#### 全局对象

```js
// parseFloat() 函数可解析一个字符串，并返回一个浮点数
// 指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串
parseFloat(string)
 
// parseInt() 函数可解析一个字符串，并返回一个整数
// radix 为进制，如果省略该参数或其值为 0，则数字将以 10 为基础来解析
parseInt(string, radix)

```



#### 关于 slice，substr 和 substring 的区别

> 对于 `substr()` 方法，需要注意的是 `ECMAscript` 没有对该方法进行标准化，因此反对使用它

```js
substr(start [, length])

substring(start [, end])

slice(start [, end])
```

从定义上看 `substring` 和 `slice` 是同类的，参数都是字符串的某个（开始）位置到某个（结束）位置（但（结束）位置的字符不包括在结果中）

而 `substr` 则是字符串的某个（开始）位置起，数 `length` 个长度的字符才结束

共性为：从 `start` 开始，如果没有第 `2` 个参数，都是直到字符串末尾



#### substring 和 slice 的区别

`slice` 可以接受"负数"，表示从字符串尾部开始计数，而 `substring` 则把负数或其它无效的数，当作 `0`

```js
'hello world!'.slice(-6, -1)        // 'world'
'hello world!'.substring('abc', 5)  // 'hello' 
```

`substr` 的 `start` 也可接受负数，也表示从字符串尾部计数，这点和 `slice` 相同，但 `substr` 的 `length` 则不能小于 `1`，否则返回空字符串

```js
'hello world!'.substr(-6, 5) // 'world'
'hello world!'.substr(0, -1) // '' 
```

所以很多人认为 `substring` 是多余的：如果只知道位置，那么用 `slice`，如果知道长度则用 `substr`



## JavaScript 获得随机 unicode 字符

```js
String.fromCharCode(Math.floor(Math.random()*9999));
```

## getElementsByClassName 方法实现

```js
function getElementsByClassName(classname) {
  if (document.querySelectorAll) {
    return document.querySelectorAll('.' + classname);
  } else {
    var elements = document.getElementsByTagName('*');
    var reg = new RegExp('(^|\\s)' + classname + '(\\s|$)');
    var results = [];
    for (let i = 0, length = elements.length; i < length; i++) {
      if (reg.test(elements[i].className)) {
        results.push(elements[i]);
      }
    }
  }

  return results;
}
```

## 提取数字中的整数部分

```js
function integer(num) {
  return Math[num < 0 ? 'ceil' : 'floor'](num);
}

console.log(integer(-10 / 3))
```

## 实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制

```js
Object.prototype.clone = function () {
  var o = this.constructor === Array ? [] : {};
  for (var e in this) {
    o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
  }
  return o;
}
```

## 深度克隆

```js
// 方式一
function extendDeepCopy01(obj, newobj) {
  var newobj = newobj || {};
  for (var i in obj) {
    if (typeof obj[1] == "object") {
      newobj[i] = (obj[i].constructor === Array) ? [] : {};
      extendDeepCopy(obj[i], newobj[i]);
    } else {
      newobj[i] = obj[i];
    }
  }
  return newobj;
}

// 方式二
function extendDeepCopy02(Obj) {
  var buf;

  if (Obj instanceof Array) {
    // 创建一个空的数组
    buf = [];
    var i = Obj.length;

    while (i--) {
      buf[i] = extendDeepCopy02(Obj[i]);
    }

    return buf;

  } else if (Obj instanceof Object) {
    // 创建一个空对象
    buf = {};

    // 为这个对象添加新的属性
    for (var k in Obj) {
      buf[k] = extendDeepCopy02(Obj[k]);
    }
    return buf;

  } else {
    return Obj;
  }
}

var user = {
  name: 'aaa',
  tag: ['tag1', 'tag2'],
  username: 'test',
  password: 'password'
}

var user1 = extendDeepCopy01(user);

user1.name = 'bbb';
user1.username = 'username1';
user1.password = 'password1';
user1.tag.push('tag3');

console.log(user1)
```

## 不使用 loop 循环，生成指定长度数组（[0, 1, 2, 3 ... N - 1]）

在 `ES5` 当中可以使用如下方式

```js
Array.apply(null, { length: N }).map(Function.call, Number);
```

* `Array.apply(null, {length: N})` 将返回一个由 `undefined` 填充的长度为 `N` 的数组

* `.map(Function.call, Number)` 将返回一个长度为 `N` 的数组，它的索引为 `I` 的元素为 `Function.call.call(Number, undefined, I, A)` 的结果

* `Function.call.call(Number, undefined, I, A)` 可转化为 `Number(I)`，正好就是 `I`


在 ES6 当中的话则可以使用下面这种方式

```js
Array.from(new Array(N), (val, index) => index);
```

* `new Array(N)` 返回一个由 `undefined` 组成的长度为 `N` 的数组（类似于 `[, , , ...]`）

* `(val, index) => index` 即 `function F (val, index) { return index; }`

* `Array.from(A, F)` 返回一个长度为 `N` 的数组，它的索引为 `I` 的元素为 `F(A[I], I)` 的结果，也就是 `I`


如果想要生成 `[1, 2, 3, 4 ... N]` 这样的序列

针对方法一可以使用

```js
Array.apply(null, { length: N }).map(function(value, index){
  return index + 1;
});
```

针对方法二可以使用

```js
Array.from(new Array(N), (val, index) => index + 1);
```

当然方法并不局限为这两种，下面是一些收集整理的方法

```js
// 方法一
Array.from(Array(100).keys())

// 方法二
[...Array(100).keys()]

// 方法三（这三张方法不算太完美，因为生成的为字符串）
Object.keys(Array(100).join().split(','))
Object.keys(Array(100).fill())
Object.keys(Array.apply(null,{length:100}))

// 方法四
Array.prototype.recursion = function(length) {
  if (this.length === length) {
    return this;
  }
  this.push(this.length);
  this.recursion(length);
}

arr = []
arr.recursion(100)

// 方法五
Array(100).fill(0).map(function (val, index) {
  return index;
})
```


## 找出数字数组中最大的元素

```js
Math.max.apply(null, arr);
```








## 转化一个数字数组为 function 数组（每个 function 都弹出相应的数字）

```js
var arr = [1, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
  var index = arr[i];
  (function (index) {
    arr[i] = function () {
      alert(index);
    }
  })(index)
}

arr[0]();
```


## 给 object 数组进行排序（排序条件是每个元素对象的属性个数）

```js
Object.prototype.getLength = function () {
  var num = 0;
  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      num++;
    }
  }
  return num;
}

var a = {
  name: 'a',
  age: 10,
  location: 'b'
};

var b = {
  name: 'c'
};

var c = {
  name: 'd',
  sex: 'e'
};

var arr = [a, b, c];

arr.sort(function (a, b) {
  return a.getLength() > b.getLength();
})

console.log(arr);
```


## 打印 Fibonacci 数（不使用全局变量）

```js
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
function fn(n) {
  var a = [];
  a[0] = 0, a[1] = 1;
  for (var i = 2; i < n; i++) {
    a[i] = a[i - 1] + a[i - 2];
  }
  for (var i = 0; i < n; i++) {
    console.log(a[i]);
  }
}

fn(20);
```


## 实现如下语法的功能 var a = (5).plus(3).minus(6);

```js
Number.prototype.plus = function (a) {
  return this + a;
};

Number.prototype.minus = function (a) {
  return this - a;
};

var a = (5).plus(3).minus(6);

console.log(a);
```


## 实现如下语法的功能 var a = add(2)(3)(4);

```js
function add(a) {
  var temp = function (b) {
    return add(a + b);
  }
  temp.valueOf = temp.toString = function () {
    return a;
  };
  return temp;
}
var ans = add(2)(3)(4);

console.log(ans);
```


## 使用 filter 确保 Observable 当中流中的值不为空

```js
dialogRef.afterClosed()
  .take(1)
  .filter(n => n)
```




## 将数组转为字典对象

```js
// obj 为传入的值
const userEntities = obj.reduce((el, c) => ({...el, c}), {})
```




## 从列表当中删除掉指定项

```js
// 从 items 中取出 id 集合
const ids = this.items.map(item => item.id);
// 然后筛选需要删除的项在数组当中所处的位置
const i = ids.indexOf(member.id);
// 进行删除
this.items = [...this.items.slice(0, i), ...this.items.slice(i + 1)]
```




## 查找列表当中指定的项

```js
export class ItemsService {
  private items: any[];

  getItem(id: number) {
    return this.items.find((item) => item.id === id);
  }
}
```

## 解析 url 为字典对象

使用方式 `getQueryObject(url).userId`

```js
function getQueryObject(url) {
  url = url == null ? window.location.href : url;
  var search = url.substring(url.lastIndexOf("?") + 1);
  var obj = {};
  var reg = /([^?&=]+)=([^?&=]*)/g;
  search.replace(reg, function (rs, $1, $2) {
    var name = decodeURIComponent($1);
    var val = decodeURIComponent($2);
    val = String(val);
    obj[name] = val;
    return rs;
  });
  return obj;
}
```

## 生成一个随机验证码

```js
function createCode() {
  var code = new Array();
  var codeLength = 4;
  var checkCode = document.getElementById("checkCode");
  checkCode.value = "";
  var selectChar = new Array(2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D',
    'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',
    'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z');
  for (var i = 0; i < codeLength; i++) {
    var charIndex = Math.floor(Math.random() * 32);
    code += selectChar[charIndex];
  }
  if (code.length != codeLength) {
    createCode();
  }
  checkCode.value = code;
}
```

## 多少秒后自动跳转

```js
function jumpTo(secs, url) {
  var obj = document.getElementById("obj");
  obj.innerHTML = secs + '秒后自动跳转';
  if (--secs > 0) {
    setTimeout("jumpTo(" + secs + ")", 1000);
  } else {
    window.location = url;
  }
}
```

## 拖拽函数

使用方式 `$(obj).drag()`

```js
$.fn.drag = function () {
  //  定义拖拽函数
  //  父元素内部的子元素的拖拽
  //  父元素需要指定高度
  var $this = $(this);
  var parent = $this.parent();
  var pw = parent.width();
  var ph = parent.height();

  var thisWidth = $this.width() + parseInt($this.css('padding-left'), 10) + parseInt($this.css('padding-right'), 10);
  var thisHeight = $this.height() + parseInt($this.css('padding-top'), 10) + parseInt($this.css('padding-bottom'), 10);
  var x, y, positionX, positionY;
  var isDown = false;

  var randY = parseInt(Math.random() * (ph - thisHeight), 10);
  var randX = parseInt(Math.random() * (pw - thisWidth), 10);
  
  parent.css({
    "position": "relative",
    "overflow": "hidden"
  });

  $this.css({
    "cursor": "move",
    "position": "absolute"
  }).css({
    top: randY,
    left: randX
  }).mousedown(function (e) {
    // 如果有多个拖拽元素，当其中一个 mousedown 的时候，当前 div 的 zIndex 为 1，其余的为 0
    parent.children().css({
      "zIndex": "0"
    });
    $this.css({
      "zIndex": "1"
    });
    //然后设置允许拖拽，设置其的position
    isDown = true;
    x = e.pageX;
    y = e.pageY;
    positionX = $this.position().left;
    positionY = $this.position().top;
    return false;
  });

  $(document).mouseup(function (e) {
    isDown = false;
  }).mousemove(function (e) {
    var xPage = e.pageX;
    var moveX = positionX + xPage - x;
    var yPage = e.pageY;
    var moveY = positionY + yPage - y;
    //判断边界
    if (isDown == true) {
      $this.css({
        "left": moveX,
        "top": moveY
      });
    } else {
      return;
    }
    if (moveX < 0) {
      $this.css({
        "left": "0"
      });
    }
    if (moveX > (pw - thisWidth)) {
      $this.css({
        "left": pw - thisWidth
      });
    }
    if (moveY < 0) {
      $this.css({
        "top": "0"
      });
    }
    if (moveY > (ph - thisHeight)) {
      $this.css({
        "top": ph - thisHeight
      });
    }
  });
};

function css(obj, attr){
  if(obj.currentStyle){
    return obj.currentStyle[attr];
  } else {
    return getComputedStyle(obj, false)[attr];
  }
}
```



## 运动函数

改变元素位置/透明度等

使用方式 `move(this, "opacity", 30) / move(this, width, 300px)`

```js
function move(obj, attr, iTarget) {
  clearInterval(obj.timer);
  obj.timer = setInterval(function () {
    var cur = 0;
    if (attr == "opacity") {
      cur = parseFloat(css(obj, attr)) * 100;
    } else {
      cur = parseInt(css(obj, attr));
    }
    var speed = (iTarget - cur) / 6;
    speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);
    if (cur == iTarget) {
      clearInterval(obj.timer);
    } else {
      if (attr == "opacity") {
        obj.style.filter = "alpha(opacity:" + (cur + speed) + ")";
        obj.style.opacity = (cur + speed) / 100;
      } else {
        obj.style[attr] = cur + speed + "px";
      }
    }
  }, 30);
};

function css(obj, attr){
  if(obj.currentStyle){
    return obj.currentStyle[attr];
  } else {
    return getComputedStyle(obj, false)[attr];
  }
}
```





## 连续运动函数

```js
/*
  不停改变元素 / 类似 `CSS3` 动画实现效果，使用方式 `act(div, "width", 0, callback)`
  可以嵌套使用，连续运动（类似 `Animate` 的回调）
  act(div, "width", 0, function () {
    act(div, "width", x + 100, function () {
      span.style.display = "block";
      span.style.right = x + 100 + "px";
    });
  });

  act(div, "left", (this.offsetLeft + 100));
*/
function act(obj, attr, target, fn) {
  clearInterval(obj.timer);
  obj.timer = setInterval(function () {
    var stop = true;
    var cur = parseInt(css(obj, attr));
    var speed = (target - cur) / 8;
    speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);
    if (cur != target) {
      stop = false;
      obj.style[attr] = speed + cur + "px";
    }
    if (stop) {
      clearInterval(obj.timer);
      obj.timer = null;
      fn && fn();
    }
  }, 30);
}
```






## 获取元素距离浏览器距离

```js
// left
var getElementLeft = function (element) {
  var actualLeft = element.offsetLeft;
  var current = element.offsetParent;
  while (current !== null) {
    actualLeft += current.offsetLeft;
    current = current.offsetParent;
  }
  return actualLeft;
}

// top
var getElementTop = function (element) {
  var actualTop = element.offsetTop;
  var current = element.offsetParent;
  while (current !== null) {
    actualTop += current.offsetTop;
    current = current.offsetParent;
  }
  return actualTop;
}
```

## 判断图片是否存在

```js
function CheckImgExists(imgurl) {
  var ImgObj = new Image();
  ImgObj.src = imgurl;
  // 没有图片，则返回 -1  
  if (ImgObj.fileSize > 0 || (ImgObj.width > 0 && ImgObj.height > 0)) {
    return true;
  } else {
    return false;
  }
}
```


## 判断图片是否加载完成

```js
var preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.onload = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
```

## 实现一个休眠函数

```js
function sleep(milliSeconds) {
  var startTime = new Date().getTime();
  while (new Date().getTime() < startTime + milliSeconds);
}
```

## 利用 canvas 图片缓存（lazyloadImage）

使用方式 `renderCvs(当前需要展示的列表)`

原理就是把图片的 `data-src` 取出来，然后放到 `canvas` 上面，同时把 `canvas` 上图片的数据取出来，然后缓存和显示

```js
var renderCvs = function (parent, max) {
  var lazyloadImage = $(".lazyload", parent);
  if (lazyloadImage.length < 1) {
    return;
  }
  var max = max || lazyloadImage.length;
  for (var i = 0; i < max; i++) {
    var imgId = lazyloadImage[i];
    var imageCache = GET(imgID);
    if (imageCache) {
      lazyloadImage[i].src = imageCache;
      continue;
    }
    var img = new Image();
    img.index = i;
    img.id = imgId;
    img.crossOrigin = "anonymous";
    img.load = function () {
      var _this = this;
      var zCvs = $("#" + this.id);
      var domCvs = zCvs[0];
      domCvs.src = this.src;
      zCvs.removeClass("lazyload");
      try {
        // 创建一个 canvas
        var cvs = document.createElement("canvas");
        cvs.style.display = "none";
        document.body.appendChild(cvs);
        // 把要画的图片画到画布上
        var rcvs = cvs.getContext("2d");
        cvs.width = 140;
        cvs.height = 108;
        rcvs.drawImage(this, 0, 0, 140, 108);
        // 缓存
        setTimeout(function () {
          // 取得的 data 是一个 base64 位的字符串
          var data = cvs.toDataURL();
          // SET(_this.id,data);
          localStorage.setItem(_this.id, data);
          document.body.removeChild(cvs);
        }, 200);
      } catch (ex) {
        // ...
      }
    }
    img.src = lazyloadImage[i].getAttribute("data-src");
  }
}
```



## 设置元素 CSS3 相关变换属性

即动态设置 `transform`，使用方式 `setCss3(div, { transform: "rotate(45deg)", transform-origin: "0 0" });`

如果想应用于动画效果，只需要将其放置在 `setInterval()` 当中即可

```js
function setCss3(obj, attrObj) {
  for (var i in attrObj) {
    var newi = i;
    // 若匹配不到符合元素，indexOf 是返回 -1，大于 0 即表示存在的时候
    if (newi.indexOf("-") > 0) {
      var num = newi.indexOf("-");
      // transform-origin 相关属性在 JS 中是 transformOrigin
      newi = newi.replace(newi.substr(num, 2), newi.substr(num + 1, 1).toUpperCase());
    }
    obj.style[newi] = attrObj[i];
    // 同上，webkitTransform
    newi = newi.replace(newi.charAt(0), newi.charAt(0).toUpperCase());
    obj.style["webkit" + newi] = attrObj[i];
    obj.style["moz" + newi] = attrObj[i];
    obj.style["o" + newi] = attrObj[i];
    obj.style["ms" + newi] = attrObj[i];
  }
}
```

## 判断上传文件大小及类型

```js
function CheckFile(obj) {
  var isIE = /msie/i.test(navigator.userAgent) && !window.opera;
  var fileSize = 0;
  var array = new Array('gif', 'png', 'jpg', 'mp4', 'ogg');  // 可以上传的文件类型  
  if (isIE && !obj.files) {
    var filePath = obj.value;
    var fileSystem = new ActiveXObject("Scripting.FileSystemObject");
    var file = fileSystem.GetFile(filePath);
    fileSize = file.Size;
  } else {
    fileSize = obj.files[0].size;
  }
  var size = fileSize / 1024;
  if (size > 1000) {
    alert("附件不能大于10M");
  }
  if (obj.value == '') {
    alert("请选择要上传的文件!");
    return false;
  } else {
    // 判断文件类型
    var fileContentType = obj.value.match(/^(.*)(\.)(.{1,8})$/)[3];
    var isExists = false;
    for (var i in array) {
      if (fileContentType.toLowerCase() == array[i].toLowerCase()) {
        isExists = true;
        return true;
      }
    }
    if (isExists == false) {
      obj.value = null;
      alert("上传文件类型不正确!");
      return false;
    }
    return false;
  }
}
```


## 判断浏览器类型

```js
// 方法一
var ie = !-[1,];
var FF = !!navigator.userAgent.match(/firefox/i);
var PC = !navigator.userAgent.match(/(iPhone|iPod|Android|ios)/i);
var Mobile = !!navigator.userAgent.match(/(iPhone|iPod|Android|ios)/i);
if (ie) {
  // ...
}

// 方法二
var Sys = {};
var ua = navigator.userAgent.toLowerCase();
var s;
(s = ua.match(/msie ([\d.]+)/)) ? Sys.ie = s[1] :
(s = ua.match(/firefox\/([\d.]+)/)) ? Sys.firefox = s[1] :
(s = ua.match(/chrome\/([\d.]+)/)) ? Sys.chrome = s[1] :
(s = ua.match(/opera.([\d.]+)/)) ? Sys.opera = s[1] :
(s = ua.match(/version\/([\d.]+).*safari/)) ? Sys.safari = s[1] : 0;

// 应用
function getScrollTop() {
  var xsun = document.documentElement.scrollTop;
  if (Sys.chrome) {
    xsun = document.body.scrollTop;
  }
  return xsun;
}

function setScrollTop(value) {
  if (Sys.chrome) {
    document.body.scrollTop = value;
  } else {
    document.documentElement.scrollTop = value;
  }
}
```

## 判断移动端机型

```js
// 方法一
if (navigator.userAgent.match(/Android/i)) {
  // Android 方法
  jsInterface.javaFunction4()
} else if ((navigator.userAgent.indexOf('iPhone') != -1)) {
  // IOS 方法名
  // test();  
} else { }

// 方法二
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) { }
```


## 点击 div 以外的地方，隐藏该 div

```js
// 一般使用在弹出层当中，比如点击弹出层之外的地方隐藏弹出层
// 原理为点击该层的时候，阻止事件冒泡
window.onload = function () {
  document.onclick = function (e) {
    $("layer").style.display = "none";
  }

  $("btn").onclick = function (e) {
    $("layer").style.display = "block";
    e = e || event; stopFunc(e);
  }

  $("layer").onclick = function (e) {
    e = e || event; stopFunc(e);
  }
}

function $(id) {
  return document.getElementById(id);
}

function stopFunc(e) {
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
}


// 也可以使用下面这种方式，即点击空白区域关闭弹窗
// 原理为判断点击事件发生在区域外的条件是
// 1. 点击事件的对象不是目标区域本身
// 2. 事件对象同时也不是目标区域的子元素
$(document).mouseup(function(e){
  var _con = $(' 目标区域 ');   // 设置目标区域
  if (!_con.is(e.target) && _con.has(e.target).length === 0) { // Mark 1
    // some code
  }
});
```


## base64 格式 转为 blob 格式

```js
function dataURItoBlob(base64Data) {
  var byteString;
  if (base64Data.split(",")[0].indexOf("base64") >= 0) {
    byteString = atob(base64Data.split(",")[1]);
  } else {
    byteString = unescape(base64Data.split(",")[1]);
  }
  var mimeString = base64Data.split(",")[0].split(":")[1].split(";")[0];
  var ia = new Uint8Array(byteString.length);
  for (var i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ia], { type: mimeString });
}
```

## 计算渐变色

使用方式为 `gradientColor(起始颜色，结束颜色，生成数量)`

```js
// 计算渐变色
gradientColor(startColor, endColor, step) {
  // 转换为 rgb 数组模式
  const startRGB = this.colorToRgb(startColor);
  const startR = startRGB[0];
  const startG = startRGB[1];
  const startB = startRGB[2];

  const endRGB = this.colorToRgb(endColor);
  const endR = endRGB[0];
  const endG = endRGB[1];
  const endB = endRGB[2];

  // 总差值
  const sR = (endR - startR) / step;
  const sG = (endG - startG) / step;
  const sB = (endB - startB) / step;

  var colorArr = [];
  for (var i = 0; i < step; i++) {
    // 计算每一步的 hex 值
    var hex = this.colorToHex('rgb(' + parseInt((sR * i + startR)) + ',' + parseInt((sG * i + startG)) + ',' + parseInt((sB * i + startB)) + ')');
    colorArr.push(hex);
  }
  return colorArr;
}

// 将 hex 表示方式转换为 rgb 表示方式（这里返回 rgb 数组模式）
colorToRgb(sColor) {
  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  var sColor = sColor.toLowerCase();
  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      var sColorNew = "#";
      for (var i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }
      sColor = sColorNew;
    }
    // 处理六位的颜色值
    var sColorChange = [];
    for (var i = 1; i < 7; i += 2) {
      sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
    }
    return sColorChange;
  } else {
    return sColor;
  }
};

// 将 rgb 表示方式转换为 hex 表示方式
colorToHex(rgb) {
  var _this = rgb;
  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
  if (/^(rgb|RGB)/.test(_this)) {
    var aColor = _this.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    var strHex = "#";
    for (var i = 0; i < aColor.length; i++) {
      var hex = Number(aColor[i]).toString(16);
      hex = hex < '10' ? 0 + '' + hex : hex;
      if (hex === "0") {
        hex += hex;
      }
      strHex += hex;
    }
    if (strHex.length !== 7) {
      strHex = _this;
    }

    return strHex;
  } else if (reg.test(_this)) {
    var aNum = _this.replace(/#/, "").split("");
    if (aNum.length === 6) {
      return _this;
    } else if (aNum.length === 3) {
      var numHex = "#";
      for (var i = 0; i < aNum.length; i += 1) {
        numHex += (aNum[i] + aNum[i]);
      }
      return numHex;
    }
  } else {
    return _this;
  }
}
```

## 获取当前元素所有最终使用的 CSS 属性值

使用方式为 `css(obj, attr)`

```js
function css(obj, attr) {
  if (obj.currentStyle) {
    return obj.currentStyle[attr];
  } else {
    return getComputedStyle(obj, null)[attr];
  }
}
```

## 获取元素的 Class

使用方式为 `getClass(div, "div_list")`

```js
function getClass(parent, cls) {
  var res = [];
  if (parent.getElementsByClassName) {
    res = parent.getElementsByClassName(cls);
  } else {
    var reg = new RegExp("\\s+|^" + cls + "\\s+|$"),
      all = parent.all;
    for (var i = 0; i < all.length; i++) {
      if (reg.test(all[i].className)) {
        res.push(all[i]);
      }
    }
  }
  return res;
}
```

## 获取一个随机的颜色

```js
function randColor() {
  return "rgb(" + Math.ceil(255 * Math.random()) + "," + Math.ceil(255 * Math.random()) + "," + Math.ceil(255 * Math.random()) + ")";
}
```

## 查询/获取字符串的 code 值

```js
function getParameterByName(name) {
  name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
    results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}
```


## 时间间隔天数计算

```js
function dateDiff(sDate1, sDate2) {
  // s1 = "2017-09-30"
  // s2 = "2017-10-08"
  // DateDiff(s1, s2)
  var aDate, oDate1, oDate2, iDays;
  aDate = sDate1.split("-")
  oDate1 = new Date(aDate[1] + '-' + aDate[2] + '-' + aDate[0])      // 转换为 12-12-2012 格式
  aDate = sDate2.split("-")
  oDate2 = new Date(aDate[1] + '-' + aDate[2] + '-' + aDate[0])
  iDays = parseInt(Math.abs(oDate1 - oDate2) / 1000 / 60 / 60 / 24)  // 把相差的毫秒数转换为天数
  return iDays
}
```

## 移动光标到内容末尾

使用方式 `moveEnd(obj)`

```js
// 方法一
function moveEnd(obj) {
  obj.focus();
  var len = obj.value.length;
  if (document.selection) {
    var sel = obj.createTextRange();
    sel.moveStart("character", len);
    sel.collapse();
    sel.select();
  } else if (typeof obj.selectionStart == "number" && typeof obj.selectionEnd == "number") {
    obj.selectionStart = obj.selectionEnd = len;
  }
}

// 方法二
// 定位 input、textarea
function po_Last(obj) {
  // 解决 ff 不获取焦点无法定位问题
  obj.focus();
  // ie11 10 9 ff safari
  if (window.getSelection) {
    // text 字符数
    var max_Len = obj.value.length;
    obj.setSelectionRange(max_Len, max_Len);
    // ie10 9 8 7 6 5
  } else if (document.selection) {
    // 创建 range
    var range = obj.createTextRange();
    // 光标移至最后
    range.collapse(false);
    // 避免产生空格
    range.select();
  }
}

// 定位 div（contenteditable = "true"）
function po_Last_Div(obj) {
  // ie11 10 9 ff safari
  if (window.getSelection) {
    // 解决 ff 不获取焦点无法定位问题
    obj.focus();
    // 创建range
    var range = window.getSelection();
    // range 选择 obj 下所有子内容
    range.selectAllChildren(obj);
    // 光标移至最后
    range.collapseToEnd();
    // ie10 9 8 7 6 5
  } else if (document.selection) {
    // 创建选择对象
    var range = document.selection.createRange();
    // range 定位到 obj
    range.moveToElementText(obj);
    // 光标移至最后
    range.collapse(false);
    range.select();
  }
}
```

## 记忆函数

```js
var memoizer = function (memo, fundamental) {
  var shell = function (n) {
    var result = memo[n];
    if (typeof result !== "number") {
      result = fundamental(shell, n);
      memo[n] = result;
    }
    return result;
  }
  return shell;
}

/* 利用上面的记忆函数计算阶乘 【 factorial(5) == 120 】*/
var factorial = memoizer([1, 1], function (shell, n) {
  return n * shell(n - 1);
})

/* 利用上面的记忆函数计算斐波那契数列 【 fibonacci(10) == 55 】*/
var fibonacci = memoizer([0, 1], function (shell, n) {
  return shell(n - 1) + shell(n - 2);
})

```


## 返回 str 中出现次数最多的字符

应用 `fineStr(str, 0, [])`

```js
function fineStr(s, n, fs) {
  var f = s.match(/^./)[0];
  var rf = new RegExp(f, "g");
  var nn = s.match(rf).length;
  if (nn == n) fs.push(f);
  if (nn > n) { fs = []; fs.push(f); n = nn }
  s = s.replace(rf, "");
  if (s.length < n) { return ["出现次数最多的字符是：" + fs.join(","), "总次数为：" + n]; }
  return fineStr(s, n, fs);
}
```



## 人名币值转换

将数值转为为人名币值（零壹贰叁肆伍陆柒捌玖）

```js
/**
 * changeMoneyToChinese
 * @param  {Number} money 
 * @return {String} chinese
 */
function changeMoneyToChinese(money) {
  var cnNums = new Array('零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖');  // 汉字的数字
  var cnIntRadice = new Array('', '拾', '佰', '仟');   // 基本单位
  var cnIntUnits = new Array('', '万', '亿', '兆');    // 对应整数部分扩展单位
  var cnDecUnits = new Array('角', '分', '毫', '厘');  // 对应小数部分单位
  var cnInteger = '整';  // 整数金额时后面跟的字符
  var cnIntLast = '元';  // 整型完以后的单位
  var maxNum = 999999999999999.9999;  // 最大处理的数字

  var IntegerNum;  // 金额整数部分
  var DecimalNum;  // 金额小数部分
  var ChineseStr = '';  // 输出的中文金额字符串
  var parts;  // 分离金额后用的数组，预定义

  if (money == '') {
    return '';
  }

  money = parseFloat(money);

  if (money >= maxNum) {
    alert('超出最大处理数字');
    return '';
  }

  if (money == 0) {
    ChineseStr = cnNums[0] + cnIntLast + cnInteger;
    return ChineseStr;
  }

  money = money.toString();  // 转换为字符串

  if (money.indexOf('.') == -1) {
    IntegerNum = money;
    DecimalNum = '';
  } else {
    parts = money.split('.');
    IntegerNum = parts[0];
    DecimalNum = parts[1].substr(0, 4);
  }

  // 获取整型部分转换
  if (parseInt(IntegerNum, 10) > 0) {
    var zeroCount = 0, IntLen = IntegerNum.length;
    for (var i = 0; i < IntLen; i++) {

      var n = IntegerNum.substr(i, 1), p = IntLen - i - 1, q = p / 4, m = p % 4;

      if (n == '0') {
        zeroCount++;
      } else {
        if (zeroCount > 0) {
          ChineseStr += cnNums[0];
        }
        // 归零
        zeroCount = 0;
        ChineseStr += cnNums[parseInt(n)] + cnIntRadice[m];
      }

      if (m == 0 && zeroCount < 4) {
        ChineseStr += cnIntUnits[q];
      }
    }

    ChineseStr += cnIntLast;
    // 整型部分处理完毕
  }

  // 小数部分
  if (DecimalNum != '') {
    var decLen = DecimalNum.length;
    for (i = 0; i < decLen; i++) {
      n = DecimalNum.substr(i, 1);
      if (n != '0') {
        ChineseStr += cnNums[Number(n)] + cnDecUnits[i];
      }
    }
  }

  if (ChineseStr == '') {
    ChineseStr += cnNums[0] + cnIntLast + cnInteger;
  } else if (DecimalNum == '') {
    ChineseStr += cnInteger;
  }

  return ChineseStr;

};
```


## 移动端适配（rem）

```js
// `meta` 设置为 `<meta(name="viewport" content="width=device-width, initial-scale=1.0, user-scalable:no")>`
// `designWidth` 为设计稿的实际宽度值，需要根据实际设置，`maxWidth` 为制作稿的最大宽度值，需要根据实际设置
// 最后面两个参数，一个为设计稿实际宽度，一个为制作稿最大宽度
; (function (designWidth, maxWidth) {
  var doc = document,
    win = window,
    docEl = doc.documentElement,
    remStyle = document.createElement("style"),
    tid;

  function refreshRem() {
    var width = docEl.getBoundingClientRect().width;
    maxWidth = maxWidth || 540;
    width > maxWidth && (width = maxWidth);
    var rem = width * 100 / designWidth;
    remStyle.innerHTML = 'html{font-size:' + rem + 'px;}';
  }

  if (docEl.firstElementChild) {
    docEl.firstElementChild.appendChild(remStyle);
  } else {
    var wrap = doc.createElement("div");
    wrap.appendChild(remStyle);
    doc.write(wrap.innerHTML);
    wrap = null;
  }
  // 要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次
  refreshRem();

  win.addEventListener("resize", function () {
    // 防止执行两次
    clearTimeout(tid); 
    tid = setTimeout(refreshRem, 300);
  }, false);

  win.addEventListener("pageshow", function (e) {
    // 浏览器后退的时候重新计算
    if (e.persisted) { 
      clearTimeout(tid);
      tid = setTimeout(refreshRem, 300);
    }
  }, false);

  if (doc.readyState === "complete") {
    doc.body.style.fontSize = "16px";
  } else {
    doc.addEventListener("DOMContentLoaded", function (e) {
      doc.body.style.fontSize = "16px";
    }, false);
  }
})(750, 750);
```



----

----

## 正则中的 test() 与 全局选项 /g

先看一个示例：

```js
var i = 0, m = 20, a = [], r = /^\d+$/g;

for (i = 0; i < m; i++) {
  a.push('' + i);
}

m = a.length;

for (i = 0; i < m; i++) {
  if (r.test(a[i])) {
    document.write(a[i] + 'true<br />');
  } else {
    document.write(a[i] + 'false<br />');
  }
}
```

也许你期待的结果应该全是 `true`，可是实际结果呢？

`true` 和 `false` 交替出现，0 是 `true`，1 是 `false`，2 是 `true`，3 是 `false`……

解决办法也很简单，把正则表达式中的全局选项 `'g'`，去掉就好了

可是为什么有 `'g'` 就会出错呢？

原因其实很简单，当一个模式具有全局选项时，和 `exec` 一样，每次 `test` 都会保留上次匹配的位置——即 `lastIndex`

很显然，当第一次匹配之后，第二次匹配时的 `lastIndex` 已经到了字符串末尾，尽管这个时候字符串已经是一个新的字符串了，但是这个 `lastIndex` 的位置并没有重新初始化，所以会从末尾开始匹配——当然会匹配失败了

#### 解决方案有两种

1. 去掉正则表达式后面的 `g`

2. 每次完成匹配之后重置模式的 `lastIndex` 属性


关于 `lastIndex` 属性，见 [RegExp.lastIndex](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex)

使用重置 `lastIndex` 的代码：

```js
var i = 0, m = 20, a = [], r = /^\d+$/g;

for (i = 0; i < m; i++) {
  a.push('' + i);
}

m = a.length;

for (i = 0; i < m; i++) {
  if (r.test(a[i])) {
    document.write(a[i] + 'true<br />');
  } else {
    document.write(a[i] + 'false<br />');
  }
  r.lastIndex = 0;
}
```


## 输入框过滤

文本框只能输入数字代码（小数点也不能输入）

```html
<input onkeyup="this.value=this.value.replace(/\D/g,'')" onafterpaste="this.value=this.value.replace(/\D/g,'')">
```

只能输入数字,能输小数点

```html
<input onkeyup="if(isNaN(value))execCommand('undo')" onafterpaste="if(isNaN(value))execCommand('undo')">

<input name=txt1 onchange="if(/\D/.test(this.value)){alert('只能输入数字');this.value='';}">
```

允许输入负数

```js
if (!/^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test($(this).val())) {
  // ...
}
```

保留两位小数

```js
$('input').on('keyup', function (event) {

  // 移除左右方向键和后退键位
  var $amountInput = $(this);
  event = window.event || event;
  if (event.keyCode == 37 | event.keyCode == 39 | event.keyCode == 8) {
      return;
  }

  // 先替换掉非数字，除了数字和. 
  $amountInput.val($amountInput.val().replace(/[^\d.]/g, '').
    // 只允许出现一个小数点              
    replace(/^\./g, '').replace(/\.{2,}/g, '.').
    // 小数点最多保留两位
    replace('.', '$#$').replace(/\./g, '').replace('$#$', '.').replace(/^(\-)*(\d+)\.(\d\d).*$/, '$1$2.$3'));

});

// 失去焦点的时候，如果最后一位是小数点，则直接剔除（另外还要绑定一个事件）
$(this).val($(this).val().replace(/\.$/g, ''))
```

