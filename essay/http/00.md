

## cookie / csrf / xss

#### Cookie 机制（客户端）

因为 `HTTP` 协议是无状态的协议，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接

这就意味着服务器无法从连接上跟踪会话，所以利用 `Cookie` 来确认用户的身份

`Cookie` 实际上是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用 `response` 向客户端浏览器颁发一个 `Cookie`，客户端浏览器会把 `Cookie` 保存起来

当浏览器再请求该网站时，浏览器把请求的网址连同该 `Cookie` 一同提交给服务器，服务器检查该 `Cookie`，以此来辨认用户状态，服务器还可以根据需要修改 `Cookie` 的内容

#### Session 机制（服务端）

除了使用 `Cookie`，`Web` 应用程序中还经常使用 `Session` 来记录客户端状态，`Session` 是服务器端使用的一种记录客户端状态的机制，使用上比 `Cookie` 简单一些，相应的也增加了服务器的存储压力

`Session` 是另一种记录客户状态的机制，不同的是 `Cookie` 保存在客户端浏览器中，而 `Session` 保存在服务器上

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 `Session`，客户端浏览器再次访问时只需要从该 `Session` 中查找该客户的状态就可以了

如果说 `Cookie` 机制是通过检查客户身上的 "通行证" 来确定客户身份的话，那么 `Session` 机制就是通过检查服务器上的 "客户明细表" 来确认客户身份，`Session` 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了

> `Session` 对象是在客户端第一次请求服务器的时候创建的


#### XSS

全名是：`Cross-site scripting`，为了和 `CSS` 层叠样式表区分所以取名 `XSS`

`XSS` 其实就是 `Html` 的注入问题，攻击者的输入没有经过严格的控制进入了数据库，最终显示给来访的用户，导致可以在来访用户的浏览器里以浏览用户的身份执行 `Html` 代码，工作原理大致如下

`
攻击者发现 XSS 漏洞 —— 构造代码 —— 发送给受害人 —— 受害人打开 —— 攻击者获取受害人的 cookie —— 完成攻击
`

当用户的 `cookie` 被拿到以后，如果服务端 `session` 没有设置过期的话，以后甚至拿这个 `cookie` 而不需用户名密码，就可以以这个用户的身份登录成功了

但是 `XSS` 容易发现，因为攻击者需要登录后台完成攻击，管理员可以看日志发现攻击者


#### CSRF

全名是：`Cross-site request forgery`，中文名称：跨站请求伪造，与 `XSS` 非常不同，`XSS` 利用站点内的信任用户，而 `CSRF` 则通过伪装来自受信任用户的请求来利用受信任的网站

与 `XSS` 攻击相比，`CSRF` 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 `XSS` 更具危险性

可以这么理解 `CSRF` 攻击：攻击者盗用了你的身份，以你的名义发送恶意请求

要完成一次 `CSRF` 攻击，受害者必须依次完成两个步骤：

* 登录受信任网站 `A`，并在本地生成 `Cookie`

* 在不登出 `A` 的情况下，访问危险网站 `B`

`CSRF` 攻击是源于 `WEB` 的隐式身份验证机制，`WEB` 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的

#### 防御

可以从服务端和客户端两方面着手，总的思想都是一致的，就是在客户端页面增加伪随机数，让钓鱼网站无法正常伪造请求














## SEO

#### META 标签

`META` 标签主要用于 `SEO` 优化，让搜索引擎能够发现你的页面，要让搜索引擎找到你，需要添加 `Keywords` 和 `description` 的 `meta` 标签

```html
<meta name="keywords" content="MP4, music, MP3"/>

<meta name="description" content="音乐,电影,视频"/>  
```

其他方法：

* 关键字隐藏在页面里，设定字体颜色跟背景一样

* 图片资源的 `alt` 属性里添加关键字（`<img src="..." alt="keywords">`）

* 在 `html` 注释中添加关键字


#### 正向代理与反向代理

**正向代理**

正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器

然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理

最后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程

![正向代理](http://images0.cnblogs.com/blog2015/456795/201507/051157002507977.jpg)

**反向代理**

反向代理方式是指代理原始服务器来接受来自 `Internet` 的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给 `Internet` 上请求数据的客户端

顾名思义，反向代理就是位于 `Internet` 和原始服务器之间的服务器，对于客户端来说就表现为一台服务器

客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配

![反向代理](http://images0.cnblogs.com/blog2015/456795/201507/051215042498342.jpg)

**性能优化之反向代理**

和传统的代理服务器一样，反向代理服务器也有保护网站安全的作用，来自互联网的请求必须经过反向代理服务器，相当于在原始服务器之间增加一道屏障

除了安全功能，反向代理服务器也可以通过配置缓存功能加速 `web` 请求，当用户第一次访问静态内容的时候，静态内容就被缓存在反向代理服务器上，下一次用户请求静态资源时，直接从反向代理服务器返回静态内容，加速 `web` 请求访问速度，减轻原始服务器的压力

此外，反向代理服务器也可实现负载均衡的功能，而通过负载均衡构建应用集群可以提高系统的总处理能力，进而改善网站在高并发情况下的性能









## 网络协议的分层结构

#### 一. 协议的分层结构的概述

协议分层结构的思想是用一个模块的集合来完成不同的通信功能，以简化设计的复杂性，大多数的网络都按照层或级的方式来组织，每一层完成特定的功能，每一层都建立在它的下层之上

#### 二. 协议的分层结构的优点

1. 各层之间相互独立，复杂程度下降

2. 结构上可分隔开：各层都可以采用最合适的技术来实现

3. 易于实现和维护：系统已被分解为若干个相对独立的子系统

4. 灵活性好：一层发生变化其他各层不受影响

5. 能促进标准化工作：每一层的功能及所提供的服务都有精确的说明

#### 三. 协议的层次结构划分的原则

1. 每层的功能应是明确的，并且是相互独立的，当某一层的具体实现方法更新时，只要保持上､下层的接口不变，便不会对邻居产生影响

2. 层间接口必须清晰，跨越接口的信息量应尽可能少

3. 层数应适中｡若层数太少，则造成每一层的计算机网络协议太复杂;若层数太多，则体系结构过于复杂，使描述和实现各层功能变得困难
