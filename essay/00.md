无意中发现了一份面试题，引用文章评论当中的一句话，还真是原以为已经触摸到王者的门槛，没想到原来一直在青铜徘徊

特意抽些时间摸索摸索试试自己的斤两，顺便记录一下

原文地址见 [front-end-javascript-interviews](https://blog.webf.zone/front-end-javascript-interviews-in-2018-19-e17b0b10514)

----


## 使以下代码正常运行

```js
const a = [1, 2, 3, 4, 5]

// 补齐这里

a.multiply();
console.log(a);  // [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]
```

#### 解决方式

两种方式，不过原理都是利用 `map` 来计算乘积在进行返回

```js
// 方法一
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return this.push(...this.map(x => x * x));
}

a.multiply();
console.log(a);

// 方法二
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return Object.assign(this, [...this, ...this.map(x => x * x)]);

  // 或者使用下面这样
  return Object.assign(this, this.concat(...this.map(x => x * x)));
}

a.multiply();
console.log(a);
```




## 为什么 0.2 + 0.1 === 0.3 返回 false

在展开这个问题之前，我们需要先了解计算机内部是如何表示数的

在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数

看下面两个例子

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|13|	10|	13|	1x10^1 + 3x10^0 = 10 + 3|
|13|	2	|1101|	1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1|
|上面是整数，下面则是小数||||
|0.625|	10|	0.625|	6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005|
|0.625|	2|	0.101|	1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8|

简单来说

* 十进制整数转二进制方法 -- 除 `2` 取余

* 十进制小数转二进制方法 -- 乘 `2` 除整

在这里就不得不提 `0.1` 这个比较特殊的小数了，`0.1` 的二进制格式是 `0.0001100011....`

这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数

这里就会存在一个**在某个精度点直接舍弃**的操作，当然，代价就是，`0.1` 在计算机内部根本就不是精确的 `0.1`，而是一个有舍入误差的 `0.1`

当代码被编译或解释后，`0.1` 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 `0.1 + 0.2` 不等于 `0.3` 的原因

这里就会引申出另外一个问题，如下

#### 为什么 0.1 + 0.1 却等于 0.2

结果是，两个有舍入误差的值在求和时，相互抵消了，但这种 "负负得正，相互抵消" 不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消

另一个需要注意的是，二进制能精确地表示位数有限且分母是 `2` 的倍数的小数，比如 `0.5`，`0.5` 在计算机内部就没有舍入误差，所以 `0.5 + 0.5 === 1`

在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在

虽然允许误差存在，但是**永远不要直接比较两个浮点的大小**

一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差

如果非要计算一些浮点数，可以采用第三方库，比如 [bignumber](https://github.com/MikeMcl/bignumber.js) 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望

```js
{
  let x = new BigNumber(0.1);
  let y = new BigNumber(0.2)
  let z = new BigNumber(0.3)

  console.log(z.equals(x.add(y)))   // 0.3 === 0.1 + 0.2, true
  console.log(z.minus(x).equals(y)) // true
  console.log(z.minus(y).equals(x)) // true
}

{
  let x = 0.2
  console.log(x * x === 0.04) // false
  let y = new BigNumber(0.2)
  let r = y.mul(y)            // 0.04
  console.log(r.equals(new BigNumber(0.04))) // true
}
```


#### 小小总结

* 为什么 `0.1 + 0.2` 不等于 `0.3`，因为计算机不能精确表示 `0.1`， `0.2` 这样的浮点数，计算时使用的是带有舍入误差的数

* 并不是所有的浮点数在计算机内部都存在舍入误差，比如 `0.5` 就没有舍入误差

* 具有舍入误差的运算结可能会符合我们的期望，原因可能是 "负负得正"

* 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 `bignumber.js` 这样的浮点数运算库











## JavaScript 中有哪些数据类型？

`6` 种原始类型（`Boolean`，`Null`，`Undefined`，`Number`，`String`，`Symbol`）和 `Object`



<!-- ## 普通回调，promises，observables，generator 或 async-wait -->


## 使用 Proxy 实现简单的数据绑定

关于数据双向绑定，之前也一直是在各大框架的基础上面来直接使用，并没有真正的深入了解其内部原理的实现，所以再次遇到这个问题的时候就抽了点时间来研究研究

也算是补习补习，当然并不仅限于 `Proxy`，详细见






































## CSS 操作

## 伪类和伪元素的区别 && 如何操作 CSS 的伪类和伪元素

https://segmentfault.com/a/1190000003711146

http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/











































// javascript


介绍一下基本数据类型，Map，Symbol，Set

什么是原型链 ==》 原型链的最顶端（原型链顶部（Object.prototype.__proto__ === null）） ==》 如何创建一个没有原型的对象（Object.create(null)） ==》 类式继承和原型继承

使用 new 的时候发生了什么

this ==》 箭头函数中的 this ==》 函数中返回的函数中的 this



----


如何判断一个对象是否存在（null）（for...in， stringify()， Object.keys()），如何判断一个变量是 string（包装对象 new String，Object.prototype.toString.call(s)， constructor）

addEventListener 最后一个参数 ==》 三个嵌套的 div，最内层的一个元素绑定两个点击事件，一个捕获，一个冒泡，会先执行哪一个

事件捕获和事件冒泡 ==》 低版本的 IE 中，为什么绑定点击事件要绑定到 document 上（因为只能冒泡到 document）

* 如果不是最内层的元素，依然是先捕获后冒泡

* 如果是最内层的元素同时绑定有捕获和冒泡事件，则哪个事件写在前面就先执行哪一个，不再区分捕获或冒泡

* 可以对同一个元素绑定多个事件监听函数，彼此之间不会覆盖，按先后顺序执行

闭包（如何取得异步请求当中的数据）

介绍一下 call 和 apply ==》 哪个速度更快一些（call，因为不存在数组遍历） ==》 第一个参数 ==》 如果传递 null => window，严格模式下不做转换 ==》 bind 简单实现

* function fun() { alert(this) }  fun.call(1); // 1


----

如何监听数组和对象的改变（getter/setter，defineProperties，proxies）

如何克隆一个对象


----

原生 ajax ==》 open() 方法的第三个参数表示采用异步（true）还是同步（false） ==》 post 请求如何发送键值对形式数据（指定 content-type 为 "application/x-www-form-urlencoded"）

同源策略/跨域 ==》 如果是 PUT 或者 DELETE 请求 ==》 promise 和 setTimeout 执行顺序（任务队列【ES6】在事件循环队列之上） ==》 任务队列，then 应当会放到当前 tick 的最后，但是还是在当前 tick 中

settimeout 和 promise 先后顺序

rxjs ==》 三个状态，next，error，complete ==》 Subject

介绍几个操作符 ==》 Subject()


================================================

列表中插入 3，300，3000 个 li，并且绑定点击事件

如何生成一个 m 长度，内容都为 n 的数组

点击其他区域关闭弹窗（回字布局结构）

数组去重

求一个数组中的最大值 ==》 删除一个数组中的指定项

生成 [0, 1, 2, 3 ... N - 1] 的数组


================================================


代码的复用（函数封装, 继承（圣杯模式）, 复制 extend, 混入 mixin, 借用 apply/call）

垃圾回收机制（标记清除，引用计数）

http 状态码（304，302，400，405）

http2（二进制帧，多路复用，请求优先级，流量控制，服务器端推送以及首部压缩）

域名发散与收敛

打包/部署

----

----


================================================

// jquery

$(document).ready() 是个什么函数  ==》 和 window.onload 有什么不同

$.each 和 $(selector).each() 的区别

$(this) 和 this

链式操作是如何实现的

源码有没有了解 ==》 




================================================

// css

盒模型，BFC（触发条件）

position ==》 float + position 以哪个为基准

水平，垂直居中（fit-content）

文字和图片居中对齐（如果文本变成 inline-block）

div 中有一个浮动的 img，高度如何 ==》 img 加上定位属性后高度如何 ==》 外层的 div 也加上浮动后如何

==》 怎么去除浮动 ==》 引起浮动的原因（BFC） ==》 哪些元素可以引起 BFC（IE 中如何触发 layout） ==》 IFC ==》 什么是 hasLayout

flex ==》 取值（0 1 auto） ==》 如何覆盖父元素指定的排列方式（align-self）

em 和 rem 区别

html 和 body 的区别

多行溢出隐藏

三个盒子 一个居左 两个居右 space-between

line-height:150%（先计算） 和 line-height:1.5（子元素）


================================================

// angular

constructor() 和 ngOnInit()（构造函数中，是无法获取输入属性的值）

如何引入第三方库

如果两次导入同一个模块会怎么样

[innerHtml] 时内容被转义

如何保证模块只加载一次（@Optional()，@SkipSelf()）

如何修改组件当前引用的组件样式（:host 和 ::ng-deep）

如何动态加载已经声明的组件 ==》 如何向动态添加的组件传递数据 ==》 如何进行通信 ==》 动态生成的组件，this.componentRef.instance.data 保证 data 是最新的

* ViewChild 获取引用，ComponentFactoryResolver 解析已经声明的组件，createComponent 呈现

组件之间传参的方式

emit() 事件如何变成异步的（true）

[] 和 {{}} 的差异（[attr.property]）

变化检测机制（Default 和 OnPush）




依赖注入 ==》 @Injectable() 是不是必须 ==》 什么情况下使用 @Inject() （非 Type 类型） ==》 Why（只有是 Type 类型的对象，才会被 TypeScript 编译器编译）

==》 那么 Type 类型的参数是否可以使用 @Inject(Type) 的方式注入

注入的时候，如何使用尚未定义的依赖对象类型（先后顺序，forwardRef(() => ...)）

ViewEncapsulation（Native、Emulated、None）

如何手动过滤输入值（this.sanitizer.sanitize(SecurityContext.HTML, "<h1>Sanitize</h1><script>attackerCode()</script>");）

Redux

effect

================================================

// Vue

Vue 的双向数据绑定（响应式）原理是什么？

父子组件之间参数传递 ==》 子组件需要修改 props

methods 和 computed 的区别



================================================

// react

左侧 dispatch 右侧去取，如何保证数据是最新的（concat）

调用 setState 之后发生了什么？



================================================

// Node.js

如何处理静态资源，比如请求了一张图片，怎么操作

如何控制并发（eventproxy，async）  ==》 两者的区别（多个源（小于 10）汇总数据用 eventproxy）

如何介绍 post 请求过来的数据（body-parser）

koa 和 express 区别
