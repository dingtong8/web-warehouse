## JavaScript 中的数据绑定

关于数据双向绑定，绑定的基础就是监听属性的变化事件（`propertyChange`），现在主流的框架当中的解决方法一般有以下几种

* `Knockout` / `Backbone`（发布/订阅模式），简单来说就是另外开发一套 `API`，但使用起来却不得不使用这套 `API` 来操作 `viewModel`，导致上手复杂、代码繁琐

* `Angular`（脏检查机制），特点是直接使用原生 `JavaScript` 来操作 `viewModel`，但脏检查机制随之带来的就是性能问题

* `Vue`（`Object.defineProperty`），会把定义的 viewModel 对象（即 `data` 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 `JavaScript` 操作对象，又可以主动触发 `propertyChange` 事件，效率虽高，但也有一些限制，见后文

另外的几种方式

* `Object.observe`，谷歌对于简化双向绑定机制的尝试，在 `Chrome 49` 中引入，然而由于性能等问题，并没有被其他各大浏览器及 `ES` 标准所接受，所以在后续版本当中移除了该方法的实现

* `Proxy`，是 `ES6` 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 `Object.observe` 以实现双向绑定）



## Object.defineProperty

那么 `Vue` 是如何实现双向数据绑定的呢？简单来说，是数据劫持，更应该说是对数据对象的 `Setter` 和 `Getter` 实现的劫持，但是也不完全

因为 `Object.defineProperty` 仅仅是实现了对数据的监控，而 `UI` 的重新渲染则是当监控的数据对象被更改后，这个变更会被广播给所有订阅该数据的 `watcher`，然后由该 `watcher` 实现对页面的重新渲染

下面从一个简单的例子开始，首先是页面布局，很简答，一个标题，一个输入框和一个按钮

```html
<h1 id='h1'></h1>
<input type="text" id="inp" onkeyup="inputChange(event)">
<input type="button" value="加" onclick="btnAdd()" />
```

绑定代码如下

```js
// 首先先定义一个数据源，需要注意，数据源仅仅是一个简单的对象
let vm = {
  value: 0
}

// 然后定义一个 Dep，用于存储 watcher
let Dep = function () {
  this.list = [];

  this.add = function (watcher) {
    this.list.push(watcher)
  },

  this.notify = function (newValue) {
    this.list.forEach(function (fn) {
      fn(newValue)
    })
  }
};

// 因为需要渲染的有两个地方，一个标题，一个输入框，所以需要两个 watcher，存入 Dep
function renderInput(newValue) {
  let el = document.getElementById('inp');
  if (el) {
    el.value = newValue
  }
}

function renderTitle(newValue) {
  let el = document.getElementById('h1');
  if (el) {
    el.innerHTML = newValue
  }
}

// 将解析出来的 watcher 存入 Dep 中待用
let dep = new Dep();
dep.add(renderInput);
dep.add(renderTitle)

// 核心方法
// 使用 Object.defineProperty 来定义一个 Observer
function initMVVM(vm) {
  Object.keys(vm).forEach(function (key) {
    observer(vm, key, vm[key])
  })
}

function observer(vm, key, value) {
  Object.defineProperty(vm, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      console.log(`Get`);
      return value
    },
    set: function (newValue) {
      if (value !== newValue) {
        value = newValue
        console.log(`Set`)
        // 将变动通知给相关的订阅者
        dep.notify(newValue)
      }
    }
  })
}

// 页面引用的方法
function inputChange(ev) {
  let value = Number.parseInt(ev.target.value);
  vm.value = (Number.isNaN(value)) ? 0 : value;
}

function btnAdd() {
  vm.value = vm.value + 1;
}

// 初始化数据源
initMVVM(vm)

// 初始化页面
dep.notify(vm.value);
```

但是这样存在一定的局限性，比如当 `data` 为一个数组的时候，就会存在一定的问题，如下

```js
let data = {
  list: []
}

Object.keys(data).forEach(function (key) {
  let value = data[key];
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get() {
      return value;
    },
    set(newValue) {
      console.log(`Setting`);
      value = newValue;
      return true;
    }
  })
})

data.list.push(1);      // 不会触发
data.list = [1, 2, 3];  // 替换的话，则会触发
```

运行后可以发现，当向 `list` 里 `push` 元素的时候并不会触发，而当直接替换 `list` 对象的时候却会触发了，所以这就是 `Object.defineProperty` 在数组监控方面的不足

在 `Vue` 当中处理的方式就是覆写数组对象中的方法，在调用数组方法的同时能触发回调

```js
function initMVVM(vm) {
  Object.keys(vm).forEach(function (key) {
    let value = vm[key];
    if (Array.isArray(value)) {
      observeArray(vm, key)
    }
  })
}

function observeArray(vm, key) {
  let arrayMethod = bindWatcherToArray();
  vm[key].__proto__ = arrayMethod;
}

function bindWatcherToArray() {
  let arrayMethod = Object.create(Array.prototype);
  ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
    Object.defineProperty(arrayMethod, method, {
      enumerable: true,
      configurable: true,
      value: function () {
        let args = [...arguments]
        Array.prototype[method].apply(this, args);
        console.log(`operation: ${method}`)
        dep.notify();
      }
    })
  });
  return arrayMethod
}
```

> 同时这样做的好处是，仅仅是数据中的数组对象的原型被修改掉了，并不会影响到全局的数组对象




## Proxy