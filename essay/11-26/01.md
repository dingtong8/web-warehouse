无意中发现了一份面试题，引用文章评论当中的一句话，还真是原以为已经触摸到王者的门槛，没想到原来一直在青铜徘徊

特意抽些时间摸索摸索试试自己的斤两，顺便记录一下

原文地址见 [front-end-javascript-interviews](https://blog.webf.zone/front-end-javascript-interviews-in-2018-19-e17b0b10514)

----


## 01. 使以下代码正常运行

```js
const a = [1, 2, 3, 4, 5]

// 补齐这里

a.multiply();
console.log(a);  // [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]
```

#### 解决方式

两种方式，不过原理都是利用 `map` 来计算乘积在进行返回

```js
// 方法一
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return this.push(...this.map(x => x * x));
}

a.multiply();
console.log(a);

// 方法二
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return Object.assign(this, [...this, ...this.map(x => x * x)]);

  // 或者使用下面这样
  return Object.assign(this, this.concat(...this.map(x => x * x)));
}

a.multiply();
console.log(a);
```




## 02. 为什么 0.2 + 0.1 === 0.3 返回 false

在展开这个问题之前，我们需要先了解计算机内部是如何表示数的

在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数

看下面两个例子

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|13|	10|	13|	1x10^1 + 3x10^0 = 10 + 3|
|13|	2	|1101|	1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1|
|上面是整数，下面则是小数||||
|0.625|	10|	0.625|	6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005|
|0.625|	2|	0.101|	1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8|

简单来说

* 十进制整数转二进制方法 -- 除 `2` 取余

* 十进制小数转二进制方法 -- 乘 `2` 除整

在这里就不得不提 `0.1` 这个比较特殊的小数了，`0.1` 的二进制格式是 `0.0001100011....`

这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数

这里就会存在一个**在某个精度点直接舍弃**的操作，当然，代价就是，`0.1` 在计算机内部根本就不是精确的 `0.1`，而是一个有舍入误差的 `0.1`

当代码被编译或解释后，`0.1` 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 `0.1 + 0.2` 不等于 `0.3` 的原因

这里就会引申出另外一个问题，如下

#### 为什么 0.1 + 0.1 却等于 0.2

待续