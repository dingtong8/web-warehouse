## $.each 和 $(selector).each() 的区别

#### $(selector).each()

```$(selector).each()``` 一般用于 ```jquery``` 对象的遍历

```each()``` 方法为每个匹配元素规定要运行的函数

```js
$("ul li").each(function(){
  alert($(this).text())
});
```

通过源码可知，```each``` 方法实际上调用的就是 ```jQuery.each()``` 方法

```js
each: function( callback, args ) {  
  return jQuery.each( this, callback, args );
}  
```

####  $.each

而 ```$.each()``` 使用的范围就很广了，可用于遍历任何的集合（无论是数组或对象） 

下面是几个例子：

```js
// 参数 i 为遍历索引值，n 为当前的遍历对象
$.each([{ name: "limeng", email: "zhangsan" }, { name: "hehe", email: "zhangsan" }], function (i, n) {
  console.log("索引:" + i + "对应值为：" + n.name);
});


var arr1 = ["one", "two", "three", "four", "five"];
$.each(arr1, function () {
  console.log(this);
});


var arr2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
$.each(arr2, function (i, item) {
  console.log(item[0]);  // 1 4 7
});


var obj = { one: 1, two: 2, three: 3, four: 4, five: 5 };
$.each(obj, function (key, val) {
  console.log(obj[key]);  // 1 2 3 4 5
});
```

```jQuery each``` 源码如下：

方法 ```.each()``` 遍历当前 ```jQuery``` 对象，并在每个元素上执行回调函数，每当回调函数执行时，会传递当前循环次数作为参数，循环次数从 ```0``` 开始计数

更重要的是，**回调函数是在当前元素为上下文的语境中触发的，即关键字 this 总是指向当前元素**，在回调函数中返回 ```false``` 可以终止遍历

```js
//  jQuery.each 方法用于遍历一个数组或对象,并对当前遍历的元素进行处理  
//  jQuery.each 方法可以为处理函数增加附带的参数(带参数与不带参数的回调使用方法不完全一致)  

// 静态方法 jQuery.each() 是一个通用的遍历迭代方法，用于无缝地遍历对象和数组
// 对于数组和含有 length 属性的类数组对象（如函数参数对象 arguments），该方法通过下标遍历，从 0 到 length-1
// 对于其他对象则通过属性名遍历（for-in），在遍历过程中，如果回调函数返回 false

// ------------------------------------------

// 总的来说就是：

// 1. 对于对象，通过 for-in 循环遍历属性名，对于数组或类数组对象，则通过 for 循环遍历下标

// 2. 如果传入了参数 args，使用 apply，执行回调函数时只传入一个参数 args

// 3. 如果未传入参数 args，使用 call，执行回调函数时传入两个参数：下标或属性名，对应的元素或属性值

// ------------------------------------------

// 关于参数 args：传给回调函数 callback 的参数数组，可选
// 如果没有传入参数 args，则执行回调函数时会传入两个参数（下标或属性名，对应的元素或属性值）
// 如果传入了参数 args，则只把该参数传给回调函数
each: function (object, callback, args) {

  // 当需要遍历的是一个对象时, name 变量用于记录对象的属性名   
  var name,

    // 当需要遍历的是一个数组时, i 变量用于记录循环的数组下标   
    i = 0,

    // 遍历数组长度,当需要遍历的对象是一个数组时存储数组长度   
    // 如果需要遍历的是一个对象, 则 length === undefined   
    length = object.length,

    // 变量 isObj 表示参数 object 是对象还是数组，以便决定遍历方式
    // 如果 object.length 是 undefined 或 object 是函数，则认为 object 是对象，设置变量 isObj 为 true，将通过属性名遍历
    // 否则认为是数组或类数组对象，设置变量 isObj 为 false，将通过下标遍历
    isObj = length === undefined || jQuery.isFunction(object);

  // 回调函数具有附加参数时, 执行第一个分支   
  // if(!!args) {   
  if (args) {

    // 需要遍历的是一个对象   
    if (isObj) {

      // 遍历对象属性, name 是对象的属性名,再函数顶部已声明 
      for (name in object) {

        // 调用 callback 回调函数, 且回调函数的作用域表示为当前属性的值   
        if (callback.apply(object[name], args) === false) {

          // 如果在 callback 回调函数中使用 return false; 则不执行下一次循环   
          break;
        }
      }
    }
    // 需要遍历的是一个数组   
    else {

      // 循环变量的自增在循环内部执行   
      for (; i < length;) {

        // 调用 callback 函数, 与上面的 callback 调用一致   
        // 此处 callback 函数中的 this 指向当前数组元素   
        // 根据下标 i 依次执行
        if (callback.apply(object[i++], args) === false) {
          break;
        }
      }
    }

  }

  // 回调函数没有附加参数时,执行第二个分支   
  else {

    // 需要遍历的是一个对象   
    if (isObj) {

      for (name in object) {

        // 调用 callback 回调函数   
        // 在不带参数的对象遍历中, 作用域表示为当前属性的值   
        // 且回调函数包含两个参数, 第一个数当前属性名, 第二个是当前属性值    
        if (callback.call(object[name], name, object[name]) === false) {

          // 作用同上
          break;
        }
      }
    }
    // 需要遍历的是一个数组   
    else {
      for (var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
      }
    }
  }

  // 最后，返回传入的参数 object
  // 方法 .each() 调用 jQuery.each() 时，把当前 jQuery 对象作为参数 object 传入，这里返回该参数，以支持链式语法 
  return object;
}
```

## jQuery 的 DOM 操作原理

这里只简单的介绍一下，具体实现可以参考源码

`jQuery` 使用 `jQuery` 对象的形式将 `Element` 对象进行封装，把复杂的 `DOM` 定义简化为对 `jQuery` 对象

`jQuery` 对于 `DOM` 封装的另一个核心就是其缓存功能，`jQuery` 将 `jQuery` 对象的变量（如事件、动画、第三方扩展的属性）都保存缓存中，而缓存又保存在实际 `Element` 对象中

所以当这个 `Element` 对象被再一次封装为 `jQuery` 对象的时候，是可以继承之前的缓存进而可以继续之前的操作

这个特性使得我们不用特意去缓存 `jQuery` 对象的引用，需要用的时候随时可以再一次将 `Element` 对象封装为 `jQuery` 对象，而不用担心两个的 `jQuery` 对象操作上会产生数据上的差异，即 `jQuery` 对象不保存任何 `Element` 元素相关信息，所有的相关信息都保存在 `DOM` 本身中

#### jQuery 的 DOM 操作 API

`DOM` 操作的 `API` 也很多，大致可以分为 `5` 大类

* `DOM` 元素的创建

```js
jQuery(html,[ownerDoc])
jQuery.fn.html([val|fn])
// ...
```

* `DOM` 元素的插入

```js
jQuery.fn.append(content|fn)
jQuery.fn.before(content|fn)
jQuery.fn.wrap(html|ele|fn)
// ...
```

* `DOM` 元素的修改

```js
jQuery.fn.attr(name|pro|key,val|fn)
jQuery.fn.removeAttr(name)
// ...
```

* `DOM` 元素的删除

```js
jQuery.fn.empty()
jQuery.fn.remove([expr])
jQuery.fn.html([val|fn])
// ...
```

* `DOM` 的 `ready`

```js
jQuery(callback)
jQuery.ready(hold)
// ...
```

其中很多 `API` 都是对底层 `API` 的封装，可以归纳为以下（包括私有 `API`）

* `DOM` 元素的创建

```js
jQuery.fn.clone([Even[,deepEven]])
buildFragment
```

* `DOM` 元素的插入

```js
domManip
buildFragment
```

* `DOM` 元素的修改

```js
access
```

* `DOM` 元素的删除

```js
jQuery.fn.cleanData( elems )
remove( elem, selector, keepData )
```

* `DOM` 的 `ready`

```js
jQuery.ready
```

## jQuery 选择器原理

主要分为两块，`$(..)` 和 `Sizzle` 选择器引擎，后者只有在处理选择器表达式时才会调用


#### $(..)

当我们使用 `jQuery` 选择器的时候，`$(..)` 会默认去执行 `jQuery` 内部封装好的一个 `init` 的构造函数，每次申明一个 `jQuery` 对象的时候，返回的是 `jQuery.prototype.init` 对象

即当我们使用选择器的时候 `$(selector,content)`，就会执行 `init(selectot,content)`

```js
if (typeof selector == "string") {

  // 正则匹配，看是不是 HTML 代码或者是 #id
  var match = quickExpr.exec(selector);

  // 没有作为待查找的 DOM 元素集、文档或 jQuery 对象
  // selector 是 #id 的形式
  if (match && (match[1] || !context)) {

    // HANDLE ==> $(html) -> $(array)
    // HTML 代码，调用 clean 补全 HTML 代码
    if (match[1]) {
      selector = jQuery.clean([match[1]], context);

      // 是 ==>  $("#id")
    } else {

      // 判断 id 的 Dom 是不是加载完成
      var elem = document.getElementById(match[3]);

      if (elem) {

        if (elem.id != match[3]) return jQuery().find(selector);

        // 执行完毕 return
        return jQuery(elem);
      }

      selector = [];

    }
    // 非 id 的形式，在 context 中或者是全文查找
  } else {
    return jQuery(context).find(selector);
  }
}
```


#### Sizzle 选择器引擎

关于 Sizzle 选择器引擎可以参考 [JQuery - Sizzle 选择器引擎原理分析](https://segmentfault.com/a/1190000003933990)



## jQuery 插件中的 return this.each()

原理是通过返回当前对象，来维护链式调用

同时也是是为了保证遍历完成后才执行下一个操作，否则迭代是延迟执行的，前面的插件并没有实际执行，而且 ```each``` 返回的也是 ```this``` 对象（还可以带 ```function``` 参数）

简单来说就是一个是先返回在执行，一个是先执行在返回

看下面代码就明白了：

```js
return this.each(function () {
  $(this).append(' - ' + $(this).data('x'));
});

// 等价于

var objs = this;

for (var i = 0; i < objs.length; i++) {
  var obj = objs[i];
  $(obj).append(' - ' + $(obj).data('x'));
};

return this;
```




## jQuery 中的 this 和 $(this)

其实同 ```jQuery``` 中的 ```get()``` 和 ```eq()``` 类似，```$(this)``` 返回的是一个 ```jQuery``` 对象，而 ```this``` 返回的其实就是一个 ```element```，看下面代码

```js
// 这样使用是可以的，this 返回的是一个 element，有 title 属性
$('#box').hover(function () {
  this.title = 'A'
}, function () {
  this.title = 'B'
})

// 这样就会报错，$(this) 返回的是一个 jQuery 对象，没有 title 属性
$('#box').hover(function () {
  $(this).title = 'A'
}, function () {
  $(this).title = 'B'
})

// 换成这样就可以了
// 建议如果已经使用了 jQuery，那就统一使用 $(this) 而不再用 this 应该是比较不错的选择
$('#box').hover(function () {
  $(this).attr('title', 'A')
}, function () {
  $(this).attr('title', 'B')
})
```






## jQuery 的链式操作是如何实现的

简单来说，仅仅是通过对象上的方法最后 `return this` 把对象再返回回来，这样一来就可以链式操作了

一个简单的模拟

```js
// 定义初始类
function Foo() { }

// 扩展它的 prototype 
Foo.prototype = {

  setName: function (name) {
    this.name = name;
    return this;
  },

  getName: function () {
    return this.name;
  },

  setAge: function (age) {
    this.age = age;
    return this;
  }

};

// 链式调用 
new Foo().setName('abc').setAge(20);  // Foo {name: 'abc', age: 20}
```






## $.fn.each() 和 Array.prototype.forEach()

```jQuery``` 定义在 ```$.fn``` 上的 ```each()``` 和 ```map()``` 方法与定义在 ```Array.prototype``` 上的原生方法 ```forEach()``` 和 ```map()``` 对应，它们的参数都是回调函数，但它们的回调函数定义有一些细节上的差别

```$.fn.each()``` 的回调定义如下：

```js
Function(Integer index, Element element )
```

回调的**第一个**参数是数组元素所在的位置（序号，从 ```0``` 开始），**第二个**参数是元素本身

而 ```Array.prototype.forEach()``` 的回调定义是：

```js
Function(currentValue, index, array)
```

回调的**第一个**参数是数组元素本身，**第二个**参数才是元素所有的位置（序号），而且这个回调有**第三个**参数，即整个数组的引用



## jQuery 中的 deferred 对象

```jQuery.Deferred()``` 基于 ```Promises/A``` 规范实现，因为 `jQuery` 本身的设计风格，```jQuery.Deferred()``` 并没有完全遵循 ```Promises/A``` 规范。

`jQuery` 的 ```Deferred``` 对象支持多个回调绑定多个任务，任务本身既可以是同步也可以是异步的。

```deferred``` 对象就是 `jQuery` 的回调函数解决方案。```deferred``` 对象的含义就是"延迟"到未来某个点再执行，它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口

有了 ```deferred``` 对象以后，我们可以这样写：

```js
$.ajax("test.html")
  .done(function () { alert("success"); })
  .fail(function () { alert("error"); });
```

可以看到，```done()``` 相当于 ```success``` 方法，```fail()``` 相当于 ```error``` 方法。采用链式写法以后，代码的可读性大大提高

一个较完整的例子

```js
$.when(wait())
  .done(function () { alert("哈哈，成功了！"); })
  .fail(function () { alert("出错啦！"); });

// 如果代码是上面这样，done() 方法会立即执行，原因在于 $.when() 的参数只能是 deferred 对象
// 所以必须对 wait() 进行改写（如下所示）

var dtd = $.Deferred();  // 新建一个 deferred 对象

var wait = function (dtd) {
  var tasks = function () {
    alert("执行完毕！");
    dtd.resolve();  // 改变 deferred 对象的执行状态
  };
  setTimeout(tasks, 5000);
  return dtd;
};

// 现在，wait() 函数返回的是 deferred 对象，这就可以加上链式操作了
// wait() 函数运行完，就会自动运行 done() 方法指定的回调函数

$.when(wait(dtd))
  .done(function () { alert("哈哈，成功了！"); })
  .fail(function () { alert("出错啦！"); });
```

#### resolve() 和 reject()

`jQuery` 规定，```deferred``` 对象有三种执行状态 ---- 未完成，已完成和已失败

* 如果执行状态是"已完成"（`resolved`），```deferred``` 对象立刻调用 ```done()``` 方法指定的回调函数

* 如果执行状态是"已失败"，调用 ```fail()``` 方法指定的回调函数

* 如果执行状态是"未完成"，则继续等待，或者调用 ```progress()``` 方法指定的回调函数（`jQuery1.7` 版本添加）

前面部分的 ```ajax``` 操作时，```deferred``` 对象会根据返回结果，自动改变自身的执行状态，但是，在 ```wait()``` 函数中，这个执行状态必须由程序员手动指定

```dtd.resolve()``` 的意思是，将 ```dtd``` 对象的执行状态从"未完成"改为"已完成"，从而触发 ```done()``` 方法

类似的，还存在一个 ```deferred.reject()``` 方法，作用是将 ```dtd``` 对象的执行状态从"未完成"改为"已失败"，从而触发 ```fail()``` 方法：

```js
var dtd = $.Deferred(); // 新建一个 Deferred 对象

var wait = function (dtd) {
  var tasks = function () {
    alert("执行完毕！");
    dtd.reject(); // 改变 Deferred 对象的执行状态
  };
  setTimeout(tasks, 5000);
  return dtd;
};

$.when(wait(dtd))
  .done(function () { alert("哈哈，成功了！"); })
  .fail(function () { alert("出错啦！"); });
```

#### promise 对象

大多数情况下，我们不想让用户从外部更改 ```deferred``` 对象的状态。这时，你可以在 ```deferred``` 对象的基础上，返回一个针对它的 ```promise``` 对象。我们可以把后者理解成，```promise``` 是 ```deferred``` 的只读版，或者更通俗地理解成 ```promise``` 是一个对将要完成的任务的承诺

你可以通过 ```promise``` 对象，为原始的 ```deferred``` 对象添加回调函数，查询它的状态，但是无法改变它的状态，也就是说 ```promise``` 对象不允许你调用 ```resolve``` 和 ```reject``` 方法

```js
var wait = function (dtd) {
  var dtd = $.Deferred(); // 在函数内部，新建一个 Deferred 对象
  var tasks = function () {
    alert("执行完毕！");
    dtd.resolve(); // 改变 Deferred 对象的执行状态
  };
  setTimeout(tasks, 5000);
  return dtd.promise(); // 返回 promise 对象
};

$.when(wait())
  .done(function () { alert("哈哈，成功了！"); })
  .fail(function () { alert("出错啦！"); });
```


#### then() 方法

```then()``` 的作用也是指定回调函数，它可以接受三个参数，也就是三个回调函数。第一个参数是 ```resolve``` 时调用的回调函数，第二个参数是 ```reject``` 时调用的回调函数，第三个参数是 ```progress()``` 方法调用的回调函数

```js
deferred.then(doneFilter[, failFilter][, progressFilter])
```

* 在 `jQuery 1.8` 之前，```then()``` 只是 ```.done()``` 和 ```.fail()``` 写法的语法糖，两种写法是等价的

* 在 `jQuery 1.8` 之后，```then()``` 返回一个新的 ```deferred``` 对象，而 ```done()``` 返回的是原有的 ```deferred``` 对象。如果 ```then()``` 指定的回调函数有返回值，该返回值会作为参数，传入后面的回调函数

```js
var defer = jQuery.Deferred();

defer.done(function (a, b) {
  return a * b;
}).done(function (result) {
  console.log("result = " + result);
}).then(function (a, b) {
  return a * b;
}).done(function (result) {
  console.log("result = " + result);
}).then(function (a, b) {
  return a * b;
}).done(function (result) {
  console.log("result = " + result);
});

defer.resolve(2, 3);

// 在 jQuery 1.8 版本之前

result = 2

result = 2

result = 2

// 在 jQuery 1.8 版本之后

result = 2

result = 6

result = NaN
```

这一点需要特别注意，比如下面这个实例：

```js
$.ajax(url1, { dataType: "json" })
  .then(function (data) {
    return $.ajax(url2, { data: { user: data.userId } });
  }).done(function (data) {
    // 处理的是从 url2 获取的数据，而不是从 url1 获取的数据
  });
```

利用 ```then()``` 会修改返回值这个特性，我们可以在调用其他回调函数之前，对前一步操作返回的值进行处理

```js
// 先使用 then() 方法，从返回的数据中取出所需要的字段（firstName）
var post = $.post("/echo/json/")
  .then(function (p) {
    return p.firstName;
  });

// 后面的操作就可以只处理这个字段了
post.done(function (r) { console.log(r); });
```

有时，```Ajax``` 操作返回 ```json``` 字符串里面有一个 ```error``` 属性，表示发生错误。这个时候，传统的方法只能是通过 ```done()``` 来判断是否发生错误。通过 ```then()``` 方法，可以让 ```deferred``` 对象调用 ```fail()``` 方法

```js
var myDeferred = $.post('/echo/json/', { json: JSON.stringify({ 'error': true }) })
  .then(function (response) {
    if (response.error) {
      return $.Deferred().reject(response);
    }
    return response;
  }, function () {
    return $.Deferred().reject({ error: true });
  });

myDeferred.done(function (response) {
  $("#status").html("Success!");
}).fail(function (response) {
  $("#status").html("An error occurred");
});
```

#### state 方法

该方法用来返回 ```deferred``` 对象目前的状态

```js
var deferred = new $.Deferred();

deferred.state();  // "pending"

deferred.resolve();

deferred.state();  // "resolved"
```

返回值有三个：

* `pending`：表示操作还没有完成

* `resolved`：表示操作成功

* `rejected`：表示操作失败


#### notify() 和 progress()

```progress()``` 用来指定一个回调函数，当调用 ```notify()``` 方法时，该回调函数将执行。它的用意是提供一个接口，使得在非同步操作执行过程中，可以执行某些操作，比如定期返回进度条的进度

```js
var userProgress = $.Deferred();
var $profileFields = $("input");
var totalFields = $profileFields.length

userProgress.progress(function (filledFields) {
  var pctComplete = (filledFields / totalFields) * 100;
  $("#progress").html(pctComplete.toFixed(0));
});

userProgress.done(function () {
  $("#thanks").html("Thanks for completing your profile!").show();
});

$("input").on("change", function () {
  var filledFields = $profileFields.filter("[value!='']").length;
  userProgress.notify(filledFields);
  if (filledFields == totalFields) {
    userProgress.resolve();
  }
});
```



#### always()

```always()``` 也是指定回调函数，不管是 ```resolve``` 或 ```reject``` 都要调用

#### pipe 方法

```pipe``` 方法接受一个函数作为参数，表示在调用 ```then``` 方法、```done``` 方法、```fail``` 方法、```always``` 方法指定的回调函数之前，先运行 ```pipe``` 方法指定的回调函数。它通常用来对服务器返回的数据做初步处理


#### 一个综合完整的实例：

```js
// 使用 deferred 对象写一个 wait 方法，表示等待多少毫秒后再执行
$.wait = function (time) {
  return $.Deferred(function (dfd) {
    setTimeout(dfd.resolve, time);
  });
}

// 使用
$.wait(5000).then(function () {
  alert("Hello from the future!");
});

// 改写 setTimeout 方法
// 在上面的 wait 方法的基础上，还可以改写 setTimeout 方法，让其返回一个 deferred 对象
function doSomethingLater(fn, time) {
  var dfd = $.Deferred();
  setTimeout(function () {
    dfd.resolve(fn());
  }, time || 0);
  return dfd.promise();
}

var promise = doSomethingLater(function () {
  console.log("已经延迟执行");
}, 100);

// 自定义操作使用 deferred 接口
// 利用 deferred 接口，使得任意操作都可以用 done() 和 fail() 指定回调函数
Twitter = {
  search: function (query) {
    var dfr = $.Deferred();
    $.ajax({
      url: "http://search.twitter.com/search.json",
      data: { q: query },
      dataType: "jsonp",
      success: dfr.resolve
    });
    return dfr.promise();
  }
}

// 使用方法
Twitter.search("intridea").then(function (data) {
  alert(data.results[0].text);
});

// deferred 对象的另一个优势是可以附加多个回调函数
function doSomething(arg) {
  var dfr = $.Deferred();
  setTimeout(function () {
    dfr.reject("Sorry, something went wrong.");
  });
  return dfr;
}

doSomething("uh oh").done(function () {
  alert("Won't happen, we're erroring here!");
}).fail(function (message) {
  alert(message)
});
```




## 使用原生 JavaScript 来替代 jQuery

#### 获取元素

```js
// jQuery
$(selector)

// Native
function $(el) {
  return document.querySelector(el)
}

// 转换为数组
function $$(el) {
  return Array.prototype.slice.call(document.querySelectorAll(el))
}
```

常用的 ```class```、```id```、属性 选择器都可以使用 ```document.querySelector``` 或 ```document.querySelectorAll``` 替代，区别是

* ```document.querySelector``` 返回第一个匹配的 ```Element```

* ```document.querySelectorAll``` 返回所有匹配的 ```Element``` 组成的 ```NodeList```。它可以通过 ```[].slice.call()``` 把它转成 ```Array```

* 如果匹配不到任何 ```Element```，```jQuery``` 返回空数组 ```[]```，但 ```document.querySelector``` 返回 ```null```，注意空指针异常

但是需要注意的是：

```document.querySelector``` 和 ```document.querySelectorAll``` 性能很差

如果想提高性能，尽量使用 ```document.getElementById```、```document.getElementsByClassName``` 或 ```document.getElementsByTagName```



#### 添加元素到匹配的元素集合（数组）

```js
// jQuery
$(selector).add($(newEl))

// Native
$$(selector).push(newEl)
```


#### 添加类名（addClass）

```js
// jQuery
$(el).addClass(className)

// Native
el.classList.add(className)
```


#### 插入元素（after）

```js
// jQuery
$(el).after("<div></div>")

// Native
el.parentNode.insertBefore(newEl, el.nextSibling)
```



#### 插入元素（append）

```js
// jQuery
$(el).append("<div></div>")

// Native
el.appendChild(newEl)
```





#### 插入元素（before）

```js
// jQuery
$(el).before("<div></div>")

// Native
el.parentNode.insertBefore(newEl, el)
```





#### 设置/获取 属性（attr）

```js
// jQuery
$(el).attr("src", "../img/foo.png")

// Native
el.getAttribute("src")

el.setAttribute("src", "../img/foo.png")
```





#### 深度拷贝（close）

```js
// jQuery
$(el).clone()

// Native
el.appendChild(newEl)
```





#### 获得匹配元素集合中每个元素的子元素（content）

```js
// jQuery
$(el).contents()

// Native
el.childNodes
```





#### 设置样式（css）

```js
// jQuery
$(el).css("color", "red")

// Native
el.style.color = "red"

----

// jQuery 多个样式
$(el).css({ color: "red", fontSize: "20px" })
// Native
const cssObj = { color: "red", fontSize: "20px" }
for (let k in cssObj) {
    el.style[k] = cssObj[k]
}
```





#### 清空元素（empty）

```js
// jQuery
$(el).empty()

// Native
el.innerHTML = "";
```





#### 过滤元素（filter）

```js
// jQuery
$(selector).filter(filterFn)

// Native
$$(selector).filter(filterFn)
```





#### 寻找元素（find）

```js
// jQuery
$(el).find(selector)

// Native
el.querySelectorAll(selector)
```




#### 寻找元素（parents）

```js
// jQuery
$(el).parents(selector)

// Native
function parents(el, selector = '*') {
    const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector
    const parentsMatch = []
    while ((el = el.parentElement) !== null) {
        if (matchesSelector.call(el, selector)) {
            parentsMatch.push(el)
        }
    }
    return parentsMatch
}
```





#### 筛选元素（has）

```js
// jQuery
$(selector).has("div")

// Native
$$(selector).filter(el => el.querySelector("div") !== null)
```






#### 筛选元素（next）

```js
// jQuery
$(el).next()

// Native
el.nextElementSibling
```





#### 筛选元素（nextAll）

```js
// jQuery
$(el).nextAll()

// Native
const nextAll = []
while ( (el = el.nextElementSibling) !== null ) {
    nextAll.push(el)
}
```





#### 筛选元素（hasClass）

```js
// jQuery
$(el).hasClass(className)

// Native
el.classList.contains(className)
```





#### 设置 html 内容（html）

```js
// jQuery
$(el).html()

// Native
el.innerHTML
```





#### 获取元素属性，宽高等（innerHeight/innerWidth）

```js
// jQuery
$(el).innerHeight()
// Native
el.clientHeight


// jQuery
$(el).innerWidth()
// Native
el.clientWidth
```





#### 获取元素当前坐标（position）

```js
// jQuery
$(el).position()
// Native
left: el.offsetLeft

top: el.offsetTop
```




#### 删除元素（remove）

```js
// jQuery
$(el).remove()
// Native
el.parentNode.removeChild(el)
```




#### 替换元素（replaceWith）

```js
// jQuery
$(el).replaceWith("<div></div>")
// Native
el.parentNode.replaceChild(newEl, el)

// 标签的话用这个
el.outerHTML = "<div></div>"
```





#### 滚动条位置（scrollTop）

```js
// jQuery
$(el).scrollTop()

$(el).scrollTop(20)
// Native
el.scrollTop

el.scrollTop = 20

// 如果全局对象为 window
document.documentElement.scrollTop = 20

document.body.scrollTop = 20
```





#### 过滤元素（slice）

```js
// jQuery
$(selector).slice(0, 1)

// Native
$$(selector).slice(0, 1)
```




#### 获取文本内容（text）

```js
// jQuery
$(el).text(str)

// Native
el.textContent = str
```




#### class 切换（toggleClass）

```js
// jQuery
$(el).toggleClass(className)

// Native
el.classList.toggle(className)
```



#### 获取元素的值（val）

```js
// jQuery
$(el).val(value)

// Native
el.value = value
```





#### 包裹元素（wrap）

```js
// jQuery
$(el).wrap("<div></div>")
// Native
建议使用 document.createElement + appendChild 来添加元素

// 这样性能很差
el.outerHTML = `<div>${el.outerHTML}</div>`
```





## 通用方法


#### 检查是否某个元素的后代（contains）
```js
// jQuery
$.contains(el, child)

// Native
el !== child && el.contains(child)
```





#### each

用来无缝迭代对象和数组

```js
// jQuery
$.each(array, (index, value) => {})

// Native
array.forEach( (value, index) => {} )
```






#### extend

将两个或更多对象的内容合并到第一个对象

```js
// jQuery
$.extend({}, {a: 1}, {b: 2})  // {a: 1, b: 2}


// ES6
Object.assign({}, {a: 1}, {b: 2});  // {a: 1, b: 2}
```









#### grep

查找满足过滤函数的数组元素（原数组不受影响）

```js
// jQuery
$.grep([10, 11, 3, 4], n => n > 9)

// Native
[10, 11, 3, 4].filter( n => n > 9)
```










#### inArray

在数组长查找指定值并返回它的索引（若没找到，则返回 `-1`）

```js
// jQuery
$.inArray(item, array)

// Native
array.indexOf(item) > -1

// ES6
array.includes(item)
```














#### makeArray

转换一个类数组对象成为真正的 `JavaScript` 数组

```js
// jQuery
$.makeArray(arrayLike)

// Native
[].slice.call(arrayLike)

// ES6
Array.from(arrayLike)
```



















#### merge

合并两个数组内容到第一个数组

```js
// jQuery
$.merge(arr1, arr2)

// Native
function merge (...args) {
    return [].concat(...args)
}
```







#### parseJSON

合并两个数组内容到第一个数组

```js
// jQuery
$.parseJSON(str)

// Native
JSON.parse(str)
```








#### proxy

接受一个函数，然后返回一个新函数，并且这个函数始终保持了特定的上下文

```js
// jQuery
$.proxy(fn, context)

// Native
fn.bind(context)
```








## 源码的总体架构

```js
(function (window, undefined) {

  // 构造 jQuery 对象
	var jQuery = function (selector, context) {
    return new jQuery.fn.init(selector, context, rootjQuery);
  }

	// 工具函数 Utilities
	// 异步队列 Deferred
	// 浏览器测试 Support
	// 数据缓存 Data
	// 队列 queue
	// 属性操作 Attribute
	// 事件处理 Event
	// 选择器 Sizzle
	// DOM遍历
	// DOM操作
	// CSS操作
	// 异步请求 Ajax
	// 动画 FX
	// 坐标和大小

  window.jQuery = window.$ = jQuery;

})(window);
```

`jQuery` 的最外层是一个自调用匿名函数，通过定义一个匿名函数，创建了一个 "私有" 的命名空间，该命名空间的变量和方法，不会破坏全局的命名空间

参数中传入 `window` 变量，使得 `window` 由全局变量变为局部变量，当在 `jQuery` 代码块中访问 `window` 时，不需要将作用域链回退到顶层作用域，这样可以更快的访问 `window`，更重要的是将 `window` 作为参数传入，可以在压缩代码时进行优化

传入 `undefined` 是因为在自调用匿名函数的作用域内，确保 `undefined` 是真的未定义，因为 `undefined` 在某些浏览器下是能够被重写，被赋予新的值的




#### 构造函数 jQuery()

构造函数 `jQuery()` 有 `7` 种用法：

#### 1） jQuery(selector, context)

接收一个 `css` 选择器表达式(`selector`)和可选的选择器上下文(`context`),返回一个包含了匹配的 `DOM` 元素的 `jQuery` 对象

例如，在一个事件监听函数中，可以像下面这样限制查找范围：

```js
$('div.foo').click(function() {
   $('span', this).addClass('bar'); // 限定查找范围
});
```

* 如果选择器表达式 `selector` 是简单的 `"#id"` ，且没有指定上下文 `context`，则调用浏览器原生方法 `document.getElementById()` 查找属性 `id` 等于指定值的元素

* 如果是比 `"#id"` 复杂的选择器表达式或指定了上下文，则通过 `jQuery` 方法 `.find()` 查找，因此 `$('span', this)` 等价于 `$(this).find('span')`



#### 2） jQuery(html, ownerDocument) 、jQuery(html, props)

用所提供的 `html` 代码创建 `DOM` 元素

```js
// 单标签 两种方式都可以往 body 中插入 div
/*   
 *   1  $('<div>').appendTo('body');
 *   2  $('<div></div>').appendTo('body');  
 */

// 多标签嵌套
$('<div><span>foo</span></div>').appendTo('body');
```

#### 3） jQuery(element or elementsArray)

如果传入一个 `DOM` 元素或 `DOM` 元素数组，则把 `DOM` 元素封装到 `jQuery` 对象中并返回


```js
// 传入 DOM 元素
$('li').each(function (index, ele) {
  $(ele).on('click', function () {
    // 这里的 DOM 元素就是 this
    $(this).css('background', 'red');
  })
})

// 传入 DOM 数组
var aLi = document.getElementsByTagName('li');
aLi = [].slice.call(aLi);    // 集合转数组

var $aLi = $(aLi);
$aLi.html('我是jQuery对象');  // 所有的 li 的内容都变成 '我是jQuery对象'

```

#### 4） jQuery(object)

如果传入一个普通 `JavaScript` 对象，则把该对象封装到 `jQuery` 对象中并返回

```js
// 定义一个普通 JavaScript 对象
var foo = { foo: 'bar', hello: 'world' };

// 封装成 jQuery 对象
var $foo = $(foo);

// 绑定一个事件
$foo.on('custom', function () {
    console.log('custom event was called');
});

// 触发这个事件
$foo.trigger('custom');  // 在控制台打印 "custom event was called"

```

#### 5） jQuery( callback )

当传进去的参数是函数的时候，则在 `document` 对象上绑定一个 `ready` 事件监听函数，当 `DOM` 结构加载完成的时候执行

```js
$(function () {

})

// 以上代码和下面的效果是一样的
$(document).ready(function () {
  // ...
})
```


#### 6） jQuery(jQuery object) 

如果传入一个 `jQuery` 对象，则创建该 `jQuery` 对象的一个副本并返回，副本与传入的 `jQuery` 对象引用完全相同的 `DOM` 元素



#### 7） jQuery() 

如果不传入任何的参数，则返回一个空的 `jQuery` 对象，属性 `length` 为 `0`

这个功能可以用来复用 `jQuery` 对象，例如，创建一个空的 `jQuery` 对象，然后在需要时先手动修改其中的元素，再调用 `jQuery` 方法，从而避免重复创建 `jQuery` 对象


#### 总体结构

```js

 16  (function (window, undefined) {
          // 构造 jQuery 对象
 22       var jQuery = (function() {
 25         var jQuery = function( selector, context ) {
 27           return new jQuery.fn.init( selector, context, rootjQuery );
 28         },

            // 一堆局部变量声明
 97         jQuery.fn = jQuery.prototype = {
 98           constructor: jQuery,
 99           init: function( selector, context, rootjQuery ) { ... },
                // 一堆原型属性和方法
319           };

322         jQuery.fn.init.prototype = jQuery.fn;

324         jQuery.extend = jQuery.fn.extend = function() { ... };
388         jQuery.extend({
              // 一堆静态属性和方法
892         });

955         return jQuery;

957       })();
        
        // 省略其他模块的代码

9246     window.jQuery = window.$ = jQuery;

9266 })(window);

```

#### return new jQuery.fn.init(selector, context, rootjQuery);

如果构造函数有返回值，运算符 `new` 所创建的对象会被丢弃，返回值将作为 `new` 表达式的值

通过在构造函数 `jQuery()` 内部用运算符 `new` 创建并返回另一个构造函数的实例，省去了构造函数 `jQuery()` 前面的运算符 `new`，即我们创建 `jQuery` 对象时，可以省略运算符 `new` 直接写 `jQuery()` 或者 `$()`

#### jQuery.fn.init() 和  jQuery.fn.init.prototype = jQuery.fn

当我们在调用 `jQuery` 构造函数时，实际返回的是 `jQuery.fn.init()` 的实例，在执行 `jQuery.fn.init.prototype = jQuery.fn` 时，用构造函数 `jQuery()` 的原型对象覆盖了构造函数 `jQuery.fn.init()` 的原型对象，从而使构造函数 `jQuery.fn.init()` 的实例也可以访问构造函数 `jQuery()` 的原型方法和属性


#### 为什么要覆盖构造函数 jQuery() 的原型对象 jQuery.prototype ？

因为在原型对象 `jQuery.prototype` 上定义的属性和方法会被所有 `jQuery` 对象继承，这样可以有效减少每个 `jQuery` 对象所需的内存


#### jQuery.fn.init(selector, context, rootjQuery)

构造函数 `jQuery.fn.init()` 负责解析参数 `selector` 和 `context` 的类型，并执行相应的逻辑，最后返回 `jQuery.fn.init()` 的实例

```js
//  ① 定义构造函数 jQuery.fn.init(selector, context, rootjQuery)，它接受 3 个参数

//  参数 selector：可以是任意类型的值，但只有 undefined、DOM 元素
//  字符串、函数、jQuery 对象、普通 JavaScript 对象这几种类型是有效的

//  参数 context：可以不传入，或者传入 DOM 元素、jQuery 对象、普通 JavaScript 对象之一

//  参数 rootjQuery：包含了 document 对象的 jQuery 对象，用于 
//  document.getElementById() 查找失败、selector 是选择器表达式且未指定 context、selector 是函数的情况

init: function(selector, context, rootjQuery) {
  var match, elem, ret, doc;

  //  ② 参数 selector 可以转换为 false，例如是 undefined、空字符串、null 等
  //     则直接返回 this，此时 this 是空 jQuery 对象，其属性 length 等于 0

  //  Handle $(""), $(null), or $(undefined)
  //  如果 selector 为空，!selector 为 false
  if (!selector) {
    //  此时 this 为空 jQuery 对象
    return this;
  }

  //  ③ 如果参数 selector 有属性 nodeType，则认为 selector 是 DOM 元素
  //  Handle $(DOMElement)
  if (selector.nodeType) {
    //  将第一个元素和属性 context 指向 selector
    this.context = this[0] = selector;
    this.length = 1;
    return this;
  }

  //  ④ 如果参数 selector 是字符串“ body” ，手动设置属性 context 指向 document 对象
  //    第一个元素指向 body元素，最后返回包含了 body 元素引用的 jQuery 对象

  //  因为 body 只出现一次，利用 !context 进行优化
  if (selector === "body" && !context && document.body) {
    //  context指向document对象
    this.context = document;
    this[0] = document.body;
    this.selector = selector;
    this.length = 1;
    return this;
  }

  //  ⑤ 如果参数 selector 是其他字符串，则先检测 selector 是 HTML 代码还是 #id
  if (typeof selector === "string") {
    //  以 '<' 开头 以 '>' 结尾，且长度大于等于 3
    if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {

      // 则跳过 queckExpr 正则检查，这里假设为 HTML 片段，比如 '<div></p>'
      match = [null, selector, null];

    } else {

      //  否则，用正则 quickExpr 检测参数 selector 是否是稍微复杂
      //  一些的 HTML 代码（如“abc<div>” ）或 #id，匹配结果存放在数组 match 中
      match = quickExpr.exec(selector);
    }

    //  ⑥ 参数 selector 是单独标签
    //  则调用 document.createElement() 创建标签对应的 DOM元素
    //  如果 match[1] 不是 undefined，即参数 selector 是 HTML 代码
    //  或者 match[2] 不是 undefined，即参数 selector 是 #id，并且未传入参数 context
    //  所以就省略了对 match[2] 的判断，完整的表达式为 if ( match && (match[1] || match[2] && !context) )
    if (match && (match[1] || !context)) {

      //  HANDLE: $(html) -> $(array)
      //  开始处理参数 selector 是 HTML 代码的情况
      if (match[1]) {

        //  先修正 context 和 doc
        context = context instanceof jQuery ? context[0] : context;
        doc = (context ? context.ownerDocument || context : document);

        //  正则 rsingleTag 检测 HTML 代码是否是单独标签，匹配结果存放在数组 ret 中
        //  rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/

        ret = rsingleTag.exec(selector);

        //  如果数组 ret 不是 null，则是单独标签，调用 document.createElement() 创建标签对应的 DOM 元素
        if (ret) {

          //  如果 context 是普通对象，则调用 jQuery 方法 .attr() 并传入参数 context
          //  同时把参数 context 中的属性、事件设置到新创建的 DOM 元素上
          if (jQuery.isPlainObject(context)) {
            //  之所以放在数组中，是方便后面的 jQuery.merge() 方法调用
            selector = [document.createElement(ret[1])];
            //  调用 attr 方法，传入参数 context
            jQuery.fn.attr.call(selector, context, true);

          } else {
            selector = [doc.createElement(ret[1])];
          }

          //  ⑦ 如果参数 selector 是复杂 HTML 代码，则利用浏览器的 innerHTML 机制创建 DOM 元素
        } else {
          ret = jQuery.buildFragment([match[1]], [doc]);
          selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
        }

        return jQuery.merge(this, selector);

        //  ⑧ 参数 selector 是“#id” ，且未指定参数 context
      } else {
        elem = document.getElementById(match[2]);

        if (elem && elem.parentNode) {

          //  即使是 documen.getElementById 这样核心的方法也要考虑到浏览器兼容问题，可能找到的是 name 而不是 id
          if (elem.id !== match[2]) {
            return rootjQuery.find(selector);
          }

          //  如果所找到元素的属性 id 值与传入的值相等，则设置第一个元素
          //  属性 length、context、selector，并返回当前 jQuery 对象
          this.length = 1;
          this[0] = elem;
        }

        this.context = document;
        this.selector = selector;
        return this;
      }

      //  HANDLE: $(expr, $(...))
      //  ⑨ 参数 selector 是选择器表达式
      //  没有指定上下文，执行rootjQuery.find()，制定了上下文且上下文是jQuery对象，执行context.find()
    } else if (!context || context.jquery) {
      return (context || rootjQuery).find(selector);

      //  HANDLE: $(expr, context)
      //  (which is just equivalent to: $(context).find(expr)

      //  如果指定了上下文，且上下文不是 jQuery 对象
    } else {
      //  先创建一个包含 context 的 jQuery 对象，然后调用 find 方法
      return this.constructor(context).find(selector);
    }

    //  HANDLE: $(function)
    //  ⑩ 参数 selector 是函数
  } else if (jQuery.isFunction(selector)) {
    return rootjQuery.ready(selector);
  }
  //  selector 是 jquery 对象
  //  如果参数 selector 含有属性 selector，则认为它是 jQuery 对象，将会复制它的属性 selector 和 context
  if (selector.selector !== undefined) {
    this.selector = selector.selector;
    this.context = selector.context;
  }
  //  参数 selector 是任意其他值，最后（合并）返回当前 jQuery 对象
  return jQuery.makeArray(selector, this);
},
```



#### jQuery.noConflict( [removeAll] )

方法 `jQuery.noConflict( [removeAll] )` 用于释放 `jQuery` 对全局变量 `$` 的控制权，可选参数 `removeAll` 表示是否释放对全局变量 `jQuery` 的控制权，`$` 仅仅是 `jQuery` 的别名，没有 `$` ，其余功能也是可以正常使用的（使用 `jQuery`）

如果需要使用另一个 `JavaScript` 库，可以调用 `$.noConflict()` 返回 `$` 给其他库

```js
//  先把可能存在的 window.jQuery 和 $ 备份到局部变量 _jQuery 和 _$ 上
_jQuery = window.jQuery,

  _$ = window.$,

  jQuery.extend({
    noConflict: function (deep) {

      //  只有当前 jQuery 库持有全局变量 $ 的情况下，才会释放 $ 的控制权给前一个 JavaScript 库
      if (window.$ === jQuery) {
        window.$ = _$;
      }

      //  只有在当前 jQuery 库持有全局变量 jQuery 的情况下，才会释放 jQuery 的控制权给前一个 JavaScript 库
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }

      return jQuery;
    }
  }),

  //  ...略

  window.jQuery = window.$ = jQuery;
```


如果有必要（例如，在一个页面中使用多个版本的 `jQuery` 库，但很少有这样的必要） ，也可以释放全局变量 `jQuery` 的控制权，只需要给这个方法传入参数 `true` 即可

从 `jQuery 1.6` 开始增加了对 `window.$ === jQuery` 的检测，如果不检测，则每次调用 `jQuery.noConflict()` 时都会释放 `$` 给前一个 `JavaScript` 库，当页面中有两个以上定义了 `$` 的 `JavaScript` 库时，对 `$` 的管理将会变得混乱



#### jQuery.isFunction( obj )， jQuery.isArray( obj )

判断传入的参数是否是函数/数组，这两个方法的实现依赖方法 `jQuery.type(obj)`， 通过返回值是否是 `"function" / "array"` 来判断

```js
isFunction: function(obj) {
  return jQuery.type(obj) === "function";
},

isArray: Array.isArray || function (obj) {
  return jQuery.type(obj) === "array";
},
```


#### jQuery.type( obj )

用于判断参数的 `JavaScript` 类型，如果参数是 `undefined` 或 `null`，返回 `"undefined"` 或 `"null"`，如果参数是内部对象，则返回对应的字符串名称，其他一律返回 `"object"`

```js
type: function (obj) {

  //  若为 undefined / null --> 转换为字符串 "undefined" / "null"
  return obj == null ? String(obj)

  //  以上的返回值形式为[object class]，其中class是内部对象类
  //  例如 Object.prototype.toString.call( true ) 会返回 [object Boolean] 
  //  然后从对象 class2type 中取出 [object class] 对应的小写字符串并返回
  : class2type[toString.call(obj)]

  //  如果未取到则一律返回"object" 
  || "object";
},



/* ------------------------------------------------------------------------------------------- */


//  原型方法 toString() 和 class2type 的定义及初始化
toString = Object.prototype.toString,

//  [[Class]] --> type pairs
class2type = {};

//  class2type的定义
jQuery.each("Boolean Number String Function Array Date RegExp Object").split(" "), function (i, name) {
  class2type["[object" + name + "]"] = name.toLowerCase();
}

//  对象 class2type 初始化后的结构为：
{
  "[object Array]": "array"
  "[object Boolean]": "boolean"
  "[object Date]": "date"
  "[object Function]": "function"
  "[object Number]": "number"
  "[object Object]": "object"
  "[object RegExp]": "regexp"
  "[object String]": "string"
}
```


#### jQuery.isWindow( obj )

用于判断传入的参数是否是 `window` 对象，通过检测是否存在特征属性 `setInterval` 来实现

```js
//  1.7.2 之前
isWindow: function (obj) {
  return obj && typeof obj === "object" && "setInterval" in obj;
},

//  1.7.2之后，该方法修改为检测特征属性 window, 该属性是对窗口自身的引用
isWindow: function (obj) {
  return obj != null && obj == obj.window;
}
```


#### jQuery.isNumeric( value )

用于判断传入的参数是否是数字，或者看起来是否像数字

```js
isNumeric: function (obj) {
  return !isNaN(parseFloat(obj)) && isFinite(obj);
},
```

先用 `parseFloat(obj)` 尝试把参数解析为数字，然后判断其是否合法，在用 `isFinite(obj)` 判断其是否是有限的，均通过验证则返回 `true`



#### jQuery.isPlainObject( object )

用于判断传入的参数是否为"纯粹"的对象，即 `{}` 或 `new Object()` 创建的对象

```js
isPlainObject: function (obj) {
  if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
    return false;
  }

  try {
    if (obj.constructor
      && !hasOwn.call(obj, "constructor")
      && !hasOwn.call(obj.constructor.property, "isPrototypeOf")) {

      return false

    }
  } catch (e) {
    return false;
  }

  var key;
  for (key in obj) { }

  return key === undefined || hasOwn.call(obj, key);

},
```

如果参数 `obj` 满足下列条件之一，则返回 `false`

* 参数 `obj` 可以转换为 `false`

* `Object.prototype.toString.call(obj)` 返回的不是 `[object, Object]`

* 参数 `obj` 是 `DOM` 元素

* 参数 `obj` 是 `window` 对象

如果参数 `obj` 不满足以上所有条件，则至少可以确定参数 `obj` 是对象

**try...catch...  检查对象 `obj` 是否由构造函数 `Object()` 创建，如果对象 `obj` 满足以下所有条件，则认为不是由构造函数 Object() 创建，而是由自定义构造函数创建，返回 `false`**

* 对象 `obj` 含有属性 `constructor`，由构造函数创建的对象都有一个 `constructor` 属性，默认引用了该对象的构造函数，如果对象 `obj` 没有属性 `constructor`，则说明该对象必然是通过对象字面量 `{}` 创建的

* 对象 `obj` 的属性 `constructor` 是非继承属性，默认情况下，属性 `constructor` 继承自构造函数的原型对象，如果属性 `constructor` 是非继承属性，说明该属性已经在自定义构造函数中被覆盖

* 对象 `obj` 的原型对象中没有属性 `isPrototypeOf`，属性 `isPrototypeOf` 是 `Object` 原型对象的特有属性，如果对象 `obj` 的原型对象中没有，说明不是由构造函数 `Object()` 创建，而是由自定义构造函数创建

* 执行以上检测时抛出了异常，在 `IE 8/9` 中，在某些浏览器对象上执行以上检测时会抛出异常，也应该返回 `false`


函数 `hasOwn()` 指向 `Object.prototype.hasOwnProperty(property)`，用于检查对象是否含有执行名称的非继承属性

**`for...in...`  检查对象 `obj` 的属性是否都是非继承属性，如果没有属性，或者所有属性都是非继承属性，则返回 `true`，如果含有继承属性，则返回 `false`，执行 `for-in` 循环时，`JavaScript` 会先枚举非继承属性，再枚举从原型对象继承的属性**

最后，如果对象 `obj` 的最后一个属性是非继承属性，则认为所有属性都是非继承属性，返回 `true`；如果最后一个属性是继承属性，即含有继承属性，则返回 `false`


#### jQuery.makeArray(obj)

可以将一个类数组对象转换为真正的数组，在 `jQuery` 内部，还可以为方法 `jQuery.makeArray()` 传入第二个参数，这样，第一个参数中的元素被合并入第二个参数，最后会返回第二个参数，此时返回值的类型不一定是真正的数组

```js
push = Array.prototype.push,

  // 定义方法 makeArray() 接收两个参数
  // array 待转换的对象，可以是任何类型
  // results 仅在jQuery内部使用，如果传入参数results，则在该参数上添加元素
  makeArray: function (array, results) {

    // 定义返回值，如果传入了参数results则把该参数作为返回值，否则新建一个空数组返回
    var ret = results || [];

    // 过滤掉 null undefined
    if (array != null) {

      var type = jQuery.type(array);

      if (array.length == null
        || type === "string"
        || type === "function"
        || type === "regexp"
        || jQuery.isWindow(array)) {

        // 之所以不是 ret.push(array) 是因为ret不一定是真正的数组，如果只传入array，则返回值
        // ret是真正的数组，如果还传入了第二个参数，则返回值ret取决于该参数的类型
        push.call(ret, array)

      } else {

        // 否则认为array是数组或类数组对象，执行合并
        jQuery.merge(ret, array)
      }
    }

    // 返回
    return ret;
  } 
```



#### jQuery.inArray( value, array[, fromIndex] )

在数组中查找指定的元素并返回其下标，未找到则返回 `-1`

```js
// 定义方法 inArray 接收三个参数
// elem 需要查找的值
// array 数组，将遍历这个数组来查找参数value在其中的下标
// i 指定开始的位置，默认是0（即查找整个数组）
inArray: function ( elem, array, i ) {

	var len;

	// 过滤掉可以转换为 false 的情况
	if (array) {

		// 如果支持 indexOf 这调用 indexOf 返回下标
		if (indexOf) {
			return indexOf.call(array, elem, i);
		}

		len = array.length;

		// 修正参数 i，如果未指定i，则初始化为0，表示从头开始
		// 如果 i < 0，则加上数组长度 len，即从末尾开始计算
		// 调用 Math.max() 在 0 和 len + i 之间取最大值，如果 len + i 依然 < 0 ，则修正为 0 ，从头开始
		i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

		// 开始遍历，查找与指定值 elem 相等的元素，并返回其下标
		for ( ; i < len; i++) {

			// 如果 i in array 返回false，则说明 array 的下标是不连续的，无需比较
			if ( i in array && array[i] === elem ) {
				return i;
			}
		} 
	}

	return -1;
}
```

通常我们会比较 `jQuery.inArray()` 的返回值是否大于 `0` 来判断某个元素是否是数组张的元素：

```js
if (jQuery.inArray(elem, array) > 0) {
	// elem 是 array 中的元素
}
```

但是这种写法比较繁琐，可以利用按位非运算符（`~`）简化上面的代码：

```js
if ( ~jQuery.inArray(elem, aray) ) {
	// elem 是 array 中的元素
}
```

按位非运算符（`~`）会将运算数的所有位取反，相当于改变它的符号并且减 `1`：

```js
~-1 == 0;  // true
~0 == -1;  // true
~1 == -2;  // true
~2 == -3;  // true
```

更进一步，可以结合使用按位非运算符（`~`）和逻辑非运算符（`!`）把 `jQuery.inArray()` 的返回值转换为布尔类型：

```js
!!~jQuery.inArray(elem, array)

// 如果 elem 可以匹配 array 中的某个元素，则该表达式的值为 true
// 如果 elem 匹配不到 array 中的某个元素，则该表达式的值为 false

```


#### jQuery.merge( first, second )

方法 `jQuery.merge()` 用于合并两个数组的元素到第一个数组中，事实上，第一个参数可以是数组或类数组对象，即必须含有整型（或可以转换为整型）属性 `length`，第二个参数则可以是数组，类数组对象或任何含有连续整型的对象

合并行为是不可逆的，即将第二个数组合并到第一个以后，第一个数组就改变了，如果不希望如此，则可以在调用 `jQuery.merge()` 之前创建一份数组的备份：

```js
var newArray = $.merge([], oldArray);
```

方法 `jQuery.merge()` 的定义如下：

```js
// 定义方法jQuery.merge() 接收2个参数
// first 数组或类对象，必须含有整型（或可以转换为整型）属性 length
// second 数组，类数组对象或任何含有连续整型的对象，合并至 first
merge: function (first, second) {

	// first.length 必须是整型或者可以转换为整型，否则后面 i++ 返回 NaN
	var i = first.length,
		j = 0;

	// 如果是数值类型，则当数组处理，添加至 first
	if ( typeof second.length === "number" ) {
		for ( var l = second.length; j < l; j++ ) {
			first[i++] = second[j];
		}
	
	// 如果没有length，则当作含有连续整型属性的对象，例如{0:"a", 1:"b"}，把其中的非 undefined 元素逐个插入参数 first中
	} else {
		while (second[j] !== undefined) {
			first[i++] = second[j++];
		}
	}

	// 修正length 因为first可能不是真正的数组
	first.length = i;

	// 返回参数
	return first;
}
```



#### jQuery.grep( array, function ( elementOfArray, indexInArray )[, invert])


用于查找数组张满足过滤函数的元素，原数组不会受影响

如果参数 `invert` 没有传入或者为 `false` 元素只有在过滤函数返回 `true`，或者返回值可以转换为 `true` 的时候，才会被保存在最终的结果数组中，即返回一个满足回调函数的元素数组，如果参数 `invert` 为 `true`，则反之


```js
// 定义方法 jQuery.grep() 接收三个参数
// array 待遍历查找的数组
// callback 过滤每个元素的函数，执行的时候传入两个参数，当前元素和它的下标，返回一个布尔值
// inv 如果参数inv是false或者没有传入，jQuery.grep()会返回一个满足回调函数的元素数组
//	   如果为 true，则返回一个不满足回调函数的元素数组
grep: function (elems, callback, inv) {
	var ret = [], retVal;
		inv = !!inv;
	    
	for (var i = 0; length = elems.length, i < length; i++) {
		retVal = !!callback(elems[i], i);
		if ( inv !== retVal ) {
			ret.push(elems[i]);
		}
	}

	return ret;
}
```









## jQuery.buildFragment(args, nodes, scripts)

* 如果 `HTML` 代码符合缓存条件，则尝试从缓存对象 `jQuery.fragments` 中读取缓存的 `DOM` 元素

* 创建文档片段 `DocumentFragment`

* 调用方法 `jQuery.clean(elems, context, fragment, scripts)` 将 `HTML` 代码转换为 `DOM` 元素，并存储在创建的文档片段中

* 如果 `HTML` 代码符合缓存条件，则把转换后的 `DOM` 元素放入缓存对象 `jQuery.fragments`

* 最后返回文档片段和缓存状态 `{ fragment: fragment, cacheable: cacheable }`



```js
//  ① 定义函数 buildFragment
jQuery.buildFragment = function (args, nodes, scripts) {

  //  ② 定义局部变量，修正文档对象 doc
  //  变量fragment 指向稍后可能创建的文档片段 Document Fragment
  //  变量 cacheable 表示 HTML 代码是否符合缓存条件
  //  变量 cacheresults 指向从缓存对象jQuery.fragments 中取到的文档片段，其中包含了缓存的 DOM 元素
  //  变量 doc 表示创建文档片段的文档对象
  var fragment, cacheable, cacheresults, doc,
    first = args[0];

  if (nodes && nodes[0]) {

    //  ownerDocument 表示 DOM 元素所在的文档对象，如果 ownerDocument 不存在，则假定 nodes[0] 为文档对象
    doc = nodes[0].ownerDocument || nodes[0];
  }

  //  然后再次检查 doc.createDocumentFragment 是否存在
  if (!doc.createDocumentFragment) {
    doc = document;
  }

  //  ③ 尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素
  //  html 代码需要满足下列所有条件，才认为符合缓存条件
  if (args.length === 1 && typeof first === "string" &&
    first.length < 512 &&
    doc === document &&
    first.charAt(0) === "<" &&

    //  rnocache = /<(?:script|object|embed|option|style)/i,
    //  checked="checked" or checked
    //  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    !rnocache.test(first) &&
    (jQuery.support.checkClone || !rchecked.test(first)) &&

    //  var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +  
    //                  "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video";  
    //  var rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i");  
    (jQuery.support.html5Clone || !rnoshimcache.test(first))) {

    //  如果为 true ，则必须先复制一份再使用，否则可以直接使用
    cacheable = true;

    //  读取缓存
    cacheresults = jQuery.fragments[first];

    if (cacheresults && cacheresults !== 1) {
      fragment = cacheresults;
    }
  }

  jQuery.fragments = {};

  //  ④ 转换 HTML 代码为 DOM 元素
  //  创建文档片段
  //  如果 !fragment 为 true，表示需要执行转换过程，有三种可能
  //  1） html 代码不符合缓存条件
  //  2） html 代码符合，但是是第一次转换，没有对应的缓存
  //  3） html 代码符合，但是是第二次转换，对应的缓存值为1
  if (!fragment) {
    fragment = doc.createDocumentFragment();
    jQuery.clean(args, doc, fragment, scripts);
  }

  //  ⑤ 转换后的dom元素放入 jQuery.fragments
  if (cacheable) {
    jQuery.fragments[first] = cacheresults ? fragment : 1;
  }

  //  返回文档片段和缓存状态 { fragment: fragment, cacheable: cacheable }
  //  fragment中包含转换后的dom元素，cacheable表示缓存状态
  return { fragment: fragment, cacheable: cacheable };

};
```

`jQuery.buildFragment()` 的用法总结为：

* 如果 `HTML` 代码不符合缓存条件，则总是会执行转换过程

* 如果 `HTML` 代码符合缓存条件，第一次转换后设置缓存值为 `1`，第二次转换后设置为文档片段，从第三次开始则从缓存中读取






## jQuery.clean(elems, context, fragment, scripts)

方法 `jQuery.clean(elems, context, fragment, scripts)` 负责把 `HTML` 代码转换成 `DOM` 元素，并提取其中的 `script` 元素

* 创建一个临时 `div` 元素，并插入一个安全文档片段中

* 为 `HTML` 代码包裹必要的父标签，然后用 `innerHTML` 赋值给临时 `div` ，从而将 `HTML` 代码转换为 `DOM` 元素，之后再层层剥去包裹的父元素，得到转换后的 `DOM` 元素

* 移除 `IE 6/7` 自动插入的空 `tbody` 元素，插入 `IE 6/7/8` 自动剔除的前导空白符

* 取到转换后的 `DOM` 元素集合

* 在 `IE 6/7` 中修正复选框和单选按钮的选中状态

* 合并转换后的 `DOM` 元素

* 如果传入了文档片段 `fragment`，则提取所有合法的 `script` 元素存入数组 `scripts`，并把其他元素插入文档片段 `fragment`

* 最后返回转换后的 `DOM` 元素数组


```js
//  ① 定义函数
//  参数 elems：数组，包含了待转换的 html 代码
//  参数 context：文档对象，被 buildFragment() 修正（doc），用于创建文本节点和临时 div
//  参数 fragment：文档片段，用于存放转换后的 dom 元素
//  参数 scripts：数组，用于存放转换后的 dom 元素中的 script 元素
clean: function(elems, context, fragment, scripts) {

  var checkScriptType;

  //  ② 修正（再次修正是是为了方便直接调用 jQuery.clean() 转换 HTML 代码为 DOM 元素）
  context = context || document;

  if (typeof context.createElement === "undefined") {
    context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
  }

  //  ③ 遍历待转换的 HTML 代码数组 elems
  //  ret用于存放转换后的 dom 元素
  var ret = [], j;

  //  在 for 语句的第 2 部分取出 elems[i] 赋值给 elem，并判断 elem 的有效性，传统的做法可能是比较循环变
  //  量 i 与 elems.length，然后在 for 循环体中把 elems[i] 赋值给elem，再判断 elem 的有效性
  //  另外，判断 elem 的有效性时使用的是“ !=” ，这样可以同时过滤 null 和 undefined，却又不会过滤整型数字 0
  for (var i = 0, elem; (elem = elems[i]) != null; i++) {

    //  如果是数值型，加上一个空字符串，即把 elem 转换为字符串
    if (typeof elem === "number") {
      elem += "";
    }

    //  用于过滤空字符串，如果是数字0，前面已经被转换为字符串"0"了，elem为false则跳过本次循环
    if (!elem) {
      continue;
    }

    // 若是html代码
    if (typeof elem === "string") {
      //  创建文本节点
      //  rhtml = /<|&#?\w+;/  检测代码中是否含有标签，字符代码，数字代码
      //  调用 document.cerateTextNode() 创建文本节点
      if (!rhtml.test(elem)) {
        elem = context.createTextNode(elem);

        //  修正自关闭标签
      } else {
        //  rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig
        elem = elem.replace(rxhtmlTag, "<$1></$2>");

        //  创建临时div元素
        //  rtagName = /<([\w:]+)/
        //  提取html中标签，删除前导空白符和左尖括号
        var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
          wrap = wrapMap[tag] || wrapMap._default,
          deoth = wrap[0],
          div = context.createElement("div");

        //  如果传入的文档对象context是当前文档对象，则把临时div插入safeFragment中
        //  否则调用createSafeFragment()新建一个安全文档碎片（低版本浏览器也能识别的）在插入
        if (context === document) {
          safeFragment.appendChild(div);
        } else {
          createSafeFragment(context).appendChild(div);
        }

        //  包裹必要父元素，赋给临时div
        div.innerHTML = wrap[1] + elem + wrap[2];

        //  用 while 循环层层剥去包裹的父元素，最终变量 div 将指向 HTML代码对应的 DOM 元素的父元素
        while (depth--) {
          div = div.lastChild;
        }

        //  省略
        //  移除 IE 6/7 自动插入的空 tbody 元素 ...
        //  插入 IE 6/7/8 自动剔除的前导空白符 ...


        //  取到转换后的 DOM 元素集合
        elem = div.childNodes;

        //  省略 
        //  在 IE 6/7 中修正复选框和单选按钮的选中状态 ...

        if (elem.nodeType) {
          ret.push(elem);
        } else {
          ret = jQuery.merge(ret, elem);
        }
      }

    }
  }

  //  如果传入文档片段 fragment 的情况
  //  遍历数组 ret，提取script存入[scripts],将其他元素插入文档片段fragment
  if (fragment) {
    //  初始化函数checkScriptType，用于检测 script 元素是否是可执行
    //  rscriptType = /\/(java|ecma)script/i
    checkScriptType = function (elem) {
      return !elem.type || rscriptType.test(elem.type);
    };
    for (i = 0; ret[i]; i++) {
      if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);
      } else {
        if (ret[i].nodeType === 1) {
          var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

          ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
        }
        fragment.appendChild(ret[i]);
      }
    }
  }

  //  返回数组 ret
  //  但是要注意，如果传入了文档片段 fragment 和数组 scripts，那么调用 jQuery.clean() 的代码应该从文档片段fragment 
  //  中读取转换后的 DOM 元素，并从数组 scripts 中读取合法的 script 元素；如果未传入，则只能使用返回值 ret
  return ret;

}
```



## 安全文档碎片 safeFragment = createSafeFragment(document)

```js
function createSafeFragment(document) {
  var list = nodeNames.split('|');
  safeFrag = document.createDocumentFragment();

  if (safeFrag.createElement) {
    while (list.length) {
      safeFrag.createElement(list.pop());
    }
  }

  return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" + 
                "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video"
```

变量 `nodeNames` 中存放了所有的 `html5` 标签， `createSafeFragment()` 在传入的文档对象 `document` 上创建一个新的文档片段，然后在该文档片段上逐个创建 `html5` 元素，从而兼容不支持 `html5` 的浏览器，使之正确的解析和渲染



## 修正复选框和单选按钮的选中状态

```js
// Used in clean, fixes the defaultChecked property
function fixDefaultChecked(elem) {
  if (elem.type === "checkbox" || elem.type === "radio") {
    elem.defaultChecked = elem.checked;
  }
}


// Finds all inputs and passes them to fixDefaultChecked
function findInputs(elem) {
  var nodeName = (elem.nodeName || "").toLowerCase();
  if (nodeName === "input") {
    fixDefaultChecked(elem);
    // Skip scripts, get other children
  } else if (nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined") {
    jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
  }
}
```

遍历转换后的 `DOM` 元素集合，在每个元素上调用函数 `findInputs(elem)`

函数 `findInputs(elem)` 会找出其中的复选框和单选按钮，并调用函数 `fixDefaultChecked(elem)` 把属性 `checked` 的值赋值给属性 `defaultChecked`



## jQuery.extend()、jQuery.fn.extend()

主要用于合并两个或多个对象的属性到第一个对象，它们的语法如下：

```js
jQuery.extend([deep], target, object1[, objectN])

jQuery.fn.extend([deep], target, object1[, objectN])
```

* 参数 `deep` 是可选的布尔值，表示是否进行深度合并（即递归合并）

* 合并行为默认是不递归的，如果第一个参数的属性本身是一个对象或数组，它会被第二个或后面的其他参数的同名属性完全覆盖

* 如果为 `true`，表示进行深度合并，合并过程是递归的

* 参数 `target` 是目标对象，参数 `object1` 和 `objectN` 是源对象，包含了待合并的属性

如果提供了两个或更多的对象，所有源对象的属性将会合并到目标对象

如果仅仅提供一个对象，意味着参数 `target` 被忽略，`jQuery` 或 `jQuery.fn` 被当作目标对象，通过这种方式可以在 `jQuery` 或 `jQuery.fn` 上添加新的属性和方法


方法 `jQuery.extend()` 和 `jQuery.fn.extend()` 执行的关键步骤如下：

* 修正参数 `deep`, `target`, 源对象的起始下标

* 逐个遍历源对象：

  * 遍历源对象的属性

  * 覆盖目标对象的同名属性，如果是深度合并，则先递归调用 `jQuery.extend()`




```js
jQuery.extend = jQuery.fn.extend = function () {

  // 定义局部变量
  var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // options：指向某个源对象
  // name：表示某个源对象的某个属性名
  // src：表示目标对象的某个属性的原始值
  // copy：表示某个源对象的某个属性的值
  // copyIsArray：指示变量 copy 是否是数组
  // clone：表示深度复制时原始值的修正值
  // target：指向目标对象
  // i：表示源对象的起始下标
  // length：表示参数的个数，用于修正变量 target
  // deep：指示是否执行深度复制，默认为 false

  // 修正目标对象 target、源对象起始下标 i
  // 如果第一个参数是布尔，则修正为第一个为 deep，第二个为 target，期望对象从第三个元素开始
  // 若第一个不是布尔，则是期望第二个元素开始（i 初始为 1）
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }

  // 如果 target 不是对象，函数，统一替换为 {} （因为在基本类型上设置非原生属性是无效的）
  if (typeof target !== "object" && !jQuery.isFunction(target)) {
    target = {};
  }

  // 如果两者相等，表示期望的源对象没有传入，则把 jQuery 和 jQuery.fn 作为目标，并且把源对象开始下标减一
  // 从而使得传入的对象被当作源对象，相等有两种情况
  // 1. extend(object) 只传入了一个参数
  // 2. extend(deep, object) 第一个参数为布尔
  if (length === i) {
    target = this;
    --i;
  }

  // 逐个遍历源对象
  for (; i < length; i++) {

    // 遍历源对象的属性
    if ((options = arguments[i]) !== null) {
      for (name in options) {

        // 覆盖目标对象的同名属性
        src = target[name];
        copy = options[name];

        // 避免 src(原始值) 与 copy(复制值) 相等进入死循环
        if (target === copy) {
          continue;
        }

        // 如果原始值 src 不是数组 --> 修正为空数组
        // 复制值是普通 js 对象，如果原始值 src 不是普通 JS 对象 --> 修正为 {}，修正后的 src 赋值给原始值的副本 clone

        // 调用 jQuery.isPlainBoject(copy) 判断复制值 copy 是否为 "纯粹" 的 JS 对象
        // 只有通过对象直接量 {} 或 new Object() 创建的对象，才会返回 true
        if (deep && copy && (jQuery.isPlainObject(copy) ||
          (copyIsArray = jQuery.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src && jQuery.isArray(src) ? src : [];
          } else {
            clone = src && jQuery.isPlainObject(src) ? src : [];
          }

          // 递归合并 copy 到 clone 中，然后覆盖对象的同名属性
          target[name] = jQuery.extend(deep, clone, copy);

          // 如果不是深度合并，且不为 undefined，则直接覆盖目标的对象的同名属性
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }
}
```


##  jQuery.each

静态方法 `jQuery.each()` 是一个通用的遍历迭代方法，用于无缝地遍历对象和数组，对于数组和含有 `length` 属性的类数组对象（如函数参数对象 `arguments`） ，该方法通过下标遍历，从 `0` 到 `length - 1`，对于其他对象则通过属性名遍历（`for-in`） ，在遍历过程中，如果回调函数返回 `false`，则结束遍历

```js
//  定义方法，接收三个参数
//  object 待遍历的对象或数组
//  callback 回调，会在数组的每个元素或对象的每个属性上执行
//  agrs 传给回调函数 callback的 参数数组(可选)，如果没有传入，
//  则执行回调函数的时候会传入两个参数（下标或属性名，对应的元素或属性值），如果传入 args 则只把该参数传给回调函数
each: function(object, callback, args) {
  var name, i = 0,
    length = object.length,

    //  判断是对象还是数组( .isObj )[object.length为undefined或object是函数]
    //  若是对象，isObj为true，通过属性名遍历
    //  若是数组或类数组，isObj为false，通过下标遍历
    isObj = length === undefined || jQuery.isFunction(object);

  //  如果传入args，用for-in遍历对象，用for遍历数组或类数组
  if (args) {
    if (isObj) {
      for (name in object) {
        //  执行 callback 时通过 apply 指定 this 关键字所引用的对象，同时要求并假设 args 是数组，若不是则抛出错误，下面同理
        if (callback.apply(object[name], args) === false) {
          break;
        }
      }
    } else {
      for (; i < length;) {
        if (callback.apply(object[i++], args) === false) {
          break;
        }
      }
    }

    //  如果没有传入参数 args，原理同上，分别处理对象和数组（类数组）
  } else {
    if (isObj) {
      for (name in object) {
        if (callback.call(object[name], name, object[name]) === false) {
          break;
        }
      }
    } else {
      for (; i < length;) {
        if (callback.call(object[i], i, object[i++]) === false) {
          break;
        }
      }
    }
  }

  //  jQuery 并没有把以上两段很相似的代码合并，这是因为在合并后需要反复判断变量 isObj 的值，避免性能下降
  //  返回 object ，方法 .each 调用 jQuery.each() 的时候，把当前的 jQuery 对象作为参数 object 传入
  //  在这里返回该参数，以支持链式语法
  return object;
},
```





## .pushStack( elements, name, arguments )

原型方法 `.pushStack()` 创建一个新的空 `jQuery` 对象，然后把 `DOM` 元素集合放进这个 `jQuery` 对象中，并保留对当前 `jQuery` 对象的引用，它对 `jQuery` 对象遍历，`DOM` 查找，`DOM` 遍历，`DOM` 插入等方法提供支持

```js
//  定义方法 .pushStack() 接收三个参数（即构建一个新的 jQuery 对象并入栈，新对象位于栈顶）
//  elems： 将放入新 jQuery 对象的元素数组（或类数组）
//  name： 产生元素数组 elems 的 jQuery 方法名
//  selector：传给 jQuery 方法的参数，用于修正原型属性 .selector

pushStack: function (elems, name, selector) {

  //  创建一个空的 jQuery 对象，this.constructor 指向构造函数 jQuery
  var ret = this.constructor();

  //  合并参数 elems 
  if (jQuery.isArray(elems)) {

    //  如果是数组
    push.apply(ret, elems);

  } else {

    //  不是数组的情况
    jQuery.merge(ret, elems);

  }

  //  设置属性 prevObject， 指向当前 jQuery 对象，从而形成一个链式栈
  ret.prevObject = this;

  //  指向当前 jQuery 的上下文
  ret.context = this.context;

  //  在 ret 上设置属性 selector，方便调试
  if (name === "find") {

    ret.selector = this.selector + (this.selector ? " " : "") + selector;

  } else if (name) {

    ret.selector = this.selector + "." + name + "(" + selector + ")";

  }

  //  返回 ret
  return ret;

}
```




## .end() 

结束当前链中最近的筛选操作，并将匹配元素集合还原为之前的状态

```js
end: function() {
  return this.prevObject || this.constructor(null);   
}
```

返回一个 `jQuery` 对象，如果属性 `prevObject` 不存在，则构建一个空的 `jQuery` 对象返回

方法 `pushStach()` 用于入栈， `end()` 则用于出栈，比如：

```js
$("ul li").find("div")
  .css("backgroundColor","red")
.end().find("span")
  .css("backgroundColor","blue")
.end();
```






## .eq(index)， .first()， .last()， .slice(start[, end])

方法 `.first()` 和 `.last()` 通过调用 `.eq(index)` 实现，`.eq(index)` 则通过 `.slice(start[, end])` 实现，`.slice(start[, end])` 则通过调用 `.pushStack(elements, name, arguments)` 实现

方法调用链为 `.first / last()` --> `.eq(index)` --> `.slice(start[, end])` --> `.pushStack(elements, name, arguments)`

```js
eq: function(i) {

  //  如果 i 是字符串，就通过 "+i" 转换为数值
  i = +i;
  return i === -1 ? this.slice(i) : this.slice(i, i + 1);
},

first: function() {
  return this.eq(0);
},

last: function() {
  return this.eq(-1);
},

slice: function() {

  //  先借用数组方法 slice() 从当前 jQuery 对象中获取指定范围的子集（数组）
  //  在调用方法 .pushStack() 把子集转换为 jQuery 对象，同时通过属性 prevObject 保留了对当前 jQuery 对象的引用
  return this.pushStack(slice.apply(this, arguments), "slice", slice.call(arguments).join(","));
}
```





## .push( value, ... ), .sort( [orderfunc] ), .splice( start,deleteCount, value, ... )


方法 `.push( value, ... )` 向当前 jQuery 对象的末尾添加新元素，并返回新长度

```js
var foo = $(document);

foo.push(document.body); // 2
```



方法 `.sort( [orderfunc] )` 对当前 `jQuery` 对象中的元素进行排序，可以传入一个比较函数来指定排序方式



```js
var foo = $([33, 4, 1111, 222]);

foo.sort(); // [1111, 222, 33, 4]

foo.sort(function (a, b) {

  console.log('orderfun', a, b);
  return a - b;

})

// [4, 33, 222, 1111]
```


方法 `.splice( start,deleteCount, value, ... )` 向当前 `jQuery` 对象中插入, 删除或替换元素，如果从当前 `jQuery` 对象中删除了元素，则返回含有被删除元素的数组

```js
var foo = $('<div id="d1" /><div id="d2" /><div id="d3" />');

// [<div id="d1"></div>, <div id="d2"></div>, <div id="d3"></div>]

foo.splice(1, 2);

// [<div id="d2"></div>, <div id="d3"></div>]
```



以上三个方法仅在内部使用，都指向同名的数组方法，因此它们的参数，功能和返回值与数组方法完全一致



```js
push: push,

sort: [].sort,

splice: [].splice
```




##  构造 jQuery 对象模块的原型属性和方法可以总结为下：

```js

jQuery.fn = jQuery.prototype            // 原型属性和方法　

.constructor                            // 指向构造函数 jQuery()

.init( selector, context, rootjQuery )  // 构造函数，解析参数 selector 和 context 的类型，
                                        // 并执行相应的逻辑，最后返回 jQuery.fn.init() 的实例

.selector                               // 记录 jQuery 査找和过滤 DOM 元素时的选择器表达式

.jquery                                 // 正在使用的 jQuery 版本号

.length                                 // jQuery 对象中元素的个数

.size()                                 // 返回当前 jQuery 对象中元素的个数

.toArray()                              // 将当前 jQuery 对象转换为真正的数组

.get( [index] )                         // 返回当前 jQuery 对象中指定位置的元素或包含了全部元素的数组

.pushStack( elements, name, arguments ) // 创建一个新的空 jQuery 对象，然后把 DOM 元素集合放入这个jQuery 对象中， 
                                        // 并保留对当前 jQuery 对象的引用

.each( function(index, Element) )       // 遍历当前 jQuery 对象中的元素，并在每个元素上执行回调函数

.ready( handler )                       // 绑定 ready 事件

.eq( index )                            // 将匹配元素集合缩减为位于指定位置的新元素
 
.first()                                // 将匹配元素集合缩减为集合中的第一个元素

.last()                                 // 将匹配元素集合缩减为集合中的最后一个元素

.slice()                                // 将匹配元素集合缩减为指定范围的子集

.map( callback(index, domElement) )     // 遍历当前 jQuery 对象中的元素，并在每个元素上执行回调函数，
                                        // 将回调函数的返回值放入一个新的 jQuery 对象中

.end()                                  // 结束当前链条中最近的筛选操作，并将匹配元素集合还原为之前的状态

.push()                                 // Array.prototype.push

.sort()                                 // [].sort

.splice()                               // [].splice
```