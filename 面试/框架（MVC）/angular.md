相关问题

* ```AngularJS``` 原理

* ```AngularJS``` 数据双向绑定原理


----


## AngularJS 原理

先来看看 ```AngularJS``` 中的几个概念

* 视图：就是指用户所看见的，视图的生命周期由作为一个模板开始，它将和模型合并并最终渲染到浏览器的 ```DOM``` 中，与其他模板系统不同的是，```AngularJS``` 使用一种独特的形式来渲染视图

* 模型：模型就是用来和模板结合生成视图的数据，模型必须在作用域中时可以被引用，这样才能被渲染生成视图，和其他框架不一样的是，```Angularjs``` 对模型本身没有任何限制和要求，你不需要继承任何类也不需要实现指定的方法以供调用或者改变模型， 模型可以是原生的对象哈希形式的，也可以是完整对象类型的，简而言之，模型可以是原生的 ```Javascript``` 对象

* 控制器：视图背后的控制代码就是控制器，它的主要工作内容是构造模型，并把模型和回调方法一起发送到视图，视图可以看做是作用域在模板（```HTML```）上的 "投影"（```projection```），而作用域是一个中间地带，它把模型整理好传递给视图，把浏览器事件传递给控制器

* 作用域：作用域是用来检测模型的改变和为表达式提供执行上下文的，它是分层组织起来的，并且层级关系是紧跟着 ```DOM``` 的结构的

用一句话来总结：在作用域的范围内，通过控制器的控制和模型方法实现，形成视图并被渲染到页面中，最终形成我们所看到的 ```html``` 页面

一个简单的启动过程：

* 首先，浏览器载入 ```HTML```，然后把它解析成 ```DOM```，载入 ```Angular.JS``` 脚本

* 之后 ```AngularJS``` 寻找 ```ng-app``` 指令，这个指令指示了应用的边界，使用 ```ng-app``` 中指定的模块来配置注入器（```$injector```）

  * 注入器（```$injector```）是用来创建 "编译服务"（```$compile service```）和 "根作用域"（```$rootScope```）的

  * 编译服务（```$compile service```）是用来编译 ```DOM``` 并把它链接到根作用域（```$rootScope```）的

* 在执行过程中，利用 ```MVC``` 模式渲染视图，首先浏览器的事件循环等待事件的触发，所谓事件包括用户的交互操作、定时事件、或者网络事件（服务器的响应）

* 在事件触发后，回调会被执行，此时会进入 ```JavaScript``` 上下文，通常回调可以用来修改 ```DOM``` 结构

* 一旦回调执行完毕，浏览器就会离开 ```javascript``` 上下文，并且根据 ```DOM``` 的修改重新渲染视图


----

## AngularJS 数据双向绑定原理

```AngularJS``` 在 ```$scope``` 变量中使用脏值检查来实现了数据双向绑定

```angularJS``` 通过不同指令注册 ```DOM``` 事件监听器来将 ```DOM``` 树的变化传播给模型，事件监听器中的代码通过修改 ```$scope``` 暴漏的变量来更新模型

主要涉及下面三个概念

```js
$watch     // 添加监听

$digest()  // 脏值检查循环

$apply     // 提供上下文执行表达式
```

简单来说就是给每个需要绑定的元素加个 ```watcher```，缓存下 ```oldValue```，在指定事件触发后遍历所有的 ```watcher```，比较 ```newValue``` 和 ```oldValue```，如果变化了做更新操作

特别需要注意的地方：```angular``` **并不存在定时**脏检测

```ng``` 只有在指定事件触发后，才进入 ```$digest cycle```：

* ```DOM``` 事件，譬如用户输入文本，点击按钮等（```ng-click```）

* ```xhr``` 响应事件（```$http```）

* 浏览器 ```Location``` 变更事件（```$location```）

* ```Timer``` 事件（```$timeout```, ```$interval```）

* 执行 ```$digest()``` 或 ```$apply()```

总结：```angular``` 对常用的 ```dom``` 事件，```xhr``` 事件等做了封装，在里面触发进入 ```angular``` 的 ```digest``` 流程，在 ```digest``` 流程里面，会从 ```rootscope``` 开始遍历，检查所有的 ```watcher```