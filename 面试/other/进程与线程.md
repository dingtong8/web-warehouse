## 进程与线程

* 进程：操作系统分配的占有 ```CPU``` 资源的最小单位，拥有独立的地址空间（工厂）

* 线程：安排 ```CPU``` 执行的最小单位，同一个进程下的所有线程，共享进程的地址空间（工人）

#### 关系和共性

* 关系：进程中包含着至少一个线程

  * 在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程
  
  * 但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作，在整个进程完成工作之后，其中的线程会被销毁，释放资源

* 共性：都包含三个状态，就绪、阻塞、运行

  * 阻塞就是资源未到位，等待资源中
  
  * 就绪，就是资源到位了，但是 ```CPU``` 未到位，还在运行其他

#### 线程的好处

之所以设置线程这个单位

* 在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型

* 线程较进程来讲，更轻

* 线程虽然微观并行，但是在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞，提高了 ```CPU``` 的利用率



## JavaScript 中的单线程执行机制

#### 单线程和多线程（本质上指在一个进程内的单和多）

* 单线程：单线程就是一个进程中只有一个线程，程序顺序执行，前面的执行完，才会执行后面的程序

* 多线程：多线程就是一个进程中只有多个线程，在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的

#### JavaScript 中的单线程执行机制

```JavaScript``` 的单线程本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中，但是浏览器是**事件驱动**的、**异步**的、**多线程**的

浏览器内部有一个事件轮询（```event loop```），是一个大的内部消息循环，会轮询大的消息队列，并执行，也就是 ```JavaScript``` 要处理的事件队列，是浏览器维护的

浏览器至少有四个线程（不同浏览器会有差异）：```JavaScript``` 引擎线程、界面渲染线程、浏览器事件触发线程、```http``` 请求线程

#### setTimeout 和 ajax

* ```setTimeout```：```JavaScript``` 在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由 ```JavaScript``` 引擎执行，都是在浏览器空闲了才会执行

* ```ajax```：是真正的异步，在调用 ```ajax``` 的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中，再由 ```JavaScript``` 引擎执行


## JavaScript的阻塞

浏览器虽然是多线程，但是由于 ```JavaScript``` 具有阻塞特性（比如 ```alert```），无论外链还是内嵌脚本，在浏览器执行解释 ```JavaScript``` 脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到 ```JavaScript``` 下载并执行完毕

这样一来，```JavaScript``` 脚本的下载、解释执行，会反使页面的继续绘制，给用户带来不良的体验，所以避免此类情况的话可以

* 将 ```<script>``` 内嵌和外链，在可以的情况下，放在 ```<body>``` 底部（对于 ```css```，浏览器是并行下载）

* 在页面 ```onload``` 后，加载 ```JavaScript```

* 可以使用 ```html5``` 的  ```<script>```标签的```defer```属性，在页面加载完成后下载

* 使用创建 ```<script>``` 标签的方式，在页面加载完成后添加进去（createElement）

简单来说就是一句话，先让页面渲染完，再加载 ```JavaScript```

> ```Node.js``` 的运行机制是基于事件轮询 （```event loop```）



## 关于线程同步

线程同步是指多线程通过特定的东西（如互斥量）来控制线程之间的执行顺序（同步），也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步那线程之间是各自运行各自的

#### 方式和机制

主要有临界区（```Critical Section```）、互斥量（```Mutex```）、信号量（```Semaphore```）、事件（```Event```）四种方式，区别如下：

* 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问，在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占

* 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问，互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享

* 信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

* 事件：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作