相关问题

* ```http``` 状态码常见有哪些

* 浏览器缓存机制

* ```cookie``` / ```csrf``` / ```xss```


----


## http 常见状态码

```js
// 2开头 （请求成功）表示成功处理了请求的状态代码
200  // OK 服务器已成功处理了请求

// 3开头 （请求被重定向）表示要完成请求，需要进一步操作，通常这些状态代码用来重定向
301  // 永久移动，请求的网页已永久移动到新位置，服务器返回此响应时，会自动将请求者转到新位置
302  // 临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
304  // 未修改，自从上次请求后，请求的网页未修改过（服务器返回此响应时，不会返回网页内容），可以在请求时添加时间戳来处理

// 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理
400  // 错误请求，服务器不理解请求的语法
404  // 未找到，服务器找不到请求的网页

// 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误，这些错误可能是服务器本身的错误，而不是请求出错
500  // 服务器内部错误，服务器遇到错误，无法完成请求
```

----


## 浏览器缓存机制

内容很多，参考：

[浏览器缓存机制详解](http://mangguo.org/browser-cache-mechanism-detailed/)

[浏览器 HTTP 协议缓存机制详解](http://www.cnblogs.com/520yang/articles/4807408.html)



----

## cookie / csrf / xss

#### Cookie 机制（客户端）

因为 ```HTTP``` 协议是无状态的协议，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接

这就意味着服务器无法从连接上跟踪会话，所以利用 ```Cookie``` 来确认用户的身份

```Cookie``` 实际上是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用 ```response``` 向客户端浏览器颁发一个 ```Cookie```，客户端浏览器会把 ```Cookie``` 保存起来

当浏览器再请求该网站时，浏览器把请求的网址连同该 ```Cookie``` 一同提交给服务器，服务器检查该 ```Cookie```，以此来辨认用户状态，服务器还可以根据需要修改 ```Cookie``` 的内容

#### Session 机制（服务端）

除了使用 ```Cookie```，```Web``` 应用程序中还经常使用 ```Session``` 来记录客户端状态，```Session``` 是服务器端使用的一种记录客户端状态的机制，使用上比 ```Cookie``` 简单一些，相应的也增加了服务器的存储压力

```Session``` 是另一种记录客户状态的机制，不同的是 ```Cookie``` 保存在客户端浏览器中，而 ```Session``` 保存在服务器上

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 ```Session```，客户端浏览器再次访问时只需要从该 ```Session``` 中查找该客户的状态就可以了

如果说 ```Cookie``` 机制是通过检查客户身上的 "通行证" 来确定客户身份的话，那么 ```Session``` 机制就是通过检查服务器上的 "客户明细表" 来确认客户身份，```Session``` 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了

> ```Session``` 对象是在客户端第一次请求服务器的时候创建的


#### XSS

全名是：```Cross-site scripting```，为了和 ```CSS``` 层叠样式表区分所以取名 ```XSS```

```XSS``` 其实就是 ```Html``` 的注入问题，攻击者的输入没有经过严格的控制进入了数据库，最终显示给来访的用户，导致可以在来访用户的浏览器里以浏览用户的身份执行 ```Html``` 代码，工作原理大致如下

```
攻击者发现 XSS 漏洞 —— 构造代码 —— 发送给受害人 —— 受害人打开 —— 攻击者获取受害人的 cookie —— 完成攻击
```

当用户的 ```cookie``` 被拿到以后，如果服务端 ```session``` 没有设置过期的话，以后甚至拿这个 ```cookie``` 而不需用户名密码，就可以以这个用户的身份登录成功了

但是 ```XSS``` 容易发现，因为攻击者需要登录后台完成攻击，管理员可以看日志发现攻击者


#### CSRF

全名是：```Cross-site request forgery```，中文名称：跨站请求伪造，与 ```XSS``` 非常不同，```XSS``` 利用站点内的信任用户，而 ```CSRF``` 则通过伪装来自受信任用户的请求来利用受信任的网站

与 ```XSS``` 攻击相比，```CSRF``` 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 ```XSS``` 更具危险性

可以这么理解 ```CSRF``` 攻击：攻击者盗用了你的身份，以你的名义发送恶意请求

要完成一次 ```CSRF``` 攻击，受害者必须依次完成两个步骤：

* 登录受信任网站 ```A```，并在本地生成 ```Cookie```

* 在不登出 ```A``` 的情况下，访问危险网站 ```B```

```CSRF``` 攻击是源于 ```WEB``` 的隐式身份验证机制，```WEB``` 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的

#### 防御

可以从服务端和客户端两方面着手，总的思想都是一致的，就是在客户端页面增加伪随机数，让钓鱼网站无法正常伪造请求