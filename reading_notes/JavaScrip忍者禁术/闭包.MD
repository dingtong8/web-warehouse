## 闭包

简单来说，```closure``` 是一块域，这块域是由创建一个 ```function``` 而来，这个 ```function``` 可以访问和操作它的外部的变量

```js
var outerValue = 'ninja';
var later;

function outerFunction() {

    var innerValue = 'samurai';

    function innerFunction() {
        assert(outerValue, "I can see the ninja");
        assert(innerValue, "I can see the samurai");
    }
    
    later = innerFunction;
}

outerFunction();
later(); 
```

1. ```inner function``` 可以访问 ```outerValue```，因为 ```outerValue``` 属于全局域，

2. 由于 js 的特性，在正常情况下，全局域中我们是无法访问到 ```innerValue``` 的，但是通过将 ```innerFunction``` 赋给 ```later``` 变量，```later``` 就称为了域之间的桥梁，我们自然在全局域可以访问到 ```innerValue```。

当我们创建 ```innerFunction``` 的时候，不仅仅是定义了一个 ```function```，我们还创建了一个域。

在外部掉用 ```innerFUnction``` 的时候，虽然调用发生在全局域，但是 ```innerFunction``` 还是会访问当初被定义的时刻的那个原始域。这个域就是它的闭包（closure）

但是所有闭包中的信息数据都已经缓存在内存之中，如何释放掉这块内存呢？这里有两种办法：

1. 通过 JavaScript 引擎的 GC 垃圾回收机制

2. 刷新或者关闭当前页面。


#### 私有变量

```js
function Ninja() {
    var slices = 0;
    this.getSlices = function () {
        return slices;
    }
    this.slice = function () {
        slices++;
    }
}

var ninja = new Ninja();

ninja.slice();

assert(ninja.getSlices() == 1, "We're able to access the internal slice data.");
assert(ninja.slices == undefined, "And the private data is inaccessible to us."); 
```

在上面的例子中，函数内部的变量，只允许 Ninja 的内部方法来访问。


#### 绑定上下文

```js
var button = {
    clicked: false,
    click: function () {
        assert(this == elem, "This is the elem, not the object button")
        this.clicked = true;
        assert(button.clicked, "The button has been clicked");
    }
}

var elem = document.getElementById("btn");
elem.addEventListener("click", button.click, false);
```

运行后发现，结果并不是我们预期的，因为 click 方法并没有像我们预期那样绑定在 button 上，在这个例子中，函数的上下文对象是 dom 中的元素，利用闭包来修正这个问题：

```js
function bind(context, name) {
    return function () {
        return context[name].apply(context, arguments);
    };
}

var button = {
    clicked: false,
    click: function () {
        assert(this == button, "This is the object button")
        this.clicked = true;
        assert(button.clicked, "The button has been clicked");
    }
}

var elem = document.getElementById("btn");
elem.addEventListener("click", bind(button, "click"), false);
```

#### currying

```js
Function.prototype.curry = function () {
    var fn = this,
        // 这里就是在预装参数，将参数抓住，缓存在变量 args 中
        args = Array.prototype.slice.call(arguments);
    return function () {
        return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)))
    }
} 
```

但是如果我不想让所有的参数全部预装，而是只预装其中一部分，另外一部分参数要在调用闭包返回的那个新的函数中，将这部分参数传入（可以参考 functional.js）。

```js
Function.prototype.partial = function () {

    var fn = this, args = Array.prototype.slice.call(arguments);

    return function () {
        var arg = 0;
        for (var i = 0; i < args.length && arg < arguments.length; i++) {
            if (args[i] === undefined) {
                args[i] = arguments[arg++];
            }
        }
        return fn.apply(this, args);
    }
}

var delay = setTimeout.partial(undefined, 10);

delay(function () {assert(true, "A call to this function will be delayed 10 ms");})

var bindClick = document.body.addEventListener.partial("click", undefined, false);

bindClick(function () {
    assert(true, "Click event bound via curried function.");
}) 
```

```partial()``` 的实现和 ```curry()``` 有些相像。在第一批的参数中，我们用 ```undefined``` 代表了那部分缺省参数。在后面 ```delay``` 调用的时候，才将真正想要被处理的参数传递进去。


#### 记忆函数

在之前的部分，我们已经实现了 memoization() 函数，该函数采用了直接去更改一个已经存在的函数。现在我们来优化这个函数

```js
Function.prototype.memoized = function (key) {
    this._values = this._values || {};
    return this._values[key] !== undefined ?
        this._values[key] :
        this._values[key] = this.apply(this, arguments);
}

function isPrime(num) {
    var prime = num != 1;
    for (var i = 2; i < num; i++) {
        if (num % i == 0) {
            prime = false;
            break;
        }
    }
    return prime;
}

assert(isPrime.memoized(5), "The function works; 5 is prime.");
assert(isPrime._values[5], "The answer has been cached."); 
```

上面的这个例子还有一个小缺点，在于：调用 ```isPrime()``` 的时候还必须记得要调用 ```.memoized()``` 方法，来实现 ```memoization```，现在来用闭包解决这个问题：

```js
Function.prototype.memoized = function (key) {
    this._values = this._values || {};
    xyz = this._values;
    return this._values[key] !== undefined ?
        this._values[key] :
        this._values[key] = this.apply(this, arguments);
}

// 这里的 memoize 就是利用闭包的特性，来隐性的更改了 ipPrime 的行为
Function.prototype.memoize = function () {
    var fn = this; //#1
    return function () { //#2
        return fn.memoized.apply(fn, arguments);
    }
}

var isPrime = (function (num) {
    var prime = num != 1;
    for (var i = 2; i < num; i++) {
        if (num % i == 0) {
            prime = false;
            break;
        }
    }
    return prime;
}).memoize(); 
```

我们创建了一个新的方法，```memoize()```。在 ```memozie()``` 中，利用 ```memoized()``` 重新包裹了原始函数(originalfunction)。这样一来，memoize 返回的函数就永远会是具备了 momoized 能力的函数(#2)

请注意，在 ```momozie()``` 这个方法中，我们构建了一个闭包，在这个闭包中通过 fn 这个变量拷贝了原始函数：isPrime 函数(通过获取其上下文 ＃1)，这是一个很通用的技巧：**每个函数都拥有自己的上下文，所以上下文从来都不是闭包的一部分**。

但是我们可以利用一个变量来关联原始函数的上下文的值，这样就等同于函数上下文(isPrime context)成为了闭包的一部分。由于原始函数已经成为了闭包的一部分，那么闭包自然可以在返回的新函数中，随意的操作原始函数(isPrime)，让其具备记忆能力.


#### 函数包装（看起来比较绕，先挖个坑，以后再回来看这章）

```js
function wrap(object, method, wrapper) {
    var fn = object[method]; //#1
    return object[method] = function () { //#2
        return wrapper.apply(this, [fn.bind(this)].concat(
            Array.prototype.slice.call(arguments)));
    }
}

// Example adapted from Prototype
if (Prototype.Browser.Opera) { //#3
    wrap(Element.Methods, "readAttribute",
        function (original, elem, attr) {
            return attr == 'title' ? elem.title : original(elem, attr);
        })
}

//#1 缓存原始函数
//#2 返回新的包装函数
//#3 实现函数包装 
```

我们来分析一下 ```wrap()``` 函数是如何工作的。在传入 ```wrapp()``` 的参数中包括：

1. 一个基础的对象(object)

2. 这个基础对象想要被包装的方法(method)

3. 新的包装函数(wrapper)

首先，我们将原始方法保存在变量 ```fn``` 中(#1)，我们在后面会通过匿名函数的闭包(anonymous function‟s closure)来调用它。

然后我们用一个新的函数来重写这个方法(#2)这个新的函数执行了之前传进来的 ```wrapper``` 函数(通过一个闭包)，并且传给它一个重新构造的参数列表.

在构建这个参数列表时，我们想让第一个参数是我们正在重写的原始函数(original function)，这样一来，我们创建一个数组来连接原始函数(原始函数的上下文已经被绑定，通过 bind()函数)，然后将原始参数追加到这个数组中。

在 ```apply()``` 函数中，如我们所见，用这个数组作为了他的参数列表。















