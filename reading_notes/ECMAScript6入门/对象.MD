#### 属性的简洁表示法

ES6 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = "bar";
var baz = {foo};
baz;  // {foo: "bar"}

// 等同于

var baz = {foo: foo};
```

```js
function f(x, y) {
    return { x, y };
}

//  等同于

function f(x, y) {
    return { x: x, y: y };
}

f(1, 2);  // Object {x: 1, y: 2}
```

除了属性简写，方法也可以简写

```js
var o = {
    method () {
        return "hello"
    }
};

// 等同于

var o = {
    method: function () {
        return "hello"
    }
}
```

```js
var birth = "2000/01/01"

var Person = {

    name: "张三",

    // 等同于 birth: birth
    birth,

    // 等同于 hello: function () ...
    hello () {
        console.log("my name is " + this.name)
    }
}
```

这种写法用于函数的返回值，非常便捷

```js
function getPoint () {
    var x = 1;
    var y = 2;
    return {x, y};
}

getPoint();  // {x: 1, y: 2}
```

CommonJS 模块输出变量，就非常适合使用简洁写法：

```js
var ms = {};

function getItem (key) {
    return key in ms ? ms[key] : null;
}

function setItem (key, value) {
    ms[key] = value;
}

function clear () {
    ms = {};
}

module.exports = { getItem, setItem, clear };

// 等同于

module.exports = {
    getItem: getItem,
    setItem: setItem,
    clear: clear
}
```

属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法

```js
var cart = {
    _wheels: 4,

    get wheels () {
        return this._wheels;
    },

    set wheels (value) {
        if (value < this._wheels) {
            throw new Error("数值太小了！");
        }
        this._wheels = value;
    }
}
```

需要注意的是：简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果

```js
// class 为字符串，不会因为其输入关键字，而导致语法解析报错
var obj = {
    class () {}
};

// 等同于

var obj = {
    "class": function () {}
}
```

如果某个方法的值是一个 Generator 函数，前面需要加上星号

```js
var obj = {
    * m () {
        yield "hello world";
    }
}
```



#### 属性名表达式

定义对象的属性，有两种方法

```js
// 方法一
// 直接使用标识符作为属性名
obj.foo = true;

// 方法二
// 使用表达式作为属性名
obj["a" + "bc"] = 123;
```

但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用标识符定义属性

```js
var obj = {
    foo: true,
    abc: 123
}
```

ES6 允许字面量定义对象，使用表达式作为对象的属性名，即把表达式放在方括号内

```js
let propKey = "foo";

let obj = {
    [propKey]: true,
    ["a" + "bc"]: 123
}

console.log(obj);  // {foo: true, abc: 123}
```

另外一个例子

```js
var lastWord = "last word"

var a = {
    "first word": "hello",
    [lastWord]: "world",
}

a["first word"];  // "hello"

a[lastWord];  // "world"

a["last word"];  // "world"
```

表达式还可以用于定义方法名

```js
let obj = {
    ["h" + "ello"] () {
        return "hi";
    }
}

obj.hello();  // hi
```

属性名表达式与简洁表示法，不能同时使用，否则会报错

```js
// 报错
var foo = "bar";
var bar = "abc";
var baz = { [foo] };

// 正确
var foo = "bar";
var baz = { [foo]: "abc" };
```

特别需要注意的一点是：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object, Object]

```js
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
    [keyA]: "valueA",
    [keyB]: "valueB"
};

myObject  // Object {[object Object]: "valueB"}
```

上面代码中，```[keyA]``` 和 ```[keyB]``` 得到的都是 ```[object Object]```，所以 ```[keyB]``` 会把 ```[keyA]``` 覆盖掉，而 ```myObject``` 最后只有一个 ```[object Object]``` 属性