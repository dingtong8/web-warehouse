## 读写操作

`open()` 将会返回一个 `file` 对象，基本语法为 `open(filename, mode)`

* `filename：filename` 变量是一个包含了你要访问的文件名称的字符串值

* `mode：mode` 决定了打开文件的模式（如下所示），默认文件访问模式为只读（`r`）


|模式	|描述|
|-|-|
|r|	以只读方式打开文件，文件的指针将会放在文件的开头，这是默认模式|
|rb	|以二进制格式打开一个文件用于只读，文件指针将会放在文件的开头，这是默认模式|
|r+	|打开一个文件用于读写，文件指针将会放在文件的开头|
|rb+	|以二进制格式打开一个文件用于读写，文件指针将会放在文件的开头|
|w|	打开一个文件只用于写入，如果该文件已存在则将其覆盖，如果该文件不存在，创建新文件|
|wb	|以二进制格式打开一个文件只用于写入，如果该文件已存在则将其覆盖，如果该文件不存在，创建新文件|
|w+	|打开一个文件用于读写，如果该文件已存在则将其覆盖，如果该文件不存在，创建新文件|
|wb+|	以二进制格式打开一个文件用于读写，如果该文件已存在则将其覆盖，如果该文件不存在，创建新文件|
|a|	打开一个文件用于追加，如果该文件已存在，文件指针将会放在文件的结尾，也就是说，新的内容将会被写入到已有内容之后，如果该文件不存在，创建新文件进行写入|
|ab|	以二进制格式打开一个文件用于追加，如果该文件已存在，文件指针将会放在文件的结尾，也就是说，新的内容将会被写入到已有内容之后，如果该文件不存在，创建新文件进行写入|
|a+	|打开一个文件用于读写，如果该文件已存在，文件指针将会放在文件的结尾，文件打开时会是追加模式，如果该文件不存在，创建新文件用于读写|
|ab+|	以二进制格式打开一个文件用于追加，如果该文件已存在，文件指针将会放在文件的结尾，如果该文件不存在，创建新文件用于读写|


一个简单的示例

```python
# 打开一个文件，如果文件不存在，会自动创建
# 一个参数为要打开的文件名
# 第二个参数描述文件如何使用的字符，参数是可选
# 'r'，表示文件只读，不能写入，同时也是默认值
# 'w' 只用于写 (如果存在同名文件则将被删除)
# 'a' 用于追加文件内容，所写的任何数据都会被自动增加到末尾
# 'r+' 同时用于读写
f = open('data.txt', 'w')
f.write('test')

# 记得操作完成要进行关闭
f.close()
```

## 文件对象的方法

接上面示例，我们定义了一个名为 `f` 的文件对象

#### f.read()

表示读取一个文件的内容，使用 `f.read(size)`，这将读取一定数目的数据, 然后作为字符串或字节对象返回

`size` 是一个可选的数字类型的参数，当 `size` 被忽略或者为负，那么该文件的所有内容都将被读取并且返回

```python
f = open('data.txt', 'r')

str = f.read()
print(str)

f.close()
```

#### f.readline()

同样也是读操作，但是只会从文件中读取单独的一行，如果返回一个空字符串, 说明已经已经读取到最后一行

```python
f = open('data.txt', 'r')

str = f.readline()
print(str)

f.close()
```


#### f.readlines()

将返回该文件中包含的所有行，结果为一个 `list`，用 `','` 进行分隔，回车（换行）会被格式化成 `'\n'`

```python
f = open('data.txt', 'r')

str = f.readlines()
print(str)

f.close()
``` 


#### f.close

当处理完一个文件后, 调用 `f.close()` 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常









## 面向对象

一个简单的类如下所示

```python
class MyClass:
  x = 12345
  def f(self):
    return 'hello world'

# 实例化类
m = MyClass()

# 调用类的属性和方法
print(m.x)
print(m.f())
```

上面代码创建了一个新的类实例并将该对象赋给局部变量 `m`（`m` 为空的对象）

实际开发中，很多类都倾向于将对象创建为有初始状态的，所以一般会定义一个 `__init__()` 的特殊方法

```python
def __init__(self):
  self.data = []
```

如果定义了 `__init__()` 方法的话，类的实例化操作会自动调用 `__init__()` 方法，比如如下示例

```python
class Complex:
  def __init__(self, realpart, imagpart):
    self.r = realpart
    self.i = imagpart

x = Complex(3, 4)
print(x.r, x.i)
```


#### self

`self` 代表的是类的实例，而不是类

类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 `self`

```python
class Test:
  def prt(self):
    print(self)
    print(self.__class__)

t = Test()
t.prt()

# <__main__.Test object at 0x021032B0>
# <class '__main__.Test'>
```

从结果可以看出，`self` 代表的是类的实例，代表当前对象的地址，而 `self.class` 则指向类


#### 类的方法

在类的内部，使用 `def` 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 `self`, 且为第一个参数，`self` 代表的是类的实例

```python
class people:
  name = ''
  age = 0
  __weight = 0

  def __init__(self, n, a, w):
    self.name = n
    self.age = a
    self.__weight = w

  def speak(self):
    print('%s 说：我今年 %d 岁，体重是 %d 千克' %(self.name, self.age, self.__weight))

p = people('zhangsan', 12, 40)
p.speak()  # zhangsan 说：我今年 24 岁，体重是 60 千克
```


#### 继承

基本语法如下

```python
class DerivedClassName(BaseClassName1):
  ...
```

需要注意括号当中的基类的顺序，若是基类当中有相同的方法名，而在子类使用时如果未指定，`python` 则会从左至右搜索

即方法在子类中未找到时，从左到右查找基类中是否包含方法，不过需要注意的是，基类必须与派生类定义在同一个作用域当中

除了类还可以使用表达式，这对于基类定义在另一个模块中的时候就十分有用了

```python
class DerivedClassName(modname.BaseClassName):
  ...
```

下面来看一个实例

```python
# 定义基类
class people:

  # 定义基本属性
  name = ''
  age = 0
  
  # 定义私有属性，在外部无法直接进行访问
  __weight = 0

  # 定义初始化的构造方法
  def __init__(self, n, a, w):
    self.name = n
    self.age = a
    self.__weight = w

  def speak(self):
    print('%s 说：我今年 %d 岁，体重是 %d 千克' %(self.name, self.age, self.__weight))


# 单继承
class student(people):
  grade = ''

  def __init__(self, n, a, *w, g):
    # 调用父类的构造
    people.__init__(self, n, a, w)
    self.grade = g
  
  # 覆盖父类的方法
  def speak(self):
    print('%s 说，我今年 %d 岁了，就读于 %d 年级' %(self.name, self.age, self.grade))

# 调用
s = student(n = 'lisi', a = 12, g = 4)
s.speak()
```