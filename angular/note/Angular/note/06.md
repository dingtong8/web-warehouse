## 依赖注入

所谓[依赖注入](https://zh.wikipedia.org/wiki/依赖注入)，本质是一种实现[控制反转](https://zh.wikipedia.org/wiki/控制反转)用于解决依赖性设计模式（详细可见对应的维基百科）

依赖注入允许程序设计遵从依赖倒置原则，调用者只需知道服务的接口，具体服务的查找和创建由注入器 (Injector) 负责处理并提供给调用者，这样就分离了服务和调用者的依赖，符合低耦合的程序设计原则

依赖注入中包含三种角色：调用者、服务和注入器 (Injector)，在 Angular 中 Injector (注入器) 用来管理服务对象的创建和获取


## Injector 抽象类

```js
// angular2\packages\core\src\di\injector.ts
export abstract class Injector {
  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  static NULL: Injector = new _NullInjector();

  /**
   * 定义了一个 get() 抽象方法，该方法用于根据给定的 Token 从注入器中获取相应的对象
   * 如果没有找到相应的对象，将返回 notFoundValue 设置的值
   * 若 notFoundValue 的值与 _THROW_IF_NOT_FOUND 相等，则会抛出异常
   */
  abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T): T;
}

const _THROW_IF_NOT_FOUND = new Object();
```

需要注意的是，每个 Injector 抽象类的子类都必须实现该方法，在 Angular 当中常见的有

* `_NullInjector`

* `ReflectiveInjector`


## _NullInjector 类

_NullInjector 类的实例用于表示空的注入器

```js
// angular2\packages\core\src\di\injector.ts
class _NullInjector implements Injector {

  // 实现 get() 方法
  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {
    if (notFoundValue === _THROW_IF_NOT_FOUND) {
      throw new Error(`No provider for ${stringify(token)}!`);
    }
    return notFoundValue;
  }
}
```


## ReflectiveInjector 抽象类

ReflectiveInjector 表示一个依赖注入的容器，用于实例化对象和解析依赖，下面是常见的使用方式

```js
@Injectable()
class Engine { }

@Injectable()
class Car {
  constructor(public engine: Engine) { }
}

// 调用 ReflectiveInjector 抽象类的 resolveAndCreate() 方法来创建注入器
var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);

// 然后调用注入器的 get() 方法，获得 Token 对应的对象
var car = injector.get(Car);

expect(car instanceof Car).toBe(true);
expect(car.engine instanceof Engine).toBe(true);
```

ReflectiveInjector 除了 resolveAndCreate() 静态方法外，还有两个常见的

* resolve() - 解析 Provider 列表为 ResolvedReflectiveProvider 列表

* fromResolvedProviders() - 基于 ResolvedReflectiveProvider 列表创建 ReflectiveInjector 对象

#### resolveAndCreate()

```js
// 通过调用 resolve() 和 fromResolvedProviders() 方法来创建 ReflectiveInjector 对象（返回的是该对象）
static resolveAndCreate(providers: Provider[], parent ?: Injector): ReflectiveInjector {
  const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
  return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
}
```


#### resolve()

该方法用于把 Provider 数组解析为