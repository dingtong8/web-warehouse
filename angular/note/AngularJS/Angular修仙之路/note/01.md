## Http 模块

首先导入 Http 模块

```js
// ... 
import { HttpModule } from '@angular/http';

@NgModule({
  imports: [BrowserModule, FormsModule, HttpModule],
  declarations: [AppComponent, UserComponent],
  bootstrap: [AppComponent]
})

export class AppModule { }
```

使用 Http 服务步骤如下

(1) 从 `@angular/http` 模块中导入 `Http` 类

(2) 导入 `RxJS` 中的 `map` 操作符

(3) 使用 `DI` 方式注入 `http` 服务

(4) 调用 `http` 服务的 `get()` 方法，设置请求地址并发送 `HTTP` 请求

(5) 调用 `Response` 对象的 `json()` 方法，把响应体转成 `JSON` 对象

(6) 把请求的结果，赋值给对应的属性

示例如下：

```js
import { Component, OnInit } from '@angular/core';
import { Http } from '@angular/http'; // (1)
import 'rxjs/add/operator/map'; // (2)

interface Member {
  id: string;
  login: string;
  avatar_url: string;
}

@Component({
  selector: 'sl-members',
  template: `
    <h3>Angular Orgs Members</h3>
    <ul *ngIf="members">
      <li *ngFor="let member of members;">
        <p>
          ID：<span>{{member.id}}</span>
          Name: <span>{{member.login}}</span>
        </p>
      </li>
    </ul>
    `
})

export class MembersComponent implements OnInit {
  members: Member[];

  constructor(private http: Http) { } // (3)

  ngOnInit() {
    this.http.get(``) // (4)
      .map(res => res.json()) // (5)
      .subscribe(data => {
        if (data) this.members = data; // (6)
      });
  }
}
```


## 路由

|名称|简介|
|-|-|
|Routes|路由配置，保存着哪个 URL 对应展示哪个组件，以及在哪个 RouterOutlet 中展示组件|
|RouterOutlet|在 HTML 中标记路由内容呈现位置的占位符指令|
|Router|负责在运行的时候执行路由的对象，可以通过调用其 navigate() 和 navigateByUrl() 方法来导航一个指定的路由|
|RouterLink|在 HTML 中声明路由导航用的指令|
|ActivatedRoute|当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等|


#### 获取动态路由的值

首先需要引入相关依赖

```js
import { Route, ActivatedRoute, Params } from '@angular/router';
```

然后进行注入之后就可以使用了

```js
constructor(
    private router: ActivatedRoute
  ) { }

  ngOnInit() {
    // 这样就可以拿到动态传递过来的值
    // 但是传递过来的是一个 Observable 对象，所以可以直接去监听
    console.log(this.router.params);

    this.router.params.subscribe((val) => {
      console.log(val.id);
    });
  }
```

#### 通配路由一般放在最后一个

如下所示

```js
const routes: Router = [
  { path: '', component: HomeComponent },
  { path: 'detail', component: DetailComponent },
  { path: '**', component: NotFoundComponent },
]
```

#### 在路由时传递数据

一般分为三种情况

* 在查询参数中传递数据

比如在路由的时候设置为

```html
<a [routerLink]="['/product']" [queryParams]="{id: 1, name: 2}">详情</a>
```

这样跳转过去以后，页面的路径会自动加上 '/product?id=1&name=2' 这样的后缀

而在接收的时候可以使用

```js
ActivatedRoute.queryParams[id]

ActivatedRoute.queryParams[name]
```

来获取对应传递的参数

* 在路由路径中传递数据

首先需要在路由当中指定参数的名称

```js
{ path:'/product/:id' }
```

路由的时候设置为

```html
<a [routerLink]="['/product', 1]">详情</a>
```

然后在访问比如 product/1 这个页面的时候，使用

```js
ActivatedRoute.params[id]
```

来获取对应的参数信息

> 需要注意，两者的参数名称需要一致

* 在路由配置中传递数据

直接在路由当中定义需要传递的参数

```js
{ path/product, component: ProductComponent, data: [{ isProd: true }]}
```

然后在取值的时候使用以下方法来获取在路由定义当中的数据

```js
ActivatedRoute.data[0][isProd]
```


#### 路由守卫

* CanActivate 处理导航到某路由的情况

* CanDeactivate 处理从当前路由离开的情况

* Resolve 在路由激活之前获取路由数据




## 依赖注入

分为注入器和提供器

使用的时候定义一个变量用来接收对应的服务 ProductServicr

```js
constructor(
    private productServicr: ProductServicr
  ) { }
```

而在定义的时候，需要在提供器的 providers 属性当中指明

```js
providers: [ProjectDirective]

// 等价于下面这种写法，因为 provide 和 useClass 两者的属性皆为 ProductServicr
// 所以可以简写成上面那种形式
providers: [{
  // provide 属性指定了提供器的 token（key）
  // 就是根据这个属性来匹配注入的对象和提供器
  // 然后才会根据提供器的 useClass 属性再去具体实例化某个类
  provide: ProductServicr,
  // 指明实例化的方式为 new 操作（因为定义的为 useClass）
  // 比如上方在 constructor 当中注入的 ProductServicr 就是经过 new 操作之后的
  // 如果这里定义为 useClass: AnotherProductServicr 的话就不能使用简写的方式
  useClass: ProductServicr
}]
```

还可以使用如下方式

```js
providers: [{
  provide: ProductServicr,
  // 在这种情况下就不再是直接去执行 new 一个类的操作了
  // 而是通过一个工厂方法返回一个实例，再将这个实例注入到 providers 当中
  // 比如做一些初始化的工作
  useFactory: () => { ... }
}]
```


#### 提供器的作用域规则

* 当一个提供器声明在模块当中时（Module），对于该模块下的所有组件是可见的，所有组件都是可以注入的

  * 即在当前模块的 @NgModule 当中的 providers 当中进行注入之后，当前模块下所有组件可用

* 当一个提供器声明在组件当中时（Component），只对声明它的组件及其子组件可见，其他组件不可注入

* 当在模块（Module）和组件（Component）当中声明的提供器具有相同的 token（key）的时候

  * 那么组件当中的提供器会覆盖声明在模块当中的提供器（就近原则）

* 一般情况下优先将服务提供器声明在模块当中

  * 只有在服务只针对某个组件使用，并且对其他组件不可见的时候，才会声明在组件当中

  * 这种情况十分少见，所以一般推荐声明在模块当中

* 补充：服务能不能注入到其他地方，是由它在没有在当前模块的 providers 当中声明来决定的