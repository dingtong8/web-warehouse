## Http 模块

首先导入 `Http` 模块

```js
// ... 
import { HttpModule } from '@angular/http';

@NgModule({
  imports: [BrowserModule, FormsModule, HttpModule],
  declarations: [AppComponent, UserComponent],
  bootstrap: [AppComponent]
})

export class AppModule { }
```

使用 Http 服务步骤如下

1. 从 `@angular/http` 模块中导入 `Http` 类

2. 导入 `RxJS` 中的 `map` 操作符

3. 使用 `DI` 方式注入 `http` 服务

4. 调用 `http` 服务的 `get()` 方法，设置请求地址并发送 `HTTP` 请求

5. 调用 `Response` 对象的 `json()` 方法，把响应体转成 `JSON` 对象

6. 把请求的结果，赋值给对应的属性

示例如下：

```js
import { Component, OnInit } from '@angular/core';
import { Http } from '@angular/http'; // 1
import 'rxjs/add/operator/map'; // 2

interface Member {
  id: string;
  login: string;
  avatar_url: string;
}

@Component({
  selector: 'sl-members',
  template: `
    <h3>Angular Orgs Members</h3>
    <ul *ngIf="members">
      <li *ngFor="let member of members;">
        <p>
          ID：<span>{{member.id}}</span>
          Name: <span>{{member.login}}</span>
        </p>
      </li>
    </ul>
    `
})

export class MembersComponent implements OnInit {
  members: Member[];

  constructor(private http: Http) { } // 3

  ngOnInit() {
    this.http.get(``) // 4
      .map(res => res.json()) // 5
      .subscribe(data => {
        if (data) this.members = data; // 6
      });
  }
}
```























## 路由

|名称|简介|
|-|-|
|Routes|路由配置，保存着哪个 URL 对应展示哪个组件，以及在哪个 RouterOutlet 中展示组件|
|RouterOutlet|在 HTML 中标记路由内容呈现位置的占位符指令|
|Router|负责在运行的时候执行路由的对象，可以通过调用其 navigate() 和 navigateByUrl() 方法来导航一个指定的路由|
|RouterLink|在 HTML 中声明路由导航用的指令|
|ActivatedRoute|当前激活的路由对象，保存着当前路由的信息，如路由地址，路由参数等|


#### 获取动态路由的值

首先需要引入相关依赖

```js
import { Route, ActivatedRoute, Params } from '@angular/router';
```

然后进行注入之后就可以使用了

```js
constructor(
    private router: ActivatedRoute
  ) { }

  ngOnInit() {
    // 这样就可以拿到动态传递过来的值
    // 但是传递过来的是一个 Observable 对象，所以可以直接去监听
    console.log(this.router.params);

    this.router.params.subscribe((val) => {
      console.log(val.id);
    });
  }
```

#### 通配路由一般放在最后一个

如下所示

```js
const routes: Router = [
  { path: '', component: HomeComponent },
  { path: 'detail', component: DetailComponent },
  { path: '**', component: NotFoundComponent },
]
```

#### 在路由时传递数据

一般分为三种情况

* 在查询参数中传递数据

比如在路由的时候设置为

```html
<a [routerLink]="['/product']" [queryParams]="{id: 1, name: 2}">详情</a>
```

这样跳转过去以后，页面的路径会自动加上 `'/product?id=1&name=2'` 这样的后缀

而在接收的时候可以使用

```js
ActivatedRoute.queryParams[id]

ActivatedRoute.queryParams[name]
```

来获取对应传递的参数

* 在路由路径中传递数据

首先需要在路由当中指定参数的名称

```js
{ path:'/product/:id' }
```

路由的时候设置为

```html
<a [routerLink]="['/product', 1]">详情</a>
```

然后在访问比如 `product/1` 这个页面的时候，使用

```js
ActivatedRoute.params[id]
```

来获取对应的参数信息

> 需要注意，两者的参数名称需要一致

* 在路由配置中传递数据

直接在路由当中定义需要传递的参数

```js
{ path/product, component: ProductComponent, data: [{ isProd: true }]}
```

然后在取值的时候使用以下方法来获取在路由定义当中的数据

```js
ActivatedRoute.data[0][isProd]
```


#### 路由守卫

* `CanActivate` 处理导航到某路由的情况

* `CanDeactivate` 处理从当前路由离开的情况

* `Resolve` 在路由激活之前获取路由数据























## 依赖注入

在 `Angular` 当中，可以通过指定 `providers` 来告诉 `Angular` 哪些对象需要依赖注入

```js
@NgModule({
  // 为一个数组，里面当中的每一个元素被称为 provider
  // 一个 provider 定义了一个对象在被注入到组件和指令中之前如何实例化
  providers: [ProductService],
  // ...
})

export class AppModule { }
```


#### 注入器和提供器

使用的时候定义一个变量用来接收对应的服务 `ProductServicr`

```js
constructor(
    private productServicr: ProductServicr
  ) { }
```

而在定义的时候，需要在提供器的 `providers` 属性当中指明

```js
providers: [ProjectDirective]

// 等价于下面这种写法，因为 provide 和 useClass 两者的属性皆为 ProductServicr
// 所以可以简写成上面那种形式
providers: [{
  // provide 属性指定了提供器的 token（key）
  // 就是根据这个属性来匹配注入的对象和提供器
  // 然后才会根据提供器的 useClass 属性再去具体实例化某个类
  provide: ProductServicr,
  // 指明实例化的方式为 new 操作（因为定义的为 useClass）
  // 比如上方在 constructor 当中注入的 ProductServicr 就是经过 new 操作之后的
  // 如果这里定义为 useClass: AnotherProductServicr 的话就不能使用简写的方式
  useClass: ProductServicr
}]
```

还可以使用如下方式

```js
providers: [{
  provide: ProductServicr,
  // 在这种情况下就不再是直接去执行 new 一个类的操作了
  // 而是通过一个工厂方法返回一个实例，再将这个实例注入到 providers 当中
  // 比如做一些初始化的工作
  useFactory: () => { ... }
}]
```


#### 提供器的作用域规则

* 当一个提供器声明在模块当中时（`Module`），对于该模块下的所有组件是可见的，所有组件都是可以注入的

  * 即在当前模块的 `@NgModule` 当中的 `providers` 当中进行注入之后，当前模块下所有组件可用

* 当一个提供器声明在组件当中时（`Component`），只对声明它的组件及其子组件可见，其他组件不可注入

* 当在模块（`Module`）和组件（`Component`）当中声明的提供器具有相同的 `token`（`key`）的时候

  * 那么组件当中的提供器会覆盖声明在模块当中的提供器（就近原则）

* 一般情况下优先将服务提供器声明在模块当中

  * 只有在服务只针对某个组件使用，并且对其他组件不可见的时候，才会声明在组件当中

  * 这种情况十分少见，所以一般推荐声明在模块当中

* 补充：服务能不能注入到其他地方，是由它在没有在当前模块的 `providers` 当中声明来决定的


#### @Injectable

* 只有声明了 `@Injectable()` 这个装饰器的服务才可以注入其他服务

* 建议对于服务，始终加上 `@Injectable()`，这样所有服务都遵循同样的规则，一致性


#### 如果所依赖的服务是动态加载的

一个简单的示例，随机生成的随机数动态加载对应服务

```js
// app.module.ts
@NgModule({
  // ...

  providers: [{
    provide: ProductService,
    useFactory: () => {
      let logger = new LoggerService();
      let dev = Math.random() > 0.5
      if (dev) {
        return new ProductService(logger)
      } else {
        return new AnotherProductService(logger)
      }
    }
  }, LoggerService]
})

// logger.service.ts
// 一个简单的打印日志的服务
import {} from '@angular/core'

@Injectable()
export class LoggerService {
  constructor() { }
  log (messgae: string) {
    console.log(messgae)
  }
}
```

需要注意，如果多个组件共用这个服务，那么生成的实例都是相同的，因为工厂方法创建的对象是一个单例对象

工厂方法只会在创建第一个对象的时候被调用一次，然后在整个应用当中所有被注入的服务的实例都是同一个对象

上面的实例中存在两个问题

* 第一个问题

在方法内部，手动实例化了一个 `new LoggerService()`，意味着工厂方法与这个类是一种强耦合的关系

而我们又声明了 `LoggerService` 的提供器，所以可以采用下面这种方式来解耦

利用第三个参数 `deps` 来声明工厂方法所依赖的参数

```js
@NgModule({
  // ...

  providers: [{
    provide: ProductService,
    useFactory: (logger： LoggerService) => {
      let dev = Math.random() > 0.5
      if (dev) {
        return new ProductService(logger)
      } else {
        return new AnotherProductService(logger)
      }
    },
    deps: [LoggerService]
  }, LoggerService]
})
```

这时 `Angular` 将会使用 `LoggerService` 这个提供器来实例化一个 `LoggerService` 的实例

并将其注入到 `ProductService` 的工厂方法的参数当中

* 第二个问题

我们是根据一个随机数来决定实例化哪个对象，这样测试是可以的，但是在发布的时候就不适用了

在这种情况下就可以使用一个变量来决定调用哪个方法

然后同样的在 `deps` 当中进行依赖声明，然后在当作参数的时候传递进去

```js
@NgModule({
  // ...

  providers: [
    {
      provide: ProductService,
      useFactory: (logger： LoggerService, isDev) => {
        if (isDev) {
          return new ProductService(logger)
        } else {
          return new AnotherProductService(logger)
        }
      },
      deps: [LoggerService, 'IS_DEV_ENV']
    }, 
    LoggerService, 
    {
      provide: 'IS_DEV_ENV',
      useValue: false
    }
  ]
})
```

同样的，可以不单一的注入一个固定的值，也是可以注入一个对象，方便维护

```js
@NgModule({
  // ...

  providers: [
    {
      provide: ProductService,
      useFactory: (logger： LoggerService, appConfig) => {
        if (appConfig.isDev) {
          return new ProductService(logger)
        } else {
          return new AnotherProductService(logger)
        }
      },
      deps: [LoggerService, 'APP_CONFIG']
    }, 
    LoggerService, 
    {
      provide: 'APP_CONFIG',
      useValue: {
        isDev: false
      }
    }
  ]
})
```


#### 注入器的层级关系

前面的提供器只负责实例化所需的依赖对象，将实例化好的对象注入所需组件的工作则是由注入器来完成的

在程序启动的时候， Angular 首先会创建一个应用级注入器，然后将模块中声明的提供器，都注册到这个注入器当中

被注册的提供器除了应用的主模块声明的以外，还包括所有被引用的模块中声明的提供器

比如

```js
// app.module.ts
@NgModule({
  // ...
  imports: [
    BrowserModule, 
    FormsModule, 
    HttpModule
  ],
  providers: [
    // ...
  ]
})
```

在应用级的注入器里面，除了 `AppModule` 本身声明的一些提供器（`providers`）会被注册以外

它引入的部分（`imports`）所有其他的模块，这些模块当中声明的提供器都会被注册到应用级注入器当中

然后 `Angular` 会创建启动模块指定的主组件（`bootstrap` 指定的模块），同时应用级别的注入器会为这个主组件创建一个组件级的注入器，并将组件中声明的提供器注册到这个组件级的注入器上

当子组件被创建的时候，它的父组件的注入器会为这个子组件也创建一个注入器，然后将子组件声明的提供器注册上去

以此类推，应用中会形成一组注入器，这些注入器会形成一个与组件的上下级关系一样的层级关系

不过在一般情况下 `Angular` 可以通过构造函数的参数自动注入所需的依赖

```js
constructor(private http: Http) { }
```

同时也需要注意，`Angular` 的依赖注入点只有一个，就是它的构造函数

如果一个组件的构造函数为空，那么就可以断定，这个函数没有被注入任何东西

简单来说，分为

```
应用级的注入器  ==>  主组件注入器  ==>  子组件注入器
```


#### 手动添加注入器（避免此类操作）

> 但是需要注意，在实际的使用当中避免使用这种方式

```js
import { Component, OnInit, Injector } from '@angular/core'
import { ProductService } from './product.service'

export class ProductComponent implements OnInit {
  private productService: ProductService;

  constructor(private injector: Injector) {
    this.productService = injector.get(this.productService)
  }
}
```