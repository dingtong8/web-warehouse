## 01. 自定义属性指令中的 ElementRef 与 Renderer 的作用

为了能够支持跨平台，`Angular` 通过抽象层封装了不同平台的差异，统一了 `API` 接口

如定义了抽象类 `Renderer` 、抽象类 `RootRenderer` 等。此外还定义了以下引用类型：`ElementRef`、`TemplateRef`、`ViewRef`、`ComponentRef` 和 `ViewContainerRef` 等


#### ElementRef 的作用

在应用层直接操作 `DOM`，就会造成应用层与渲染层之间强耦合，导致我们的应用无法运行在不同环境（比如 `Web Workers`）

通过 `ElementRef` 我们就可以封装不同平台下视图层中的 `native` 元素，最后借助于 `Angular` 提供的强大的依赖注入特性，我们就可以轻松地访问到 `native` 元素


#### ElementRef 的定义

```js
export class ElementRef {
  public nativeElement: any;
  constructor(nativeElement: any) {
    this.nativeElement = nativeElement;
  }
}
```

#### Renderer2 常用方法

要注意的是在 `Angular 4.x+` 版本，我们使用 `Renderer2` 替代 `Renderer`

```js
export abstract class Renderer2 {
  abstract createElement(name: string, namespace?: string|null): any;
  abstract createComment(value: string): any;
  abstract createText(value: string): any;
  abstract setAttribute(el: any, name: string, value: string, namespace?: string|null): void;
  abstract removeAttribute(el: any, name: string, namespace?: string|null): void;
  abstract addClass(el: any, name: string): void;
  abstract removeClass(el: any, name: string): void;
  abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;
  abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;
  abstract setProperty(el: any, name: string, value: any): void;
  abstract setValue(node: any, value: string): void;
  abstract listen(target: 'window'|'document'|'body'|any, eventName: string, callback: (event: any) => boolean | void): () => void;
}
```


## 02. 自定义结构指令中的 TemplateRef 与 ViewContainerRef 的作用

#### TemplateRef

用于表示内嵌的 `template` 模板元素，通过 `TemplateRef` 实例，我们可以方便创建内嵌视图(`Embedded Views`)

```js
ngAfterViewInit() {
  let view = this.tpl.createEmbeddedView(null);
}
```

且可以轻松地访问到通过 `ElementRef` 封装后的 `nativeElement`

需要注意的是组件视图中的 `template` 模板元素，经过渲染后会被替换成 `comment` 元素

因为 `<template>` 模板元素，已经被 `Angular 2` 解析并封装成 `TemplateRef` 实例，通过 `TemplateRef` 实例，我们可以方便地创建内嵌视图(`Embedded View`)

#### ViewContainerRef

用于表示一个视图容器，可添加一个或多个视图

通过 `ViewContainerRef` 实例，我们可以基于 `TemplateRef` 实例创建内嵌视图，并能指定内嵌视图的插入位置

也可以方便对视图容器中已有的视图进行管理，简而言之，`ViewContainerRef` 的主要作用是创建和管理内嵌视图或组件视图


#### ViewRef 与 EmbeddedViewRef 之间的关系

`ViewRef` 用于表示 `Angular View`(视图)，视图是可视化的 `UI` 界面

```js
// @angular/core/src/linker/view_ref.d.ts
export declare abstract class ViewRef {
  destroyed: boolean;
  abstract onDestroy(callback: Function): any;
}
```

`EmbeddedViewRef` 继承于 `ViewRef`，用于表示 `<template>` 模板元素中定义的 `UI` 元素

```js
// @angular/core/src/linker/view_ref.d.ts
export declare abstract class EmbeddedViewRef<C> extends ViewRef {
  context: C;
  rootNodes: any[]; // 保存 <template> 模板中定义的元素
  abstract destroy(): void; // 用于销毁视图
}
```


## 03. 注入服务的两种方式的区别

一个简单的服务

```js
// 需要在当前使用的模块的 module 文件中进行配置服务
import {MailService} from "./mail.service";

@NgModule({
  ...
  providers: [MailService],
  bootstrap: [AppComponent]
})
export class AppModule { }

// 然后书写服务的具体逻辑，更新服务
import { Injectable } from '@angular/core';

@Injectable()
export class MailService {
  message: string  ='该消息来自MailService';
  constructor() { }
}

// 最后进行注入后使用服务
import { Component } from '@angular/core';
import {MailService} from "./mail.service";

@Component({
  selector: 'app-root',
  template: `
    <h3>{{title}}</h3>
    <div>
      <app-simple-form></app-simple-form>
      {{mailService.message}}
    </div>
  `
})

export class AppComponent {
  title = 'Hello, Angular';
  constructor(private mailService: MailService) {}
}
```

服务的注入方式除了使用 constructor(private mailService: MailService) 方式注入服务外

我们也可以使用 Inject 装饰器来注入 MailService 服务：

```js
import { Component, Inject } from '@angular/core'
import { MailService } from "./mail.service";

@Component({...})

export class AppComponent {
  constructor(@Inject(MailService) private mailService) {}
}
```

两者的区别如下：

* 对于 Type 类型(函数类型) 的对象，我们一般使用 constructor(private mailService: MailService) 方式进行注入

* 而 Inject 装饰器一般用来注入非 Type 类型的对象，如下所示

```js
@NgModule({
  ...
  providers: [
    MailService,
    { provide: 'apiUrl', baseUrl: 'http://...'}
  ]
})
```

使用

```js
@Component({
  selector: 'app-root',
  template: `...`
})

export class AppComponent {
  constructor(
    @Inject(MailService) private mailService,
    @Inject('apiUrl') private apiUrl
  ) {}
}
```

## 04. *ngFor

*ngFor 中的 * 号是语法糖，表示结构指令，该语法最终会转换成：

```html
<ng-template ngFor let-item [ngForOf]="items" let-i="index">
  ...
</ng-template>
```


## 05. :host

:host 表示选择宿主元素，比如以下组件

```js
import {Component, OnInit, Input, Output, EventEmitter} from '@angular/core';

@Component({
  selector: 'app-simple-form',
  template: `...`,
  styles: [`
   :host { margin: 10px; }
   input:focus { font-weight: bold;}
  `
  ]
})
export class SimpleFormComponent implements OnInit {
  @Input() message: string;
  @Output() update = new EventEmitter<{text: string}>();
  ngOnInit() {}
}
```

表示的即为 `AppComponent` 组件模板中的 `app-simple-form` 元素


## 06. 引入第三方库

若是需要引入第三方 UI 库，比如 bootstrap，可以在 .angular-cli.json 文件中

配置对应的样式文件地址，然后重启项目即可

```js
{
  "apps": {
     "styles": [
         "styles.css",
         "../node_modules/bootstrap/dist/css/bootstrap.min.css"
      ]
  }
}
```