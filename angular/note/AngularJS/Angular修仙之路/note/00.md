
### 01. [hidden] 属性失效

模版如下

```html
<div [hidden]="!showGreeting">
  Hello, world!
</div>
```

上面的代码在通常情况下，都能正常工作

但当在对应的 `DOM` 元素上设置 `display: flex` 属性时，尽管 `[hidden]` 对应的表达式为 `true`，但元素却能正常显示

对于这种特殊情况，则推荐使用 `*ngIf`



### 02. 直接使用 el.nativeElement 获取元素存在的问题

如下代码

```js
@Component({
  selector: 'my-comp',
  template: `
    <input type="text" />
    <div> Some other content </div>
  `
})
export class MyComp {
  constructor(private el: ElementRef) {
    el.nativeElement.querySelector('input').focus();
  }
}
```

通常不推荐直接使用 `querySelector()` 获取页面中的元素

更好的方法是使用 `@ViewChild` 属性装饰器和模板变量

```js
@Component({
  selector: 'my-comp',
  template: `
    <input #myInput type="text" />
    <div> Some other content </div>
  `
})
export class MyComp implements AfterViewInit {
  @ViewChild('myInput') input: ElementRef;

  constructor(private renderer: Renderer) {}

  ngAfterViewInit() {
    this.renderer.invokeElementMethod(this.input.nativeElement, 'focus');
  }
}
```

另外，`@ViewChild()` 属性装饰器还支持设置返回对象的类型，使用方式如下

```js
// 若未设置 read 属性，则默认返回的是 ElementRef 对象实例
@ViewChild('myInput') myInput1: ElementRef;
@ViewChild('myInput', {read: ViewContainerRef}) myInput2: ViewContainerRef;
```


### 03. 自定义结构指令中的 TemplateRef 与 ViewContainerRef 的作用

#### TemplateRef

用于表示内嵌的 `template` 模板元素，通过 `TemplateRef` 实例，我们可以方便创建内嵌视图(`Embedded Views`)

```js
ngAfterViewInit() {
  let view = this.tpl.createEmbeddedView(null);
}
```

且可以轻松地访问到通过 `ElementRef` 封装后的 `nativeElement`

需要注意的是组件视图中的 `template` 模板元素，经过渲染后会被替换成 `comment` 元素

因为 `<template>` 模板元素，已经被 `Angular 2` 解析并封装成 `TemplateRef` 实例，通过 `TemplateRef` 实例，我们可以方便地创建内嵌视图(`Embedded View`)


#### ViewContainerRef

用于表示一个视图容器，可添加一个或多个视图

通过 `ViewContainerRef` 实例，我们可以基于 `TemplateRef` 实例创建内嵌视图，并能指定内嵌视图的插入位置

也可以方便对视图容器中已有的视图进行管理，简而言之，`ViewContainerRef` 的主要作用是创建和管理内嵌视图或组件视图


#### ViewRef 与 EmbeddedViewRef 之间的关系

`ViewRef` 用于表示 `Angular View`(视图)，视图是可视化的 `UI` 界面

```js
// @angular/core/src/linker/view_ref.d.ts
export declare abstract class ViewRef {
  destroyed: boolean;
  abstract onDestroy(callback: Function): any;
}
```

`EmbeddedViewRef` 继承于 `ViewRef`，用于表示 `<template>` 模板元素中定义的 `UI` 元素

```js
// @angular/core/src/linker/view_ref.d.ts
export declare abstract class EmbeddedViewRef<C> extends ViewRef {
  context: C;
  rootNodes: any[]; // 保存 <template> 模板中定义的元素
  abstract destroy(): void; // 用于销毁视图
}
```