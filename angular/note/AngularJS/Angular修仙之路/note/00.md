## 自定义属性指令中的 ElementRef 与 Renderer 的作用

为了能够支持跨平台，`Angular` 通过抽象层封装了不同平台的差异，统一了 `API` 接口

如定义了抽象类 `Renderer` 、抽象类 `RootRenderer` 等。此外还定义了以下引用类型：`ElementRef`、`TemplateRef`、`ViewRef`、`ComponentRef` 和 `ViewContainerRef` 等


#### ElementRef 的作用

在应用层直接操作 `DOM`，就会造成应用层与渲染层之间强耦合，导致我们的应用无法运行在不同环境（比如 `Web Workers`）

通过 `ElementRef` 我们就可以封装不同平台下视图层中的 `native` 元素，最后借助于 `Angular` 提供的强大的依赖注入特性，我们就可以轻松地访问到 `native` 元素


#### ElementRef 的定义

```js
export class ElementRef {
  public nativeElement: any;
  constructor(nativeElement: any) {
    this.nativeElement = nativeElement;
  }
}
```

#### Renderer2 常用方法

要注意的是在 `Angular 4.x+` 版本，我们使用 `Renderer2` 替代 `Renderer`

```js
export abstract class Renderer2 {
  abstract createElement(name: string, namespace?: string|null): any;
  abstract createComment(value: string): any;
  abstract createText(value: string): any;
  abstract setAttribute(el: any, name: string, value: string, namespace?: string|null): void;
  abstract removeAttribute(el: any, name: string, namespace?: string|null): void;
  abstract addClass(el: any, name: string): void;
  abstract removeClass(el: any, name: string): void;
  abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;
  abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;
  abstract setProperty(el: any, name: string, value: any): void;
  abstract setValue(node: any, value: string): void;
  abstract listen(target: 'window'|'document'|'body'|any, eventName: string, callback: (event: any) => boolean | void): () => void;
}
```
