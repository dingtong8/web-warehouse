
### 01. [hidden] 属性失效

模版如下

```html
<div [hidden]="!showGreeting">
  Hello, world!
</div>
```

上面的代码在通常情况下，都能正常工作

但当在对应的 `DOM` 元素上设置 `display: flex` 属性时，尽管 `[hidden]` 对应的表达式为 `true`，但元素却能正常显示

对于这种特殊情况，则推荐使用 `*ngIf`



### 02. 直接使用 el.nativeElement 获取元素存在的问题

如下代码

```js
@Component({
  selector: 'my-comp',
  template: `
    <input type="text" />
    <div> Some other content </div>
  `
})
export class MyComp {
  constructor(private el: ElementRef) {
    el.nativeElement.querySelector('input').focus();
  }
}
```

通常不推荐直接使用 `querySelector()` 获取页面中的元素

更好的方法是使用 `@ViewChild` 属性装饰器和模板变量

```js
@Component({
  selector: 'my-comp',
  template: `
    <input #myInput type="text" />
    <div> Some other content </div>
  `
})
export class MyComp implements AfterViewInit {
  @ViewChild('myInput') input: ElementRef;

  constructor(private renderer: Renderer) {}

  ngAfterViewInit() {
    this.renderer.invokeElementMethod(this.input.nativeElement, 'focus');
  }
}
```

另外，`@ViewChild()` 属性装饰器还支持设置返回对象的类型，使用方式如下

```js
// 若未设置 read 属性，则默认返回的是 ElementRef 对象实例
@ViewChild('myInput') myInput1: ElementRef;
@ViewChild('myInput', {read: ViewContainerRef}) myInput2: ViewContainerRef;
```