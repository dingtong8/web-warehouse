## 第1章 作用域是什么

储存和访问变量的值的能力将状态带给了程序

一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量，这套规则被称为作用域


## 作用域嵌套

当一个块或者函数嵌套在另一个块或函数中时，就发生了作用域的嵌套

因此，在当前作用域中无法找到某个变量的时候，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止

考虑以下代码：

```js
function foo(a) {
  console.log(a + b);
}

var b = 2;

foo(2)  //4
```

对 `b` 进行的 `RHS` 引用无法在函数 `foo` 内部完成，但可以在上一级作用域（该例中为全局作用域）中完成

遍历嵌套作用域链的规则很简单，引擎从当前的执行作用域开始查找变量，如果找不到，就像上一级继续查找，当抵达最外层的全局作用域的时候，无论找到还是没找到，查找过程都会停止

#### 小结

`JavaScript` 引擎会在代码执行前对其进行编译，在这个过程中，像 `var a = 2` 这样的声明会被分解成两个独立的步骤：

1）首先，`var a` 在其作用域中声明新变量，这会在最开始的阶段，也就是代码执行前进行

2）接下来，`a = 2` 会查询（`LHS` 查询）变量 `a` 并对其赋值

`LHS` 和 `RHS` 查询都会在当前执行作用域中开始，如果有需要（也就是说他们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都会停止

不成功的 `RHS` 引用会导致抛出 `ReferenceError` 异常，不成功的 `LHS` 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 `LHS` 引用的目标做为标识符，或者抛出 `ReferenceError` 异常（严格模式下）






## 第2章 词法作用域

作用域共有两种主要的工作模型

第一种是最为普遍，被大多数编程语言所采用的词法作用域

另外一种叫做动态作用域，仍有一些编程语言在使用（比如 `Bash` 脚本，`Perl` 中的一些模式等）


## 词法阶段

简单地说，词法作用域就是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将 变量 和 块作用域 写在 哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）


![img](1.png)

作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的




## 查找

作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名的标识符，这叫作"遮蔽效应"（内部的标识符"遮蔽"了外部的标识符）

抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止

全局变量会自动成为全局对象（比如浏览器中的 `window` 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问

```js
window.a
```

通过这种技术可以访问那些被同名变量所遮蔽的全局变量，但非全局的变量如果被遮蔽了，无论如何都无法被访问到

需要注意的是：无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定


#### 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的，编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找

`JavaScript` 中有两个机制可以"欺骗"词法作用域：`eval(..)` 和 `with`，前者可以对一段包含一个或多个声明的"代码"字符串进行演算，并借此来修改已经存在的词法作用域（在运行时），后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的，使用这其中任何一个机制都将导致代码运行变慢，不要使用它们




## 第3章 函数作用域和块作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用），这种设计方案是非常有用的，能充分利用 `JavaScript` 变量可以根据需要改变值类型的"动态"特性



## 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码，但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码"隐藏"起来了

实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中

它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则，这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都"隐藏"起来，比如某个模块或对象的 `API` 设计

例如：

```js
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething(2); // 15
```

在这个代码片段中，变量 `b` 和函数 `doSomethingElse(..)` 应该是 `doSomething(..)` 内部具体实现的"私有"内容

给予外部作用域对 `b` 和 `doSomethingElse(..)` 的"访问权限"不仅没有必要，而且可能是"危险"的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了 `doSomething(..)` 的适用条件

更'合理'的设计：

```js
function doSomething(a) {
  
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;

  b = a + doSomethingElse(a * 2);

  console.log(b * 3);

}

doSomething(2); // 15
```

现在，`b` 和 `doSomethingElse(..)` 都无法从外部被访问，而只能被 `doSomething(..)` 所控制，功能性和最终效果都没有受影响，但是设计上将具体内容私有化了




## 函数作用域

```js
var MyReallyCoolLibrary = {
    
  awesome: "stuff",
  
  doSomething: function () {
    // ...
  },
  
  doAnotherThing: function () {
    // ...
  }
    
};
```

首先，包装函数的声明以(`function...`而不仅是以 `function...` 开始，尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别，函数会被当作函数表达式而不是一个标准的函数声明来处理

区分函数声明和表达式最简单的方法是看 `function` 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置），如果 `function` 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处

`(function foo(){..})` 作为函数表达式意味着 `foo` 只能在 `..` 所代表的位置中被访问，外部作用域则不行，`foo` 变量名被隐藏在自身中意味着不会非必要地污染外部作用域



## 匿名和具名

对于函数表达式你最熟悉的场景可能就是回调参数了，比如：

```js
setTimeout(function () {
  console.log("I waited 1 second!");
}, 1000);
```

这叫作匿名函数表达式，因为 `function()..` 没有名称标识符，函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 `JavaScript` 的语法中这是非法的

但是它也有几个缺点需要考虑


1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 `arguments.callee` 引用，比如在递归中，另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身

3. 匿名函数省略了对于代码 可读性/可理解性 很重要的函数名，一个描述性的名称可以让代码不言自明



行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响，给函数表达式指定一个函数名可以有效解决以上问题，始终给函数表达式命名是一个最佳实践：

```js
setTimeout(function timeoutHandler() {   // <-- 快看，我有名字了！
  console.log("I waited 1 second!");
}, 1000); 
```





## 块作用域

尽管函数作用域是最常见的作用域单元，当然也是现行大多数JavaScript中最普遍的设计方法，但其他类型的作用域单元也是存在的

除 `JavaScript` 外的很多编程语言都支持块作用域

对下面这种很常见的 `JavaScript` 代码一定很熟悉：

```js
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

我们在 `for` 循环的头部直接定义了变量i，通常是因为只想在 `for` 循环内部的上下文中使用 `i`，而忽略了 `i` 会被绑定在外部作用域（函数或全局）中的事实，这就是块作用域的用处

另外一个例子：

```js
var foo = true;

if (foo) {
  var bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
```

`bar` 变量仅在 `if` 声明的上下文中使用，因此如果能将它声明在 `if` 块内部中会是一个很有意义的事情，但是当使用 `var` 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域

块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息




## let

`ES6` 改变了现状，引入了新的 `let` 关键字，提供了除 `var` 以外的另一种变量声明方式

`let` 关键字可以将变量绑定到所在的任意作用域中（通常是 `{..}` 内部），换句话说，`let` 为其声明的变量隐式地了所在的块作用域

```js
var foo = true;

if (foo) {
    
  let bar = foo * 2;
  bar = something(bar);
  console.log(bar);
    
}

console.log(bar); // ReferenceError
```

用 `let` 将变量附加在一个已经存在的块作用域上的行为是隐式的

通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码，显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：

```js
var foo = true;

if (foo) {
  { // <-- 显式的块
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
  }
}

console.log(bar); // ReferenceError
```

只要声明是有效的，在声明中的任意位置都可以使用 `{..}` 括号来为 `let` 创建一个用于绑定的块

使用 `let` 进行的声明不会在块作用域中进行提升，声明的代码被运行之前，声明并不"存在"

```js
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```


## 垃圾收集

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关，考虑以下代码：

```js
function process(data) {
  // some code here
}

var someReallyBigData = { ... };

process(someReallyBigData);

var btn = document.getElementById("my_button");

btn.addEventListener("click", function click(evt) {
  console.log("button clicked");
}, false)
```

`click` 函数的点击回调并不需要 `someReallyBigData` 变量

理论上这意味着当 `process(..)` 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了

但是，由于 `click` 函数形成了一个覆盖整个作用域的闭包，`JavaScript` 引擎极有可能依然保存着这个结构（取决于具体实现）

块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 `someReallyBigData` 了：

```js
function process(data) {
  // some code here
}

// 在这个块中定义的内容可以销毁了！
{
  let someReallyBigData = { ... };
  process(someReallyBigData);
}

var btn = document.getElementById("my_button");

btn.addEventListener("click", function click(evt) {
  console.log("button clicked");
}, false);
```

## let循环

一个 `let` 可以发挥优势的典型例子就是之前讨论的 `for` 循环

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}

console.log(i); // ReferenceError
```

`for` 循环头部的 `let` 不仅将 `i` 绑定到了 `for` 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值

下面通过另一种方式来说明每次迭代时进行重新绑定的行为：

```js
{
  let j;
  for (j = 0; j < 10; j++) {
    let i = j; // 每个迭代重新绑定！
    console.log(i);
  }
}
```

由于 `let` 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域），当代码中存在对于函数作用域中 `var` 声明的隐式依赖时，就会有很多隐藏的陷阱，如果用 `let` 来替代 `var` 则需要在代码重构的过程中付出额外的精力

考虑以下代码：

```js
var foo = true, baz = 10;

if (foo) {
    
  var bar = 3;
  
  if (baz > bar) {
    console.log(baz);
  }
  // ...
}
```

这段代码可以简单地被重构成下面的同等形式：

```js
var foo = true, baz = 10;

if (foo) {
  var bar = 3;
  // ...
}

if (baz > bar) {
  console.log(baz);
}
```

但是在使用块级作用域的变量时需要注意以下变化：

```js
var foo = true, baz = 10;

if (foo) {
    
  let bar = 3;
  
  if (baz > bar) { // <-- 移动代码时不要忘了 bar
    console.log(baz);
  }
    
}
```


## const

除了 `let` 以外，`ES6` 还引入了 `const`，同样可以用来创建块作用域变量，但其值是固定的（常量）

```js
var foo = true;

if (foo) {
  var a = 2;
  const b = 3; // 包含在if中的块作用域常量
  a = 3; // 正常
  b = 4; // 错误
}

console.log(a); // 3
console.log(b); // ReferenceError!
```


#### 小结

函数是 `JavaScript` 中最常见的作用域单元，本质上，声明在一个函数内部的变量或函数会在所处的作用域中'隐藏'起来，这是有意为之的良好软件的设计原则

但函数不是唯一的作用域单元，块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 `{..}` 内部）

从 `ES3` 开始，`try/catch` 结构在 `catch` 分句中具有块作用域

在 `ES6` 中引入了 `let` 关键字（`var` 关键字的表亲），用来在任意代码块中声明变量，`if (..) { let a = 2; }` 会声明一个劫持了 `if` 的 `{..}` 块的变量，并且将变量添加到这个块中

