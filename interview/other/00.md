## 缓存穿透和缓存雪崩

分布式缓存系统面临的问题

#### 缓存一致性问题

* 缓存系统与底层数据的一致性

  * 这点在底层系统是 "可读可写" 时，写得尤为重要 

* 有继承关系的缓存之间的一致性

  * 为了尽量提高缓存命中率，缓存也是分层的，分为全局缓存和二级缓存，他们是存在继承关系的，全局缓存可以有二级缓存来组成

* 多个缓存副本之间的一致性

  * 为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如 ```MemCache```，```Redis``` 等）

#### 缓存穿透和缓存雪崩

* **缓存穿透**

  * 一般的缓存系统，都是按照 ```key``` 去缓存查询，如果不存在对应的 ```value```，就应该去后端系统查找（比如 ```DB```），如果 ```key``` 对应的 ```value``` 是一定不存在的，并且对该 ```key``` 并发请求量很大，就会对后端系统造成很大的压力，这就叫做**缓存穿透**
 
* **如何避免**

  * 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 ```key``` 对应的数据 `insert` 了之后清理缓存

  * 对一定不存在的 ```key``` 进行过滤，可以把所有的可能存在的 ```key``` 放到一个大的 ```Bitmap``` 中，查询时通过该 ```Bitmap``` 过滤


* **缓存雪崩**


  * 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如 ```DB```）带来很大压力


* **如何避免**


* 在缓存失效后，通过**加锁**或者队列来控制读数据库写缓存的线程数量，比如对某个 ```key``` 只允许一个线程查询数据和写缓存，其他线程等待

* 不同的 ```key``` ，设置不同的过期时间，让缓存失效的时间点尽量均匀

* 做二级缓存，```A1``` 为原始缓存，```A2``` 为拷贝缓存，```A1``` 失效时，可以访问 ```A2```，```A1``` 缓存失效时间设置为短期，```A2``` 设置为长期（此点为补充）

 
#### 缓存数据的淘汰

策略有两种： 

* 定时去清理过期的缓存

* 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存

两者各有优劣，第一种的缺点是维护大量缓存的 ```key``` 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，可以根据自己的应用场景来权衡
 
* 预估失效时间 

* 版本号（必须单调递增，时间戳是最好的选择）

* 提供手动清理缓存的接口



## 进程与线程

对于操作系统来说，一个任务就是进程（`Process`），比如打开一个浏览器就是启动了一个浏览器进程，打开一个记事本就启动了一个记事本进程

有些进程还不止同时干一件事，比如 `Word`，它可以同时进行打字、拼写检查，打印等，在一个进程的内部，要同时干多件事，就需要同时运行多个 "子任务"，我们把进程内的这些 "子任务" 称为线程（`Thread`）

由于每个进程至少要干一件事，所以，一个进程至少有一个线程，当然也可以有多个，也可以多个线程同时执行

> 简单来说就是，线程是最小的执行单元，而进程由至少一个线程组成

#### 关系和共性

* 关系：进程中包含着至少一个线程

  * 在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程
  
  * 但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作，在整个进程完成工作之后，其中的线程会被销毁，释放资源

* 共性：都包含三个状态，就绪、阻塞、运行

  * 阻塞就是资源未到位，等待资源中
  
  * 就绪，就是资源到位了，但是 ```CPU``` 未到位，还在运行其他

#### 线程的好处

之所以设置线程这个单位

* 在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型

* 线程较进程来讲，更轻

* 线程虽然微观并行，但是在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞，提高了 ```CPU``` 的利用率



## JavaScript 中的单线程执行机制

#### 单线程和多线程

* 本质上指在**一个进程内**的单线程和多线程

* 单线程：单线程就是一个进程中只有一个线程，程序顺序执行，前面的执行完，才会执行后面的程序

* 多线程：多线程就是一个进程中只有多个线程，在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的

#### JavaScript 中的单线程执行机制

```JavaScript``` 的单线程本质上执行的是基于浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中，但是浏览器是**事件驱动**的、**异步**的、**多线程**的

浏览器内部有一个事件轮询（```event loop```），是一个大的内部消息循环，会轮询大的消息队列，并执行，也就是 ```JavaScript``` 要处理的事件队列，是浏览器维护的

浏览器至少有四个线程（不同浏览器会有差异）：```JavaScript``` 引擎线程、界面渲染线程、浏览器事件触发线程、```http``` 请求线程

#### setTimeout 和 ajax

* ```setTimeout```：```JavaScript``` 在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由 ```JavaScript``` 引擎执行，都是在浏览器空闲了才会执行

* ```ajax```：是真正的异步，在调用 ```ajax``` 的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中，再由 ```JavaScript``` 引擎执行


## JavaScript 中的阻塞

浏览器虽然是多线程，但是由于 ```JavaScript``` 具有阻塞特性（比如 ```alert```），无论外链还是内嵌脚本，在浏览器执行解释 ```JavaScript``` 脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到 ```JavaScript``` 下载并执行完毕

这样一来，```JavaScript``` 脚本的下载、解释执行，会反使页面的继续绘制，给用户带来不良的体验，所以避免此类情况的话可以

* 将 ```<script>``` 内嵌和外链，在可以的情况下，放在 ```<body>``` 底部（对于 ```css```，浏览器是并行下载）

* 在页面 ```onload``` 后，加载 ```JavaScript```

* 可以使用 ```html5``` 的  ```<script>```标签的```defer```属性，在页面加载完成后下载

* 使用创建 ```<script>``` 标签的方式，在页面加载完成后添加进去（createElement）

简单来说就是一句话，先让页面渲染完，再加载 ```JavaScript```

> ```Node.js``` 的运行机制是基于事件轮询 （```event loop```）



## 关于线程同步

线程同步是指多线程通过特定的东西（如互斥量）来控制线程之间的执行顺序（同步），也可以说是在线程之间通过同步建立起执行顺序的关系，如果没有同步那线程之间是各自运行各自的

#### 方式和机制

主要有临界区（```Critical Section```）、互斥量（```Mutex```）、信号量（```Semaphore```）、事件（```Event```）四种方式，区别如下：

* 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问，在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占

* 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问，互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享

* 信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

* 事件：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作


## 数据库中的事务和锁

#### 事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消，也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做

事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交，如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作

#### 事务的 ACID 

* A （```Atomicity```）  原子性

事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全都不执行

* C （```Consistency```） 一致性

事务在完成时，必须使所有的数据都保持一致状态，在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性，事务结束时，所有的内部数据结构（如 ```B``` 树索引或双向链表）都必须是正确的

* I （```Isolation```）   隔离性 

并发事务所做的修改必须与任何其他并发事务所做的修改隔离，事务识别数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是第二个事务修改它之后的状态，事务不会识别中间状态的数据

* D （```Durability```）  持久性

事务完成之后，它对于系统的影响是永久性的，该修改即使出现系统故障也将一直保持


#### 锁

在事务获取数据块当前状态的依赖关系（比如通过读取或修改数据）之前，它必须保护自己不受其他事务对同一数据进行修改的影响，事务通过请求锁定数据块来达到此目的，锁有多种模式，如共享或独占

锁模式定义了事务对数据所拥有的依赖关系级别，如果某个事务已获得特定数据的锁，则其他事务不能获得会与该锁模式发生冲突的锁，如果事务请求的锁模式与已授予同一数据的锁发生冲突，则数据库引擎实例将暂停事务请求直到第一个锁释放

引入锁的机制主要是用来处理多个用户同时对数据库的并发操作时会带来以下几种数据不一致的问题（四大冲突问题）

* 脏读

  * 某个事务读取的数据是另一个事务正在处理的数据，而另一个事务可能会回滚，造成第一个事务读取的数据是错误的

* 不可重复读

  * 在一个事务里两次读入数据，但另一个事务已经更改了第一个事务涉及到的数据，造成第一个事务读入旧数据

* 幻读

  * 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行，同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据，那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样

* 更新丢失

  * 多个事务同时读取某一数据，一个事务成功处理好了数据，被另一个事务写回原值，造成第一个事务更新丢失


#### 锁模式

* 共享锁

  * 共享锁（```S``` 锁）允许并发事务在封闭式并发控制下读取 （```SELECT```）资源，资源上存在共享锁（```S``` 锁）时，任何其他事务都不能修改数据，读取操作一完成，就立即释放资源上的共享锁（```S``` 锁），除非将事务隔离级别设置为可重复读或更高级别，或者在事务持续时间内用锁定提示保留共享锁（```S``` 锁）

* 更新锁（```U``` 锁）

  * 更新锁在共享锁和排他锁的杂交，更新锁意味着在做一个更新时，一个共享锁在扫描完成符合条件的数据后可能会转化成排他锁

  * 这里面有两个步骤：

    * 扫描获取 ```Where``` 条件时，这部分是一个更新查询，此时是一个更新锁

    * 如果将执行写入更新，此时该锁升级到排他锁，否则，该锁转变成共享锁

  * 更新锁可以防止常见的死锁

* 排他锁

  * 排他锁（```X``` 锁）可以防止并发事务对资源进行访问，排他锁不与其他任何锁兼容，使用排他锁（```X``` 锁）时，任何其他事务都无法修改数据，仅在使用 ```NOLOCK``` 提示或未提交读隔离级别时才会进行读取操作




## JavaScript 中的栈和堆

首先要先说一下耳熟能详的「堆栈」，要区分数据结构和内存中各自「堆栈」的含义

数据结构中的堆和栈是两种不同的、数据项按序排列的数据结构，这里主要介绍的是内存中的堆区与栈区

#### 内存中的堆区与栈区

在 `C` 语言中，各个区的区别如下

* 栈区是分配局部变量的空间

* 堆区是地址向上增长的用于分配我们申请的内存空间

* 另外还有静态区是分配静态变量、全局变量空间的

* 只读区是分配常量和程序代码空间的

一个简单的例子

```c#
int a = 0;                  // 全局初始化区
char *p1;                   // 全局未初始化区

main() {
  int b;                    // 栈
  char s[] = "abc";         // 栈
  char *p2;                 // 栈
  char *p3 = "123";         // 在常量区，p3 在栈上
  static int c =0；         // 全局（静态）初始化区
  p1 = (char *)malloc(10);  // 堆
  p2 = (char *)malloc(20);  // 堆
}
```

而 `JavaScript` 是高级语言，底层依靠 `C/C++` 来编译实现，其变量划分为基本数据类型和引用数据类型

基本数据类型包括 `Undefined`，`Null`，`Boolean`，`Number`、`String`

这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，通过按值访问、拷贝和比较

引用类型包括 `object`，`array`，`function`，`error`，`date`

这些类型大小不固定，栈内存中存放地址指向堆内存中的对象，是按引用访问的（和 `C` 语言的指针类似）

对于引用类型的变量，栈内存中存放的只是该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存在栈内存中

但是内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中

这样一来，当查询引用类型的变量的时候，就会先从栈中读取堆内存地址，然后在根据地址取出对应的值

显而易见的是，`JavaScript` 中所有引用类型创建实例的时候，都是显示或者隐式的 `new` 出对应类型的实例，实际上就是对应 `C` 语言的 `malloc` 分配内存函数


#### 栈和队列的区别

* 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的

* 队列先进先出，栈先进后出

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除


#### 栈和堆的区别

* 栈区（`stack`） -- 由编译器自动分配释放，存放函数的参数值，局部变量的值等

* 堆区（`heap`） -- 一般由程序员分配释放，若程序员不释放，程序结束时可能由 `OS` 回收

* 堆（数据结构）：堆可以被看成是一棵树，如：堆排序

* 栈（数据结构）：一种先进后出的数据结构







