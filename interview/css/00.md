






## 盒子模型

盒模型尺寸基准有两种，分别是默认的 ```content-box``` 和 ```border-box```

#### content-box

默认情况下我们代码中元素的是以 ```content-box``` 作为标准的盒子，如下图所示：

![content-box](盒子模型.png)

元素框的最内部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素

#### border-box

```content-box``` 和 ```border-box``` 的主要区别是二者的盒子的宽度是否包含元素的边框和内边距

若想把 ```div``` 设为 ```border-box``` 盒模型，我们需要为其添加 ```box-sizing: border-box``` 属性，这样才能作为 ```border-box``` 盒模型

当我们设置 ```box-sizing: content-box;``` 时，浏览器对盒模型的解释遵从我们之前认识到的 ```W3C``` 标准，当它定义 ```width``` 和 ```height``` 时，它的宽度不包括 ```border``` 和 ```padding```



----

----










## FC

一开始浅显的以为盒子模型就那么回事，了解了相关知识以后才发现水深不见底，这里也只浅显的了解一下 ```BFC```、```IFC```、```GFC``` 和 ```FFC``` 等的一些入门知识，想深入了解的可以见下面的规范，里面有详细的描述

```FC``` 的全称是：```Formatting Contexts```，是 [W3C CSS2.1 规范](https://www.w3.org/TR/CSS2/) 中的一个概念，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用

在深入展开 ```FC``` 相关知识前，我们先来了解一下盒模型

#### 盒子模型的结构

![盒子模型](http://images2015.cnblogs.com/blog/347002/201603/347002-20160317004252474-1628947975.png)

盒子模型其实就是由以下 4 个盒子组成：

* ```content box```：必备，由 ```content area``` 和 ```4``` 条 ```content/inner edge``` 组成

* ```padding box```：可选，由 ```padding``` 和 ```4``` 条 ```padding edge``` 组成，若 ```padding``` 宽度设置为 ```0```，则 ```padding edge``` 与 ```content edage``` 重叠

* ```border box```：可选，由 ```border``` 和 ```4``` 条 ```border edge``` 组成，若 ```border``` 宽度设置为 ```0```，则 ```border edge``` 与 ```padding edage``` 重叠

* ```margin box```：可选，由 ```margin``` 和 ```4``` 条 ```margin/outer edge``` 组成，若 ```margin``` 宽度设置为 ```0```，则 ```margin edge``` 与 ```border edage``` 重叠

一般所说的盒模型有两种情况，一个是标准盒子模型，另一种是怪异盒子模型（```IE``` 盒子模型），两者的区别就在于计算 ```width``` 和 ```height``` 的时候是否包含 ```padding/margin/border```

从上面可以看出，```margin```、```border```、```padding```、```content``` 分别定义了元素四种边，然后每种类型的边的四条边定义了一个盒子，分别是 ```content box```、```padding box```、```border box```、```margin box```，而决定块盒在包含块中与相邻块盒的垂直间距的便是 ```margin-box```，这个 ```margin-box``` 是始终存在的，即使它的 ```margin``` 为 ```0```

比如一个元素 ```<div></div>```，会生成一个块级的元素，同时元素也生成了一个块级盒子，如果不设置 ```div``` 的 ```margin``` 值，但是可以在浏览器生成的 ```computed style``` 中看到它的 ```margin``` 值仍然为 ```0``` 的

特别需要注意的是：当 ```<div></div>``` 标签被浏览器解析后会生成 ```div``` 元素并添加到 ```document tree``` 中，但 ```CSS``` 作用的对象并不是 ```document tree```，而是根据 ```document tree``` 生成的 ```render tree```，而盒子模型就是 ```render tree``` 的节点

* ```CSS``` 作用的是盒子（```box```）而不是元素（```element```）

* ```JS``` 无法直接操作盒子

```Box```（盒子模型）是 ```CSS``` 布局的对象和基本单位，直观点来说，就是一个页面是由很多个 ```Box``` 组成的

元素的类型和 ```display``` 属性，决定了这个 ```Box``` 的类型，不同类型的 ```Box```，会参与不同的 ```Formatting Context```（一个决定如何渲染文档的容器），因此 ```Box``` 内的元素会以不同的方式渲染

#### Formatting context

```Formatting context``` 是 ```W3C CSS2.1``` 规范（见开头部分）中的一个概念

它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用

最常见的 ```Formatting context``` 有 ```Block fomatting context```（```BFC```）和 ```Inline formatting context```（```IFC```）

```CSS2.1``` 中只有 ```BFC```（```Block Formatting Contexts```） 和 ```IFC```（```Inline Formatting Contexts```）（关于 ```BFC``` 与 ```IFC``` 内容见列表）, ```CSS3``` 中还增加了 ```GFC```（```GridLayout Formatting Contexts```） 和 ```FFC```（```Flex Formatting Contexts```）




## BFC

```BFC``` 直译为 "块级格式化上下文"，它是一个独立的渲染区域，只有 ```Block-level box``` 参与， 它规定了内部的 ```Block-level Box``` 如何布局，并且与这个区域外部毫不相干

块级元素会自动生成一个块级盒 ```block-level box```，这是块级盒 ```block-level-box``` 的盒模型构成，它表明的是块级盒自身的结构构成


#### BFC 的生成

既然 ```BFC``` 是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，而这些则由生成 ```BFC``` 的元素决定（即哪些元素会生成 ```BFC```）

* 根元素，即 ```HTML``` 元素

* ```float``` 属性不为 ```none```

* ```overflow``` 的值不为 ```visible```

* ```position``` 为 ```absolute``` 或 ```fixed```

* ```display``` 为 ```inline-block```, ```table-cell```, ```table-caption```, ```flex```, ```inline-flex```

  * 关于 ```display：table```，之所以可以生成 ```BFC```，主要原因在于 ```table``` 会默认生成一个匿名的 ```table-cell```，正是这个匿名的 ```table-cell``` 生成了 ```BFC```

#### BFC 布局规则

主要有下面几点：

* 普通流中的块元素（```Box```）独占一行，然后从上往下一个接一个的排布（垂直方向），相邻元素间会有外边距折叠（垂直方向的距离由 ```margin``` 决定，属于同一个 ```BFC``` 的两个相邻 ```Box``` 的 ```margin``` 会发生重叠）

* 每个元素的 ```margin box``` 的左边， 与包含块 ```border box``` 的左边相接触（对于从左往右的格式化，否则相反）（即使存在浮动也是如此）

* ```BFC``` 的区域不会与 ```float box``` 重叠

* ```BFC``` 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素（反之也如此）

* 计算 ```BFC``` 的高度时，浮动元素也参与计算


#### BFC 作用

有了上面这些规则，我们就可以来解决平常遇到过的一些问题


**两列布局**

先看下面代码

```html
<style>
body {
  width: 300px;
  position: relative;
}

.aside {
  width: 100px;
  height: 150px;
  float: left;
  background: #f66;
}

.main {
  height: 200px;
  background: #fcc;
}
</style>
<body>
  <div class="aside"></div>
  <div class="main"></div>
</body>
```

效果如下：

![bfc](http://p1.qhimg.com/d/inn/4055c62a/4dca44a927d4c1ffc30e3ae5f53a0b79.png?_=3674372)

根据规则可知，虽然存在浮动的元素 ```aslide```，但 ```main``` 的左边依然会与包含块的左边相接触

```BFC``` 不会与 ```float box``` 重叠，所以我们可以将 ```main``` 生成为 ```BFC``` 即可

```css
.main {
  overflow: hidden;
}
```

当触发 ```main``` 生成 ```BFC``` 后，这个新的 ```BFC``` 不会与浮动的 ```aside``` 重叠，这样就可以生成一个简单的两列布局

效果如下：

![bfc](http://p6.qhimg.com/t01077886a9706cb26b.png?_=3674372)


**高度坍塌**

这个也是一个比较常见的问题，即内部元素设置了浮动以后，外面包裹的容器，比如 ```div``` 的高度会发生坍塌，代码如下：

```html
<style>
.par {
  border: 5px solid #fcc;
  width: 300px;
}

.child {
  border: 5px solid #f66;
  width:100px;
  height: 100px;
  float: left;
}
</style>
<body>
  <div class="par">
    <div class="child"></div>
    <div class="child"></div>
  </div>
</body>
```

效果如下：

![bfc](http://p1.qhimg.com/t016035b58195e7909a.png?_=3674372)

发生这种情况的原因是因为内部的 ```child``` 元素使用了 ```float```，使其脱离了文档流，故父元素的高度自然就没有了

解决办法有很多，原理只需要将父元素触发为 ```BFC``` 即可

```css
.par {
  overflow: hidden;
}
```

效果如下：

![bfc](http://p2.qhimg.com/t016bbbe5236ef1ffd5.png?_=3674372)


**margin 重叠**

代码如下：

```html
<style>
p {
  color: #f55;
  background: #fcc;
  width: 200px;
  line-height: 100px;
  text-align:center;
  margin: 100px;
}
</style>
<body>
  <p>Haha</p>
  <p>Hehe</p>
</body>
```

效果如下：

![bfc](http://p5.qhimg.com/t01b47b8b7d153c07cc.png?_=3674372)

在控制台中审查元素可知，两个 ```p``` 之间的距离为 ```100px```，发生了 ```margin``` 重叠，根据规则可知，属于同一个 ```BFC``` 的两个相邻 ```Box``` 的 ```margin``` 会发生重叠

解决办法也很简单，我们可以给其中任意一个元素包裹一层容器，并触发该容器生成 ```BFC```，那么此时的两个子元素就不属于同一个 ```BFC```，所以就不会发生 ```margin``` 重叠的现象了

```html
<style>
.wrap {
  overflow: hidden;
}
p {
  color: #f55;
  background: #fcc;
  width: 200px;
  line-height: 100px;
  text-align:center;
  margin: 100px;
}
</style>
<body>
  <p>Haha</p>
  <div class="wrap">
    <p>Hehe</p>
  </div>
</body>
```

效果如下：

![bfc](http://p3.qhimg.com/t0118d1d2badbb00521.png?_=3674372)

通过以上几个例子可以看出，同规则一样，```BFC``` 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素（反之也如此）

因为 ```BFC``` 内部的元素和外部的元素绝对不会互相影响，因此当 ```BFC``` 外部存在浮动时，它不应该影响 ```BFC``` 内部 ```Box``` 的布局，```BFC``` 会通过变窄，而不与浮动有重叠

同样的，当 ```BFC``` 内部有浮动时，为了不影响外部元素的布局，```BFC``` 计算高度时会包括浮动的高度，同样，避免 ```margin``` 重叠也是这样的一个道理


参考：

[W3C CSS2.1 规范](https://www.w3.org/TR/CSS2/)

[什么是BFC](http://web.jobbole.com/84808/)

[BFC的理解](http://www.jianshu.com/p/76484dff1cb5)

[深入理解BFC](http://www.cnblogs.com/xiaohuochai/p/5248536.html)

   


## IFC

```IFC```（```Inline Formatting Context```），直译为 "行内格式化上下文"，与之相关的就是行盒模型，行盒模型是一个显示区域，根据块状容器内，每一行的多个内联元素（```inline-level element```）都会共同生成一个行盒模型

每个盒子都有一个 ```FC``` 特性，不同的 ```FC``` 值代表一组盒子不同的排列方式，有的 ```FC``` 值表示盒子从上到下垂直排列，有的 ```FC``` 值表示盒子从左到右水平排列等等

而 ```IFC``` 则是表示盒子从左到右的水平排列方式，仅此而已（注意：一个盒子仅且仅有一个 ```FC``` 值），而 ```inline-level box``` 的 ```FC``` 特性值固定为 ```IFC```

在 ```IFC``` 中，盒子水平放置，一个接着一个，从包含块的顶部开始，水平 ```margins```，```borders``` 和 ```padding``` 在这些盒子中被平分，这些盒子也许通过不同的方式进行对齐，他们的底部和顶部也许被对齐，或者通过文字的基线进行对齐，矩形区域包含着来自一行的盒子叫做 ```line box```

```line box``` 的宽度由浮动情况和它的包含块决定，**line box 的高度由 line-height 的计算结果决定**

一个 ```line box``` 总是足够高对于包含在它内的所有盒子，它也许比包含在它内最高的盒子高（比如，盒子对齐导致基线提高了）

当盒子 ```B``` 的高度比包含它的 ```line box``` 的高度低，在 ```line box``` 内的 ```B``` 的垂值对齐线通过 ``````"vertical align"`````` 属性决定，当几个行内级盒子在一个单独的 ``````line box`````` 内不能很好的水平放置，则他们被分配成了 ```2``` 个或者更多的垂直重叠的 ```line boxs```

因此，一个段落是很多个 ```line boxs``` 的垂直叠加，```line boxs``` 被叠加没有垂直方向上的分离（特殊情况除外），并且他们也不重叠

通常，```line box``` 的左边缘挨着它的包含块的左边缘，右边缘挨着它的包含块的右边缘，然而浮动盒子也许会在包含块边缘和 ```line box``` 边缘之间，因此尽管 ```line boxs``` 在同样的行内格式上下文中通常都有相同的宽度（就是他的包含块的宽度），但是水平方向上的空间因为浮动被减少了，它的宽度也会变得复杂，```line boxs``` 在同样的行内格式上下文中通常在高度上是多样的（比如，一行也许包含了一个最高的图片然后其他的也可以仅仅只包含文字）

注意一下几种情况：

* 当在一行中行内级盒子的总宽度比包含他们的 ```line box``` 的宽度小，他们的在 ```line box``` 中的水平放置位置由 ```"text align"``` 属性决定，如果属性是 ```"justify"```，用户代理可能会拉伸空间和文字在 ```inline boxs``` 内

* 当一个行内盒子超过了 ```line box``` 的宽度，则它被分割成几个盒子并且这些盒子被分配成几个横穿过的 ```line boxs```，如果一个行内盒子不能被分割，则行内盒子溢出 ```line box```

* 当一个行内盒子被分割，分割发生则 ```margins```，```borders``` 和 ```padding``` 便没有了视觉效果

* 在同样的 ```line box``` 内的行内盒子也许会被分割成几个盒子因为[双向的文字](https://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html#direction)

```line boxs``` 在行内格式上下文中档需要包含行内级内容时被创造，```line boxs``` 包含没有文字，没有空格，没有带着 ```margins```，```padding``` 和 ```borders```，以及没有其他在流中的内容（比如图片，行内盒子和行内表格），也不会以新起一行结尾，对于在他们内的任何盒子的位置都以他们决定并且必须将他们视作没有高度的 ```line boxs```

影响 ```IFC``` 内布局的 ```css``` 主要有以下几个：

* ```font-size```

* ```line-height```

* ```height```

* ```vertical-aligin```

#### font-size

一般用于指定文本类型节点的大小，```IFC``` 内的很多属性的值是基于这个的

#### line-height & height

在一个由多个内联元素组成的块状容器内，```"line-height"``` 为内联元素的行盒模型指定了一个最低高度，这个最低高度是分别由基线上的最小高度和基线下的最小深度组成

从上到下四条线分别是顶线、中线、基线、底线，那么行高是指上下文本行的基线间的垂直距离，即如下图所示中的两条红线间垂直距离（实际在数值上，行高也等于其它相同颜色间的距离）

![IFC](http://upload-images.jianshu.io/upload_images/1726248-ca8bc83d72d02759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### vertical-align

该属性影响由多个内联元素生成的盒模型组成的行内盒模型的垂直定位，```vertical``` 有几个特定的值，或者指定一个值

```html
<p class="a1">
  <span style="vertical-align:60px;">
  English中文
  </span>
  <span>
  中文English
  </span>
</p>
```

显示如下：

![IFC](http://upload-images.jianshu.io/upload_images/1726248-c751e43bebd6a8b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中，黄色线就是基线（```baseline```），绿线和黄线的间隔即为 ```60px```，这里会发现，容器（蓝色）的高度被撑高了

> 容器的高度 ```height = line-height + vertical-align```

当然同理，如果容器的高度被指定了，那么高度则不变，而超出的部分则不影响布局，如果设置 ```overflow: hidden```，则超过的部分则不可见

而 ```vertical-align``` 的其它特殊值，均可以看做一个根据容器高度而变化的相对值（比如可以设置百分比）


## GFC

```GFC``` 直译为 "网格布局格式化上下文"，当为一个元素设置 ```display``` 值为 ```grid``` 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（```grid container```）上定义网格定义行（```grid definition rows```）和网格定义列（```grid definition columns```）属性各在网格项目（```grid item```）上定义网格行（```grid row```）和网格列（```grid columns```）为每一个网格项目（```grid item```）定义位置和空间

```GFC``` 同 ```table``` 类似，同样是一个二维的表格，但 ```GridLayout``` 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制


## FFC

```FFC``` 直译为"自适应格式化上下文"，```display``` 值为 ```flex``` 或者 ```inline-flex``` 的元素将会生成自适应容器（```flex container```）

可惜这个属性只有谷歌和火狐支持，```Flex Box``` 由伸缩容器和伸缩项目组成，通过设置元素的 ```display``` 属性为 ```flex``` 或 ```inline-flex``` 可以得到一个伸缩容器

设置为 ```flex``` 的容器被渲染为一个块级元素，而设置为 ```inline-flex``` 的容器则渲染为一个行内元素

伸缩容器中的每一个子元素都是一个伸缩项目，伸缩项目可以是任意数量的，伸缩容器外和伸缩项目内的一切元素都不受影响，简单地说，```Flexbox``` 定义了伸缩容器内伸缩项目该如何布局


## haslayout

特别注意：```hasLayout``` 在 ```IE 8``` 及之后的 ```IE``` 版本中已经被抛弃，所以在实际开发中只需针对 ```IE 8``` 以下的浏览器为某些元素触发 ```hasLayout```

```Layout``` 是 ```IE``` 浏览器渲染引擎的一个内部组成部分，在 ```IE``` 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容，为了协调这两种方式的矛盾，渲染引擎采用了 ```"hasLayout"``` 属性，属性值可以为 ```true``` 或 ```false```

当一个元素的 ```"hasLayout"``` 属性值为 ```true``` 时，我们说这个元素有一个布局（```layout```），或拥有布局，可以通过 ```hasLayout``` 属性来判断一个元素是否拥有 ```layout```，如 ```object.currentStyle.hasLayout```

```hasLayout``` 与 ```BFC``` 有很多相似之处，但 ```hasLayout``` 的概念会更容易理解

在 ```Internet Explorer``` 中，元素使用 "布局" 概念来控制尺寸和定位，分为拥有布局和没有布局两种情况

* 拥有布局的元素由它控制本身及其子元素的尺寸和定位

* 而没有布局的元素则通过父元素（最近的拥有布局的祖先元素）来控制尺寸和定位

而一个元素是否拥有布局则由 ```hasLayout``` 属性告知浏览器，它是个布尔型变量，```true``` 代表元素拥有布局，```false``` 代表元素没有布局，简而言之，```hasLayout``` 只是一个 ```IE``` 下专有的属性，```hasLayout``` 为 ```true``` 的元素浏览器会赋予它一系列的效果


#### 怎样触发 layout

一个元素触发 ```hasLayout``` 会影响一个元素的尺寸和定位，这样会消耗更多的系统资源，因此 ```IE``` 设计者默认只为一部分的元素触发 ```hasLayout``` （即默认有部分元素会触发 ```hasLayout```，这与 ```BFC``` 基本完全由开发者通过特定 ```CSS``` 触发并不一样），这部分元素如下：

```html
<html>, <body>
<table>, <tr>, <th>, <td>
<img>
<hr>
<input>, <button>, <select>, <textarea>, <fieldset>, <legend>
<iframe>, <embed>, <object>, <applet>
<marquee>
```

除了 ```IE``` 默认会触发 ```hasLayout``` 的元素外，```Web``` 开发者还可以使用特定的 ```CSS``` 触发元素的 ```hasLayout```

通过为元素设置以下任一 ```CSS``` ，可以触发 ```hasLayout``` （即把元素的 ```hasLayout``` 属性设置为 ```true```）

```css
display: inline-block

height: (除 auto 外任何值)

width: (除 auto 外任何值)

float: (left 或 right)

position: absolute

writing-mode: tb-rl

zoom: (除 normal 外任意值)

min-height: (任意值)

min-width: (任意值)

max-height: (除 none 外任意值)

max-width: (除 none 外任意值)

overflow: (除 visible 外任意值，仅用于块级元素)

overflow-x: (除 visible 外任意值，仅用于块级元素)

overflow-y: (除 visible 外任意值，仅用于块级元素)

position: fixed
```

对于内联元素（可以是默认被浏览器认为是内联元素的 ```span``` 元素，也可以是设置了 ```display: inline``` 的元素），```width``` 和 ```height``` 只在 ```IE5.x``` 下和 ```IE6``` 或更新版本的 ```quirks``` 模式下能触发元素的 ```hasLayout```，但是对于 ```IE6```，如果浏览器运行于标准兼容模式下，内联元素会忽略 ```width``` 或 ```height``` 属性，所以设置 ```width``` 或 ```height``` 不能在此种情况下令该元素触发 ```hasLayout```

但 ```zoom``` 除了在 ```IE 5.0``` 中外，总是能触发 ```hasLayout```，```zoom``` 用于设置或检索元素的缩放比例，为元素设置 ```zoom: 1``` 既可以触发元素的 ```hasLayout``` 同时不会对元素造成多余的影响，因此综合考虑浏览器之间的兼容和对元素的影响， 建议使用 ```zoom: 1``` 来触发元素的 ```hasLayout``` 


#### 解决的问题

```hasLayout``` 表现出来的特性跟 ```BFC``` 很相似，所以可以认为是 ```IE``` 中的 ```BFC```，规则几乎都遵循，所以在之前 ```BFC``` 当作遇到的问题在IE里都可以通过触发 ```hasLayout``` 来解决

虽然 ```hasLayout``` 也会像 ```BFC``` 那样影响着元素的尺寸和定位，但它却又不是一套完整的标准，并且由于它默认只为某些元素触发，这导致了 ```IE``` 下很多前端开发的 ```bugs```

触发 ```hasLayout``` 更大的意义在于解决一些 ```IE``` 下的 ```bugs```，而不是利用它的一些 "副作用" 来达到某些效果，另外由于触发 ```hasLayout``` 的元素会出现一些跟触发 ```BFC``` 的元素相似的效果，因此为了统一元素在 ```IE``` 与支持 ```BFC``` 的浏览器下的表现，建议为触发了 ```BFC``` 的元素同时触发 ```hasLayout``` ，当然还需要考虑实际的情况，也有可能只需触发其中一个就可以达到表现统一




## vertical-align

```vertical-align``` 用来设置垂直对齐方式，所有垂直对齐的元素都会影响行高

它的取值方式有很多种

> 注意：IE7-浏览器中 ```vertical-align``` 的百分比值不支持小数行高，且取 ```baseline```、```middle```、```text-bottom``` 等值时与标准浏览器在展示效果不一样，常用的解决办法是将行内元素设置 ```display: inline-block```

```js
baseline        // 元素的基线与父元素的基线对齐

sub             // 降低元素的基线到父元素合适的下标位置

super           // 升高元素的基线到父元素合适的上标位置

bottom          // 把对齐的子元素的底端与行框底端对齐

text-bottom     // 把元素的底端与父元素内容区域的底端对齐

top             // 把对齐的子元素的顶端与行框顶端对齐

text-top        // 把元素的顶端与父元素内容区域的顶端对齐

middle          // 元素的中垂点与父元素的基线加 1/2 父元素中字母X的高度对齐

px              // 元素相对于基线 上/下 偏移 px

x%              // 相对于元素的 line-height 值

inherit         // 从父元素继承属性的值
```

综合一些常用情况，简单来说就是：

* 对齐操作必定涉及操作元素和参考系元素，而 ```vertical-align``` 的值全是指参考系元素的位置，而操作元素则以 ```baseline``` 或 ```linebox``` 上中下作对齐

* 默认对齐方式为 ```baseline```，数量值均是相对于 ```baseline``` 而言

* 仅对 ```inline-level``` 和 ```table-cell``` 元素有效（详细见 [IFC](https://github.com/heptaluan/blog/blob/master/interview/css/2019/IFC.md)）

有的时候会遇到 ```inline-block``` 底部会有空隙的问题

```inline-block``` 元素在块级元素中留空隙就是因为图像的默认垂直对齐方式是**基线**对齐（基线对齐在原理上图像底边与匿名文本大写英文字母X的底边对齐）

而匿名文本是有行高的，所以```X```的底边距离行框有一段距离，这段距离就是图像留出的空隙

常用的解决办法

* ```display: block```，因为垂直对齐方式只能作用于替换元素和行内元素，更改为块级元素，会使垂直对齐方式失效

* 设置父级的 ```line-height: 0```，这样使匿名文本与行框的距离为 ```0```

* 使用 ```vertical-align: top/middle/bottom```





## float，display，position

#### 误解

```float``` 的常见用法一般用来横向排版或者多列布局（```bootstrap``` 中的栅格系统也是通过 ```float``` 来实现的），并且在 ```CSS3``` 并未普及前，多列布局的解决方案一般也是通过 ```float``` 来实现的

但是 ```float``` 被设计出来的初衷只是仅仅用于来实现文字环绕图片的效果

#### 坍塌现象

比如在一个 ```div``` 元素中 放置了一个设置了 ```float``` 属性的图片，这样一来会导致 ```div``` 的**高度坍塌**，根本原因在于 设置 ```float``` 的元素会脱离文档流（至于为什么会这样，详细可见 BFC 一节）

另外要提到的一点就是，如果普通的 ```div``` 没有设置宽度，那么它的默认宽度则会充满整个屏幕，但是如果给 ```div``` 设置了 ```float``` 属性行，它的宽度就不再是占据整个屏幕，而是其宽度会自动调整为包裹住里面内容的宽度

此时虽然 ```div``` 体现了包裹性，但是它的 ```display``` 样式是没有变化的，仍然是 ```block```

#### 清除 float

想要解决上面出现的坍塌问题也很简单，一般常见的有下面几种

* 为父元素添加 ```overflow: hidden```

* 或者父元素也设置为浮动

* 再或者设置 ```clear: both```

#### display

```display``` 的属性有很多，这里主要说的是 ```inline```

#### inline

网页的所有元素，除了块就是流，而且流都是包含在块里面的（最外层的 ```body``` 就是一个块）

常用的 ```inline``` 就是文字和图片，它是没有大小和形状的，它的宽度取决于父容器的宽度

针对 ```inline``` 的标签，你设置宽度和高度是无效的，该元素实际的宽度和高度都是 ```auto```，并不是我们设定的值

将 ```inline``` 元素转化为块级元素常见的方式有 ```display: block```，```display: table``` 等等，这里提两种不是很常见的

* 一种是对 ```inline``` 元素设置 ```float```

* 另一种就是对 ```inline``` 元素设置 ```position: absolute/fixed```

#### 关于 IE7 下 不支持给块级元素设置 inline-block 样式

解决方法如下：首先将其变成行内元素，使用具有行内元素的特性，然后触发 haslayout，使其具有块级元素的特性，如此就可以模拟出 inline-block 的效果

```css
div{
  display:inline-block;
  *display: inline;
  zoom: 1;
}
```

#### position

```position``` 常用的属性一般有四个 ```static/relative/absolute/fixed```

另外 ```CSS3``` 又提供了三个新的属性，分别为 ```center/page/sticky```，虽然实现的效果很好，但是兼容性不是很好（```IE11``` 暂时都不支持），所以一般很少去使用

#### static 和 fixed

其中 ```static```（静态定位）是默认值，即所有的元素如果不设置其他的 ```position``` 值，它的 ```position``` 值就是 ```static```

```fixed``` 其实和 ```absolute``` 一样，唯一区别在于 ```fixed``` 永远根据浏览器来确定位置，和其他元素没有关系


#### relative

```relative``` 会导致自身位置的相对变化，而不会影响其他元素的位置、大小的变化，这是 ```relative``` 的要点之一

另外，```relative``` 还会产生一个新的定位上下文

```relative``` 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素

#### absolute

```absolute``` 元素脱离了文档结构，和 ```relative``` 不同，只要元素会脱离文档结构，它就会产生破坏性，导致父元素坍塌

同时 ```absolute``` 元素也具有 包裹性 和 跟随性，而且 ```absolute``` 元素会悬浮在页面上方，会遮挡住下方的页面内容，也会使得元素已有的 ```float``` 失效（不过 ```absolute``` 和 ```float``` 一起使用的场景不太常见）

一般通过给 ```absolute``` 元素设置 ```top```、```left``` 值来控制其所在的位置，但是它所依据定位的基准点与 ```fixed``` 不同

它的纵向和横向的偏移量主要依靠：浏览器递归查找该元素的所有父元素，如果找到一个设置了 ```position: relative/absolute/fixed``` 的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位


## line-height

```line-height```，一般也称为行高，指的是相邻文本行基线间的距离，至于什么是基线，可以参考下图

![IFC](http://upload-images.jianshu.io/upload_images/1726248-ca8bc83d72d02759.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上到下四条线分别是顶线、中线、基线、底线，那么行高是指上下文本行的基线间的垂直距离，即如上图所示中的两条红线间垂直距离（实际在数值上，行高也等于其它相同颜色间的距离）

行高 ```line-height``` 实际上只影响行内元素和其他行内内容，而不会直接影响块级元素，也可以为一个块级元素设置 ```line-height```，但这个值只是应用到块级元素的内联内容时才会有影响，在块级元素上声明 ```line-height``` 会为该块级元素的内容设置一个最小行框高度

#### 常用术语

如下图所示：

![line-height](http://images2015.cnblogs.com/blog/740839/201602/740839-20160219175645722-1098817036.jpg)

#### 内容区

对于行内非替换元素或匿名文本某一部分，```font-size``` 和 ```font-family``` 确定了内容区的高度，在宋体情况下，如果一个行内元素的 ```font-size``` 为 ```15px```，则内容区的高度为 ```15px```，而在其他字体情况下，内容区的高度并不等于字体大小

![line-height](http://images2015.cnblogs.com/blog/740839/201602/740839-20160219151914238-1621336937.jpg)


#### 行内框

内容区加上行间距等于行内框，如果一个行内非替换元素的 ```font-size``` 为 ```15px```，```line-height``` 为 ```21px```，则相差 ```6px```

用户代理将这 ```6``` 像素一分为二，将其一半分别应用到内容区的顶部和底部，这就得到了行内框

![line-height](http://images2015.cnblogs.com/blog/740839/201602/740839-20160219152043831-1132174404.jpg)

当 ```line-height``` 小于 ```font-size``` 时，行内框实际上小于内容区

![line-height](http://images2015.cnblogs.com/blog/740839/201602/740839-20160219153607784-951513878.jpg)



#### 行框

行框定义为行中最高行内框的顶端到最低行内框底端之间的距离，而且各行框的顶端挨着上一行行框的底端

![line-height](http://images2015.cnblogs.com/blog/740839/201602/740839-20160219153943722-241079730.jpg)



#### 框属性

* 内边距、外边距和边框不影响行框的高度，即不影响行高

* 行内元素的边框边界由 ```font-size``` 而不是 ```line-height``` 控制

* 外边距不会应用到行内非替换元素的顶端和底端

* ```margin-left```、```padding-left```、```border-left``` 应用到元素的开始处，而 ```margin-right```、```padding-right```、```border-right``` 应用到元素的结尾处


#### 替换元素

行内替换元素需要使用 ```line-height``` 值，从而在垂直对齐时能正确地定位元素，因为 ```vertical-align``` 的百分数值是相对于元素的 ```line-height``` 来计算的，对于垂直对齐来说，图像本身的高度无关紧要，关键是 ```line-height``` 的值

默认地，行内替换元素位于基线上，如果向替换元素增加下内边距、外边距或边框，内容区会上移

替换元素的基线是正常流中最后一个行框的基线，除非该替换元素内容为空或者本身的 ```overflow``` 属性值不是 ```visible```，这种情况下基线是 ```margin``` 底边缘


#### 150% 与 1.5 的区别

主要区别如下：

* 父元素设置 ```line-height: 1.5``` 会直接继承给子元素，子元素根据自己的 ```font-size``` 再去计算子元素自己的 ```line-height```（**实际行高 = 1.5 * 子元素的 font-size**）

* 父元素设置 ```line-height: 150%``` 是计算好了 ```line-height``` 值，然后把这个计算值给子元素继承，子元素继承拿到的就是最终的值了（此时子元素设置 font-size 对其 ```line-height``` 是无影响的）

#### ```line-height``` 与图片的表现

```inline``` 水平元素 ```vertical-align``` 默认**基线**对齐

比如图片和文字在一排排列，这个时候如果字体的 ```line-height``` 过大，而图片又是根据文字的基线来排列的，这个时候图片底部便会出现间距

#### 消除图片底部间距

一种就是将图片块状化，这时就无基线对齐，因为 ```vertical-align``` 属性只对**内联**，**内联块状**元素有效

另一种就是使用 ```vertical-align：bottom``` 来将图片的底线对齐，或者减小行高（这时基线的位置会上移）





## 样式来源与层叠规则

#### 层叠

```css``` 即所谓的层叠样式表，就是浏览器对多个样式来源进行叠加，最终确定结果的过程

#### 样式来源

之所有有层叠的概念，是因为有多个样式来源，具体为下面五种：

* ```<s style=''>``` 属性样式

* ```<style>``` 内部样式

* ```<link>``` 引用样式

* 浏览器用户自定义样式

* 浏览器默认样式

上面三个可以利用程序来控制（比如 ```css``` 文件，行内样式等，就不所说了），后面两个则是浏览器的行为

#### 浏览器默认样式

浏览器自带一个默认的样式，如果 ```html``` 中没有为标签设置样式，则浏览器会按照自己的样式来显示，但是浏览器默认样式的级别是最低的，一旦有其他地方设置了标签样式，浏览器默认样式就会被冲掉

不过各个浏览器的默认样式有些地方不一样，所以我们在编写 ```css``` 的时候都会为了统一而指定相应的样式（例如 ```* {margin: 0; padding: 0}```）

#### 浏览器用户自定义样式

指的一些浏览器自带功能，比如字体的放大缩小，用户在这里设置了字体和字号以后，它们会覆盖掉浏览器默认的样式


#### 层叠的规则

由于样式的来源不同，浏览器在加载样式时，需要计算出最终的样式值，这里的规则就是：浏览器会让**后面的样式覆盖前面的样式**（行内的话同样适用）

但是有一个特殊的情况：**!important**，它可以忽略掉上面的规则

#### 浏览器默认样式

下面是代码：

```css
html, address, blockquote, body, dd, div, dl, dt, 
fieldset, form, frame, frameset, h1, h2, h3, h4, 
h5, h6, noframes, ol, p, ul,center, dir, hr, menu, 
pre{ display: block} 
/* 以上按照 block 显示，没有规定的则按照默认的 inline 显示 */

li { display: list-item} 


head { display: none} 
table { display: table } 


tr { display: table-row} 
thead { display: table-header-group} 
tbody { display: table-row-group} 
tfoot { display: table-footer-group} 
col { display: table-column} 
colgroup { display: table-column-group} 
td, th { display: table-cell; } 


caption{ display: table-caption} 
th { font-weight: bolder; text-align: center} 


caption{ text-align: center} 
body { margin: 8px; line-height: 1.12} 


h1{ font-size: 2em; margin: .67em 0} 
h2{ font-size:1.5em; margin: .75em 0} 
h3{ font-size: 1.17em; margin: .83em 0} 
h4, p, 
blockquote, ul, 
fieldset, form, 
ol, dl, dir, 
menu { margin:1.12em 0} 

/* 加粗 */
h5{ font-size: .83em; margin: 1.5em 0} 
h6{ font-size: .75em; margin: 1.67em 0} 
h1, h2, h3, h4, 
h5, h6, b, 
strong { font-weight: bolder} 

/* 斜体 */
blockquote { margin-left: 40px; margin-right: 40px} 
i, cite, em, 
var, address { font-style: italic} 


pre, tt, code, 
kbd, samp { font-family: monospace} 
pre{ white-space: pre} 
button, textarea, 
input, object, 
select { display:inline-block; } 


big { font-size: 1.17em} 
small, sub, sup { font-size: .83em} 
sub{ vertical-align:sub} 
sup { vertical-align: super} 
table { border-spacing: 2px; } 
thead, tbody, 
tfoot { vertical-align: middle} 
td, th { vertical-align: inherit } 
s, strike, del { text-decoration: line-through} 
hr {border: 1px inset} 
/* 可以看到 hr 的默认样式 */

ol, ul, dir, 
menu, dd { margin-left: 40px} 
ol {list-style-type: decimal} 
/* 这就是为什么 ul 和 ol 在默认情况下左边会有一些间距*/

ol ul, ul ol, 
ul ul, ol ol { margin-top: 0;margin-bottom: 0} 
u, ins { text-decoration: underline} 
br:before {content: "\A"} 
:before, :after { white-space: pre-line } 
/* br 换行的原因 */

center{text-align: center} 
abbr, acronym { font-variant: small-caps; letter-spacing: 0.1em} 
:link, :visited { text-decoration: underline} 
:focus {outline: thindottedinvert} 


BDO[DIR="ltr"] { direction: ltr; unicode-bidi: bidi-override} 
BDO[DIR="rtl"] { direction: rtl; unicode-bidi: bidi-override} 

*[DIR="ltr"] { direction: ltr; unicode-bidi: embed} 
*[DIR="rtl"] { direction:rtl; unicode-bidi: embed} 
/* 控制文本方向，一般不会用到 */

@media print{ 
h1{ page-break-before:always} 
h1, h2, h3, 
h4, h5, h6{ page-break-after: avoid} 
ul, ol, dl { page-break-before: avoid}
/* 打印页面时的设置，一般不会用到 */
```

浏览器加载了 ```html``` 之后只为一件东西 -- ```dom``` 树，浏览器把 ```html``` 变为 ```dom``` 树结构，就完成了对 ```html``` 的结构化，至于后来对视图的渲染，就是整合了 ```css``` 之后的事情（包含了浏览器默认样式，浏览器整合 ```css``` 又是另一个路线，和解析 ```html``` 是分开的）



## 浏览器默认样式

#### block 元素

```css
html, address, blockquote, body, dd, div, dl, dt, 
fieldset, form, frame, frameset, h1, h2, h3, h4, 
h5, h6, noframes, ol, p, ul,center, dir, hr, menu, 
pre{ display: block} 
```

浏览器默认样式天生规定了 ```div``` 等一些元素为 ```block```，而不是 ```div``` 天生就是 ```block```

简单来说，是默认样式规定的，而不是浏览器内核规定的

没有设置 ```block``` 的元素，默认显式为 ```inline``` 显式


#### display: list-item

```css
li { display: list-item} 
```

```display: list-item``` 会为元素内容生成一个块型盒，随后再生成一个列表型的行内盒

其效果就和 ```ul``` 中出现项目列表符号一样，通俗地说就是会在内容前面自动加上黑点，例如

```css
<span style="display:list-item;list-style:square;list-style-position:inside;">1</span>
<span style="display:list-item;list-style:square;list-style-position:inside;">2</span>
<span style="display:list-item;list-style:square;list-style-position:inside;">3</span>
<span style="display:list-item;list-style:square;list-style-position:inside;">4</span>
```

#### list-style 和 list-style-type 属性

```list-style``` 列表中的列表项目标记设定为自定义的图片

而 ```list-style-type``` 可以来设置为不同的列表样式（自带），例如：

```html
ul.a  {list-style-type:circle}
ul.b {list-style-type:square}
ol.a {list-style-type:upper-roman}
ol.b {list-style-type:lower-alpha}
```

#### diplay: table

```css
table { display: table } 
```

设置该属性的元素会作为块级表格来显示（类似 ```<table>```），表格前后带有换行符

与 ```diplay: block``` 最主要的区别就是，```block``` 的元素会作为块级元素独占一行，而设置 ```table``` 的元素则会根据内容的宽度自适应的包含，即所谓的包裹性

#### display: table-cell

```css
td, th { display: table-cell; } 
```

这个属性主要用来多列布局，类似 ```bootstrap``` 中的栅格系统，比如：

```html
<div style="display: table-cell; width: 20%">
    111111111111
</div>
<div style="display: table-cell;">
    2222222222222
</div>
<div style="display: table-cell; width: 30%">
    33333333333
</div>
```

#### 其他

剩余的一些都是比较常见的属性，或者几乎不会用到的属性，比如打印设置，字体的书写顺序（默认的就是从左到右）

通过其他一些设置可以看出，浏览器会默认的设置一些间距（```margin```，```padding```），字体大小，粗/斜 体等，因为各个浏览器的解析效果可能不一致，所以在开发的时候，我们都会为其统一设置一个值，以来覆盖掉浏览器的默认样式




## 选择器的优先级

之前提到过，最后申明的样式会覆盖掉前面的样式，例如下面这两种，即相同选择器在层叠时，后加载的覆盖前加载的

```html
<div style="color:red;color:blue"></div>

p {
  color: red;
  color: blue;
}
```

这里就涉及到了一个选择器优先级的概念

#### 特指度（I-C-E）

特指度表示一个 ```css``` 选择器表达式的重要程度，通常称为 "I-C-E" 计算公式，其中的 ```I``` 对应着 ```id```，```C``` 对应着 ```class```，```E``` 对应着 ```element```

在针对一个 ```css``` 选择器表达式的时候，遇到一个 ```id``` 就往特指度数值中加 ```100```，遇到一个 ```class``` 就往特指度数值中加 ```10```，遇到一个 ```element``` 就往特指度数值中加 ```1```

下面是几个简单的例子：

```js
div        // 1

div#box    // 101

div p#box  // 102
```

优先级如下

首先声明：```!important``` 优先级是最高的，而 ```*``` 选择器最低，排除这两点以外：

* 最高的优先级： 直接在标签中的设置样式，例如 ```<div style="color:red;"></div>```

* 次优先级： ```id``` 选择器，例如 ```#box { .. }```

* 其次的是类选择器，例如 ```.box { .. }```

* 最后的就是标签选择器，例如 ```div { .. }```

简单总结的话，三句话：

* ```id``` 选择器高于 ```class``` 选择器

* 不同选择器的特指度比较时，不区分加载的顺序（而相同选择器在层叠时，后加载的覆盖前加载的）

* 设置的样式高于继承的样式，不用考虑特指度



## Bootstrap 中的栅格系统


#### 栅格系统的容器

为了寄予栅格系统合适的排列和 ```padding```，要把每一行 ```"row"``` 包含在一个容器中，而这个容器我们用 ```class``` 名为 ```"container"``` 或者 ```"container-fluid"```，这两个 ```class``` 是 ```Bootstrap``` 事先为我们设计好的，```.container``` 是固定宽度，居中显示

```html
<div class="container-fluid">
  <div class="row">
    ...
  </div>
</div>
```


#### 合适的栅格系统

每一个 ```"row"``` 代表一行，而内部的 ```"col-md-*"``` 代表一个单元格，```Bootstrap``` 把每一行分成 ```12``` 等份，```"col-md-*" ```中的 ```"*"``` 表示从 ```1 - 12``` 中取，```"*"``` 等于几，就占几份

合理的选择单元格的数字配置，再往单元格中添加我们想要的内容，这样一个栅格系统就完成了

比如：

```html
<div class="row">

  <div class="col-md-4">.col-md-4</div>

  <div class="col-md-4">.col-md-4</div>

  <div class="col-md-4">.col-md-4</div>

</div>

<div class="row">

  <div class="col-md-6">.col-md-6</div>

  <div class="col-md-6">.col-md-6</div>

</div>

<div class="row">

  <div class="col-md-3">.col-md-3</div>

  <div class="col-md-3">.col-md-3</div>

  <div class="col-md-3">.col-md-3</div>

  <div class="col-md-3">.col-md-3</div>

</div>
```


#### 单元格分类

一共有四种：
　　　　
* ```.c0l-xs-```　　无论屏幕宽度如何，单元格都在一行，宽度按照百分比设置，试用于手机

* ```.col-sm-```　　屏幕大于 ```768px``` 时，单元格在一行显示，屏幕小于 ```768px``` 时，独占一行，试用于平板

* ```.col-md-```　　屏幕大于 ```992px``` 时，单元格在一行显示，屏幕小于 ```992px``` 时，独占一行，试用于桌面显示器

* ```.col-lg-```　　屏幕大于 ```1200px``` 时，单元格在一行显示，屏幕小于 ```1200px``` 时，独占一行，适用于大型桌面显示器

以上的情况可以通过下面的代码清晰的理解：

```html
<div class="container">

  <div class="row">

    <div class="col-xs-12 col-sm-6 col-md-8">.col-xs-12 .col-sm-6 .col-md-8</div>

    <div class="col-xs-6 col-md-4">.col-xs-6 .col-md-4</div>

  </div>

  <div class="row">

    <div class="col-xs-6 col-sm-4">.col-xs-6 .col-sm-4</div>

    <div class="col-xs-6 col-sm-4">.col-xs-6 .col-sm-4</div>

    <div class="col-xs-6 col-sm-4">.col-xs-6 .col-sm-4</div>

  </div>

</div>
```

![栅格](https://github.com/heptaluan/blog/blob/master/面试/css/栅格.jpg)




----

----



## 响应式布局

总的来说分为以下几点：

#### Meta 标签定义

一般会使用如下的标签

大致意思为：设置屏幕宽度为手机的屏幕分辨率，页面缩放值为 ```1:1```，不允许用户进行缩放

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

移动设备上的 ```viewport``` 就是设备的屏幕上能用来显示我们的网页的那一块区域，移动设备上的浏览器都会把自己默认的 ```viewport``` 设为 ```980px``` 或 ```1024px```（也可能是其它值，这个是由设备自己决定的）

![viewport](http://images.cnitblog.com/blog/130623/201407/300958470402077.png)

这个时候，我们就需要利用 ```meta``` 标签对 ```viewport``` 进行控制

各个属性值如下：

```js
width	           // 设置 layout viewport  的宽度，为一个正整数，或字符串 "width-device"（手机的屏幕分辨率）

initial-scale	   // 设置页面的初始缩放值，为一个数字，可以带小数

minimum-scale	   // 允许用户的最小缩放值，为一个数字，可以带小数

maximum-scale	   // 允许用户的最大缩放值，为一个数字，可以带小数

height	           // 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用

user-scalable	   // 是否允许用户进行缩放，值为 "no" 或 "yes", no 代表不允许，yes 代表允许
```

安卓中还支持  ```target-densitydpi```  这个私有属性，它表示目标设备的密度等级，作用是决定 ```css``` 中的 ```1px``` 代表多少物理像素（当 ```target-densitydpi=device-dpi``` 时， ```css``` 中的 ```1px``` 会等于物理像素中的 ```1px```）

以后将会被**废弃**，所以避免使用

```js
target-densitydpi  // 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个
```

关于缩放值：

在 ```iphone``` 和 ```ipad``` 上，无论你给 ```viewport``` 设的宽的是多少，如果没有指定默认的缩放值，则 ```iphone``` 和 ```ipad``` 会自动计算这个缩放值，以达到当前页面不会出现横向滚动条（或者说 ```viewport``` 的宽度就是屏幕的宽度）的目的



#### 媒体查询 media query

```media query``` 是响应式设计的核心，它能够和浏览器进行沟通，告诉浏览器页面如何呈现

```css
// 假如一个终端的分辨率小于 980px，这里面的样式会覆盖掉之前所定义的样式
@media screen and (max-width:980px){
  #head { … }
  #content { … }
  #footer { … }
}
```

还可以针对不同的终端来设置多种视图

```css
/* 判断 ipad */
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) {
  /* style */
}

/* ipad 横屏 */
/* orientation 用于定义输出设备中的页面可见区域高度是否大于或等于宽度 */
/* orientation：portrait | landscape（除 portrait 值情况外，都是 landscape） */
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) {
  /* style */
}

/* ipad 竖屏 */
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) {
  /* style */
}

/* 判断 iphone5 */
/* 横屏竖屏判断方法与ipad一样 */
@media only screen and (min-device-width: 320px) and (max-device-width: 568px) {
  /* style */
}

/* 判断 iphone4-iphone4s */
/* 横屏竖屏判断方法与 ipad 一样 */
@media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
  /* style */
}
```


#### 其他需要注意的问题

#### 字体设置

字体可以使用 ```CSS3``` 提供的 ```rem```，和 ```em``` 类似，对于 ```html``` 元素，```rem``` 更为方便一些

需要注意的是：```rem``` 是相对于根元素的，一般会先重置下根元素大小（```html{font-size:100%;}```）


#### 宽度百分比

宽度可以不用写成固定的多少多少像素，可以使用百分比

```css
#head{width:100%;}

#content{width:50%;}
```

#### 图片处理

图片我们都可以通过 ```css``` 样式 ```max-width``` 来进行控制图片的最大宽度

```css
#wrap img{
  max-width:100%;
  height:auto;
}
```

图片会根据 ```wrap``` 的宽度改变已达到等宽扩充，```height``` 为 ```auto``` 的设置是为了保证图片原始的高宽比例，以至于图片不会失真

对于背景图片一类，可以使用一些 ```CSS3``` 提供的 ```background-*``` 属性

```css
#log a{
  display:block;
  width:100%;
  height:40px;
  text-indent:55rem;
  background-img:url(bg.png);
  background-repeat:no-repeat;
  background-size:100% 100%;
}
```

```background-size``` 用于设置背景图片的大小，有两个可选值，第一个值用于指定背景图的 ```width```，第 ```2``` 个值用于指定背景图的 ```height```，如果只指定一个值，那么另一个值默认为 ```auto```

还有两个可选的官方提供的值：```cover```（等比扩展图片来填满元素） 和 ```contain```（等比缩小图片来适应元素的尺寸）





----

----




## 文档类型（DOCTYPE）有哪些，含义是什么

`DOCTYPE` 是 `document type`（文档类型）的简写，用来说明你用的 `XHTML` 或者 `HTML` 是什么版本

在 `HTML 4.01` 中，`<!DOCTYPE>` 声明引用 `DTD`（文档类型定义，里面包含了文档的规则），因为 `HTML 4.01` 基于 `SGML`，`DTD` 规定了标记语言的规则，这样浏览器才能来解释你页面的标识，并正确地呈现内容

`DTD` 可声明三种类型，分别表示严格版本、过渡版本以及基于框架的 `HTML` 文档

注意： `HTML5` 中的 `DOCTYPE` 之所以可以简单的写为 `<!DOCTYPE html>`，是因为 `HTML5` 不是基于 `SGML` 的，所以不需要引用后面的 `DTD`

#### 作用

简单来说，就是声明文档的解析类型（`document.compatMode`），避免浏览器的怪异模式

`document.compatMode` 分为两种

* `BackCompat`：怪异模式，浏览器使用自己的怪异模式解析渲染页面

* `CSS1Compat`：标准模式，浏览器使用 `W3C` 的标准解析渲染页面

这个属性会被浏览器识别并使用，但是如果你的页面没有 `DOCTYPE` 的声明，那么 `compatMode` 默认就是 `BackCompat`
        
如果你的页面添加了 `<!DOCTYPE html>` 那么，那么就等同于开启了标准模式，那么浏览器就按照 `W3C` 的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了



----

----



## css 中的原生变量

```CSS``` 预编译工具 ```Sass/Less/Stylus``` 的便捷之处就是可以定义变量，方便代码的维护，其实 ```css``` 也有自己原生的变量 ```var```

> 在 ```pc``` 端支持还不错，```ie``` 不支持，移动端也不支持，大概这就是 ```css``` 变量没有广泛使用的原因吧

* 命名方式：```--*``` （以 ```--``` 开头，```*```代表变量名称）

* 变量名称命名规则：

* 不能以：```$```，```[```，```^```，```(```，```%``` 等字符字符开头，可以是数字，但是 ```css``` 和 ```js``` 不能以数字开头，但是可以是中文，日文或者韩文

#### 使用方法和作用域

```css
:root{
  --red: red;
  --blue: blue;
  --yellow: yellow;
}

.div{ 
    background-color: var(--red);
}
```

```css``` 变量有自己的作用域，局部声明的只能在内部使用，而 ```:root``` 下定义的变量的作用域是整个文档

#### 缺省值

```var( <自定义属性名> [, <默认值 ]? )```

如果变量没有定义，则使用默认值（```transparent```），如果是不合法的变量值，则无效

```css
.div { 
  background-color: var(--color, red);
}
```

#### 空格尾随特性

```css
.div {
    --size: 20;
    font-size: var(--size)px;
}
```

字体大小并不是 ```20px```，而是是默认的字体大小，因为解析出来是 ```font-size:20 px;``` 在 ```20``` 的后边有一个空格

可以使用 ```CSS3 calc()``` 计算：

```css
.div {
  --size: 20;   
  font-size: calc(var(--size) * 1px);
}
```



----

----



## em 和 rem 的区别

`em` 和 `rem` 都是相对单位，由浏览器转换为像素值，具体取决于您的设计中的字体大小设置

`em` 和 `rem` 单位之间的区别是浏览器根据谁来转化成 `px` 值 理解这种差异是决定何时使用哪个单元的关键

#### rem

当使用 `rem` 单位，他们转化为像素大小取决于**页面根元素**的字体大小，即 `html` 元素的字体大小， 根元素字体大小乘以 `rem` 的值

例如，根元素的字体大小为 `16px`，那么 `10rem` 将等同于 `160px`，即 `10 x 16 = 160`

#### em

当使用 `em` 单位时，像素值将是 `em` 值乘以使用 `em` 单位的元素的字体大小

例如，如果一个 `div` 有 `18px` 字体大小，`10em` 将等同于 `180px`，即 `10 × 18 = 180`

> 有一个比较普遍的误解，认为 `em` 单位是相对于父元素的字体大小，事实上，根据 [W3 标准](https://www.w3.org/TR/css3-values/#font-relative-lengths) ，它们是相对于使用 `em` 单位的元素的字体大小，父元素的字体大小可以影响 `em` 值，但这种情况的发生，纯粹是因为继承


#### 总结

- `rem` 单位翻译为像素值是由 `html` 元素的字体大小决定的，此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位

- `em` 单位转为像素值，取决于他们使用的字体大小，此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位

#### 注意点

* `rem` 和 `em` 单位是由浏览器基于你的设计中的字体大小计算得到的像素值

* `em` 单位基于使用他们的元素的字体大小

* `rem` 单位基于 ``html`` 元素的字体大小

* `em` 单位可能受任何继承的父元素字体大小影响

* `rem` 单位可以从浏览器字体设置中继承字体大小

* 使用 `em` 单位应根据组件的字体大小而不是根元素的字体大小

* 在不需要使用 `em` 单位，并且需要根据浏览器的字体大小设置缩放的情况下使用`rem`

* 使用 `rem` 单位，除非你确定你需要 `em` 单位，包括对字体大小

* 媒体查询中使用 `rem` 单位

* 不要在多列布局中使用 `em` 或 `rem`，改用 `%`

* 如果缩放会不可避免地导致要打破布局元素，不要使用 `em` 或 `rem`



----

----



## 水平居中

#### text-align

属性规定元素中的文本的水平对齐方式，该属性通过指定行框与哪个点对齐，从而设置块级元素内文本的水平对齐方式;

一般情况下设置文本对齐方式的时使用此属性，支持 ```justify```

例如

```css
div { text-align: left; }  // 文本居左对齐
```

#### margin: 0 auto

设置对象四边的外延边距，被称为外补丁或外边距

例如

```css
div { margin: 20px 10px 30px 40px; }  // 表示对象外边距，顶 20px、右 10px、下 30px、左 40px
```

在不设置宽度，并且元素中含用 `float:left` 情况下居中可以使用 

```css
ul{
  width: fit-content;
  margin: auto;
}
```

#### 两者的区别

* ```text-align: center``` 设置文本或 ```img``` 标签等一些内联对象（或与之类似的元素）的居中

* 而 ```margin: 0 auto``` 设置块元素（或与之类似的元素）的居中　

**注意**：

比如我们设置一个段落 ```P```，在段落内存在一个图片 ```img``` 标签

* 当设置 ```body { text-align:center; }```，在 ```IE``` 中，段落 ```P```，图片 ```img``` 同时实现了居中对齐，也就是说 ```text-align: center``` 同时作用于元素 ```p``` 与元素 ```img```，而在 ```FF``` 中，段落 ```P```，没有能实现居中对齐，而图片 ```img``` 实现了居中对齐，也就是说 ```text-align: center``` 作用于 ```img``` 标签，而段落 ```p``` 标签没有起到居中的作用

* 当设置段落 ```p { margin: 0 auto; }```，在 ```IE``` 与 ```FF``` 中，段落 ```P``` 均实现了居中对齐，图片 ```img``` 由于不是作用对象，所以不会居中对齐

有三种情况需要说明： 

* ```margin: 0 auto``` 的选择器是作用对象，如 ```div```， ```p```，而不是 ```body```，如果设置 ```body { margin: 0 auto; }``` 将不会达到任何效果，除非你定义 ```body``` 的宽度，那将会让 ```body``` 内的元素产生位置变化，如我们设置 ```body``` 宽度为 ```500px```，对 ```p``` 段落不作任何设置， 我们最大化窗口将会看到段落并非处于窗口的最左上角

* 设置段落 ```p { text-align: center; }``` 将要实现的并不是段落本身的对齐方式，而是段落内元素居中对齐

* 设置图片标签 ```img { margin: 0 auto; }```，就犯了一个小错误，```img``` 类于内联对象，不可以设置图片 ```img``` 标签的 ```margin``` 属性，如果一定要设置，那么先将它的属性转变为块元素，如 ```img { display: block; margin: 0 auto; }```


## 垂直居中

#### position

通过改变元素的 ```top``` 位置来实现居中

```css
div {
  position: relative;
  top: 50%;
  margin-top: - 1/2 * 元素的高度;
}
```

也可以使用 ```css3``` 提供的 ```transform``` 来实现

```css
div {
  position: relative;
  top: 50%;
  transform: translateY(-50%);
}
```


#### flex

也可以使用 ```css3``` 的弹性布局（```flex```）

```css
body {
  display: flex;
  align-items: center;  /* 定义 body 元素垂直居中 */
  justify-content: center;  /* 定义 body 里面的元素垂直居中 */
}

div {
  width: 100px;
  height: 100px;
  border: 1px solid red;
}
```


#### 文本内容居中

#### 单行文本

如果是单行文本，只需要设置其容器的 ```height``` 和 ```line-height``` 并使其相等即可

```css
div {
  height: 20px;
  line-height: 20px;
}
```

#### 多行文本

如果文本容器高度不限定，使用 ```padding``` 即可

如果父容器高度固定，文本可能是一行或者多行，这时候可以把文字当作图片来处理，使用 ```display``` 属性

```css
/* 外层 div */
.wrap {
  display: table-cell;
  vertical-align: middle;
}

/* 内部 div */
div {
  display:inline-block;
  font-size: （n）px;
  vertical-align:middle;
}
```

另外一种方式

```css
.wrap {
  display:table;
}

.div {
  display:table-cell;
  vertical-align:middle;
}
```




----

----



## 多行溢出隐藏

在 `WebKit` 浏览器或移动端（绝大部分是 `WebKit` 内核的浏览器）的页面实现比较简单，可以直接使用 `WebKit` 的 `CSS` 扩展属性（`WebKit` 是私有属性）`-webkit-line-clamp`

> 这是一个不规范的属性（`unsupported WebKit property`），它没有出现在 `CSS` 规范草案中

`-webkit-line-clamp` 用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 `WebKit` 属性

```css
display: -webkit-box      /* 必须结合的属性，将对象作为弹性伸缩盒子模型显示 */

-webkit-box-orient        /* 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式 */

text-overflow: ellipsis   /* 可以用来多行文本的情况下，用省略号（...）隐藏超出范围的文本 */
```

比如常用的使用方式如下

```css
/* 多行 */
div {
  overflow : hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}


/* 单行 */
div {
  text-overflow: ellipsis;
  overflow: hidden;
  word-break: break-all;
  white-space: normal;
}
```


## calc()

可以理解为一个函数 `function`，使用 `calc()` 给元素的 `border`、`margin`、`pading`、`font-size` 和 `width` 等属性设置动态值，`calc()` 最大的好处就是用在流体布局上，可以通过 `calc()` 计算得到元素的宽度

语法如下，内部可以使用加 （`+`）、减（`-`）、乘（`*`）、除（`/`）

```css
width: calc(50% + 2em)
```

* 使用 `+`、`-`、`*` 和 `/` 四则运算

* 可以使用百分比、`px`、`em`、`rem`等单位

* 可以混合使用各种单位进行计算

* 表达式中有 `+` 和 `-` 时，其前后必须要有空格，如 `"widht: calc(12%+5em)"` 没有空格的写法是错误的

* 表达式中有 `*` 和 `/` 时，其前后可以没有空格，但建议留有空格

#### 实例

```css
.wrap_div {
	width: 300px;
	background: red;
	padding: 3px 0;
}

.div {
	background: red;
	height: 50px;
	padding: 10px;
	border: 5px solid green;
	width:-moz-calc(100% - (10px + 5px) * 2);
	width:-webkit-calc(100% - (10px + 5px) * 2);
	width: calc(100% - (10px + 5px) * 2);
}
```


----

----


## absolute 的 containing block（容器块） 计算方式跟正常流有什么不同？

无论属于哪种，都要先找到其祖先元素中最近的 `position` 值不为 `static` 的元素，然后在进行判断：

1. 若此元素为 `inline` 元素，则 `containing block` 为能够包含这个元素生成的第一个和最后一个 `inline box` 的 `padding box`（除 `margin`, `border` 外的区域） 的最小矩形

2. 否则，则由这个祖先元素的 `padding box` 构成，如果都找不到，则为 `initial containing block`

补充：

1. `static`（默认值）/ `relative`：简单说就是它的父元素的内容框（即去掉 `padding` 的部分）

2. `absolute`: 向上找最近的定位为 `absolute/relative` 的元素

3. `fixed`: 它的 `containing block` 一律为根元素（`html/body`），根元素也是 `initial containing block`


----

----


## IE 中的 css hack

* `\9`    `IE8` 以及以下版本浏览器
 
* `\0`    `IE8` 识别，`IE6`、`IE7` 不能

* `*`     `IE7` 以及以下版本浏览器 

* `_`     `IE6` 浏览器

* `-`     减号是 `IE6` 专有的 `hack`

* `\9\0`  `IE9` 识别

```css
.bb{

  /* 所有识别 */  
  background-color: red;

  /* \0 是留给 ie8 的*/
  background-color: red\0; 

  /* IE6、7、8 识别 */
  .background-color: red\9; 

  /* IE6、7 识别*/
  +background-color: red;

  /* IE6 识别 */
  _background-color: red;

}
```


----

----


## html 和 body 的区别

根据标准定义，`<html>` 是文档的根元素，`<head>`、`<body>` 是 `<html>` 唯一的两个子元素，`<head>` 才是和 `<body>` 相对照、需要加以区别的元素

因此，`<html>` 和 `<body>` 是父子关系，在 HTML 文档中，`:root` 选择符对应 `<html>` 元素

> `:root` 选择符（伪类）的优先级大于 `html` 选择符

两个常见问题

## background-color

将 `background-color` 应用到 `<body>` 以后，即便 `<body>` 里的元素没有占满视口，背景颜色也会蔓延到整个视口

这时给 `html` 设置 `background-color` 可以解决这个问题

## height: 100%

一般比较常见的是设置 `html, body {height: 100%}`

这样做是为了兼容各个浏览器

* 处于混杂模式时，`body` 以窗口为高度参照，`body` 设置为 `100%` 就可以使得页面和窗口一样高，`body` 里面的嵌套 `div` 也可以扩展到窗口高度，这样的话可以使布局适应浏览器窗口大小

* 当处于标准模式时，`body` 以 `html` 标签为高度参照，`html` 标签才以窗口为参照，所以仅仅 `body 100%`，并不能使它的子 `div` 也为 `100%` 来占据整个屏幕，还要设置 `html 100%` 使得 `html` 获得窗口大小才行


----

----





## Flex

```Flex``` 是 ```Flexible Box``` 的缩写，意为 "弹性布局"，用来为盒状模型提供最大的灵活性，设为 ```Flex``` 布局以后，子元素的 ```float```、```clear``` 和 ```vertical-align``` 属性将失效

任何一个容器都可以指定为 ```Flex``` 布局，简单来说，就是把容器设置为 `display: flex`，然后对内部的子元素来进行定位分布

#### 需要注意的是，只对设置 `flex` 容器的直接子元素起作用

#### 几个值的作用

* `flex: 1` 取值是三个元素的合集，放大/缩小/基线的宽度或高度为多少（取决于 `col/row` 排列方式），例如设置为 `0 0 auto`，则不会放大

* `flex-direction: row/column` 表示排列的方式

* `flex-wrap: wrap` 如果一排放不下，则换行显示

* `justify-content`

  * `flex-start` 默认的排序方式，左对齐

  * `flex-end` 右对齐

  * `center` 居中对齐

  * `space-around` 除了元素占用的空间，剩余的空白区域平均分配到每个元素的周围

  * `space-between` 同上面类似，但是两边会紧靠着容器

* `align-content` 整体在纵轴（`Y` 轴）方向上如何排列，取值同 `justify-content` 类似

* `align-items` 每一行元素如何在纵轴上如何排列（`center`）

详细可以参考下图

![flex](flex.png)


## 如何检测改浏览器是否支持某个 CSS3 的特性

这个判断的原理是，创建一个节点，判断 `style` 属性是否含有指定的 `CSS3` 属性，有则进一步判断是否支持这个属性的某个值，比如

`text-overflow` 这个属性，`text-flow：clip` 是大部分浏览器都支持的，而 `text-flow：ellipsis` 则在 `firefox` 和 `10.6` 版本以下的 `opera` 上工作不了

判断代码如下

```js
// 创建一个节点
var element = document.createElement('div');

if('textOverflow' in element.style){
  element.style['textOverflow'] = 'ellipsis';
  return element.style['textOverflow'] === 'ellipsis';
}else{
  return false;
}
```

判断是否支持 `ellipsis` 值依靠的是浏览器对于非法 style 值的处理，当遇到不支持的属性值时，浏览器会直接把这个值抛弃

因此这里就可以先给 `textOverflow` 赋值 `'ellipsis'`，如果不支持，则其值肯定为空或者其它不等于 `'ellipsis'` 的值

因此只要判断赋值后的 `textOverflow` 是否等于 `'ellipsis'` 即可




## 边框外发光

```css
.border-out {
  border: 1px solid #f8f8f8;
  outline: none;
  border-color: rgba(241, 39, 232, .75);
  box-shadow: 0 0 10px rgba(241, 39, 232, .5);
  -moz-box-shadow: 0 0 8px rgba(241, 39, 232, .5);
  -webkit-box-shadow: 0 0 8px rgba(241, 39, 232, 3);
}
```



## 移动端全屏背景

希望的效果是整个背景能够填充整个页面，并且在页面元素上下滚动的情况下，背景固定而不随着元素滚动

这里不仅仅是简单的 `background-size: cover` 就可以轻松实现的，一般的写法是像下面这样

```css
body, html {
  height: 100%;
}

body {
  background: url(bg.png) center 0 no-repeat;
  background-size: cover;
}
```

但是这样的话在移动端会出现比较严重的后果，那就是一旦页面元素的高度大于整个页面后，滚动页面元素的时候，背景也会随之而动，而且背景会被撑开

这里用到一个小技巧，用上 `:before` 的方法

```css
body:before {
  content: '';
  position: fixed;
  z-index: -1;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: url(bg.png) center 0 no-repeat;
  background-size: cover;
}
```



## 移动端滑动卡顿

可是试着添加下面这个属性

```css
-webkit-overflow-scrolling: touch;
```




## line-height:150% 和 line-height:1.5 的区别

* 父元素 `line-height:150%` 表示根据父元素的字体大小先计算出行高值然后再让子元素继承

  * 子元素字体大小 = 父元素字体大小 * `150%`

* 父元素 `line-height:1.5` 表示根据子元素的字体大小动态计算出行高值让子元素继承

  * 子元素字体大小 = 子元素字体大小 * `150%`




## 移动端原生控件样式 -webkit-appearance

其中 `-webkit-appearance: push-button;` 的作用就是将按钮设置成 `IOS` 中默认原生控件的样式

如果想要移除原生控件样式，可以在相应的元素上加上

```css
-webkit-appearance : none;
```

即可，需要注意的是，360浏览器若是添加该属性，`input` 默认的 `checkbox` 框无法显示

兼容性可见 [-webkit-appearance](http://www.css88.com/webkit/-webkit-appearance/)



## 清除选中样式

```js
// 改变默认选中的背景颜色 
::-moz-selection{ background:#FF0000; color:#FFFFFF; }
::selection { background:#FF0000; color:#FFFFFF; }
code::-moz-selection { background:#FF0000; color:#FFFFFF; }
code::selection { background:#FF0000; color:#FFFFFF; }


// 设置页面禁止选中　　
/*全局*/
html,body{ 
  padding: 0px; 
  margin: 0px; 
  background: #fff; 
  moz-user-select: -moz-none;
  -moz-user-select: none;
  -o-user-select: none;
  -khtml-user-select: none;    /* you could also put this in a class */
  -webkit-user-select: none;   /* and add the CSS class here instead */
  -ms-user-select: none;
  user-select: none;           /* 禁止选中文字 */ 
}
```




## 火狐专有hack

```css
@-moz-document url-prefix(){.defaultmallsearchbt{padding:0 0 4px 16px;}} 
```





## link 和 @import 的区别

* 层级不同，`link` 属于 `XHTML` 标签，而 `@import` 完全是 `CSS` 提供的一种方式

  * `link` 标签除了可以加载 `CSS` 外，还可以做很多其它的事情，比如定义 `RSS`，定义 `rel` 连接属性等，`@import` 就只能加载 `CSS` 了


* 加载顺序的差别，当一个页面被加载的时候（就是被浏览者浏览的时候），`link` 引用的 `CSS` 会同时被加载，而 `@import` 引用的 `CSS` 会等到页面全部被下载完再被加载

  * 所以有时候浏览 `@import` 加载  `CSS` 的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显


* 兼容性的差别，由于 `@import` 是 `CSS2.1` 提出的，所以老的浏览器不支持，`@import` 只有在 `IE5` 以上的才能识别，而 `link` 标签无此问题


* 使用 `dom` 控制样式时的差别，当使用 `javascript` 控制 `dom` 去改变样式的时候，只能使用 `link` 标签，因为 `@import` 不是 `dom` 可以控制的




## JavaScript 判断滚动条方向

```js
$(document).ready(function () {

  // 设置参照物与比较物
  var p = 0,t = 0;

  $(window).scroll(function (e) {

    // 默认相对滚动条顶部的偏移
    p = $(this).scrollTop();
    
    // 下滚
    if( t <= p ){  
      $('.header').hide();
    }
                
    // 上滚
    else{  
      $('.header').show();
    }

    // 关于这句的解释 见下方
    setTimeout(function(){t = p;}, 0);    
  });

});
```


## setTimeout(function(){}, 0) 

`JavaScript` 是单线程执行的，也就是无法同时执行多段代码，当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列，一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 "阻塞式执行"

假如当前 `JavaScript` 进程正在执行一段很耗时的代码，此时发生了一次鼠标点击，那么事件处理程序就被阻塞，用户也无法立即看到反馈，事件处理程序会被放入任务队列，直到前面的代码结束以后才会开始执行

如果代码中设定了一个 `setTimeout` 那么浏览器便会在合适的时间，将代码插入任务队列，如果这个时间设为 `0`，就代表立即插入队列，但不是立即执行，仍然要等待前面代码执行完毕，所以 `setTimeout` 并不能保证执行的时间，是否及时执行取决于 `JavaScript` 线程是拥挤还是空闲

更多见 [JavaScript 下的 setTimeout(fn, 0) 意味着什么？](http://www.cnblogs.com/silin6/p/4333999.html)





## 如何判断鼠标滚动方向和绑定鼠标滚轮事件

#### 绑定鼠标滚轮事件

`js` 事件有很多需要兼容的地方，鼠标滚轮事件也有额外的差异吗，包括 `IE6` 浏览器在内的都适用 `mouseWheel`，而只有火狐浏览器使用`DOMMouseScroll`

#### 如何判断鼠标滚动方向

其他浏览器通过 `wheeldalta` 属性来判断，但是火狐浏览器没有这个属性，可以通过`detal`这个属性来判断

开发中发现每次向下滚动的时候，`wheeldalta`都是`-120`，但是`detail`却是`3`，火狐浏览器方向判断的数值正负与其他浏览器是相反的

```js
div.on('mousewheel DOMMouseScroll', function(e){
  var delta = e.originalEvent.wheelDelta || -e.originalEvent.detail;
  // do someing
});
```

关于火狐浏览器： [firefox的event.detail](https://segmentfault.com/q/1010000003986369)




## 媒体查询

```js
/* 判断ipad */
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) { }

/* ipad横屏 */
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: landscape) { }

/* ipad竖屏 */
@media only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (orientation: portrait) { }

/* 判断iphone5 */
/* 横屏竖屏判断方法与ipad一样 */

@media only screen and (min-device-width: 320px) and (max-device-width: 568px) { }

/* 判断iphone4-iphone4s */
/* 横屏竖屏判断方法与ipad一样 */

@media only screen and (min-device-width: 320px) and (max-device-width: 480px) { }
```


## input、placeholder 和 textarea 默认显示颜色修改

```js
input::-webkit-input-placeholder, textarea::-webkit-input-placeholder { color: red; } 
input:-moz-placeholder, textarea:-moz-placeholder { color: red; } 
input::-moz-placeholder, textarea::-moz-placeholder { color: red; } 
input:-ms-input-placeholder, textarea:-ms-input-placeholder { color: red; } 
```

## 高斯模糊效果

```css
.avatar:hover{
  filter: blur(20px);
  -webkit-filter: blur(5px);
}
```