
----

----

## JavaScripts

this，箭头函数中的 this

new，原型链，原型链顶部（Object.prototype.__proto__ === null）

call 和 apply（第一个参数，如果传递 null => window，严格模式下不做转换），bind 简单实现

事件流，冒泡与捕获

* 都支持事件冒泡，一直冒泡到 window

* 如果不是最内层的元素同时绑定有捕获和冒泡事件，改变事件绑定的先后顺序，不会影响执行结果，依然是先捕获后冒泡

* 如果是最内层的元素同时绑定有捕获和冒泡事件，则哪个事件写在前面就先执行哪一个，不再区分捕获或冒泡

* 可以对同一个元素绑定多个事件监听函数，彼此之间不会覆盖，按先后顺序执行

检测对象改变（getter/setter，defineProperties，proxies）

闭包

ajax，xhr2

* open() 方法的第三个参数表示采用异步（true）还是同步（false）

Promise

* 任务队列，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中

rxjs

* 三个状态，next，error，complete

* Subject


----

#### 实际场景

如何取得异步请求当中的数据

settimeout 和 promise 先后顺序

数组去重

生成 [0, 1, 2, 3 ... N - 1] 的数组

代码的复用（函数封装, 继承（圣杯模式）, 复制extend, 混入mixin, 借用apply/call）

打包/部署

----

----

## CSS

盒模型，BFC（触发条件），

水平，垂直居中（fit-content）

三个盒子 一个居左 两个居右 space-between

line-height:150%（先计算） 和 line-height:1.5（子元素）