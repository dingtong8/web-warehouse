无意中发现了一份面试题，引用文章评论当中的一句话，还真是原以为已经触摸到王者的门槛，没想到原来一直在青铜徘徊

特意抽些时间摸索摸索试试自己的斤两，顺便记录一下

原文地址见 [front-end-javascript-interviews](https://blog.webf.zone/front-end-javascript-interviews-in-2018-19-e17b0b10514)

----


## 使以下代码正常运行

```js
const a = [1, 2, 3, 4, 5]

// 补齐这里

a.multiply();
console.log(a);  // [1, 2, 3, 4, 5, 1, 4, 9, 16, 25]
```

#### 解决方式

两种方式，不过原理都是利用 `map` 来计算乘积在进行返回

```js
// 方法一
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return this.push(...this.map(x => x * x));
}

a.multiply();
console.log(a);

// 方法二
const a = [1, 2, 3, 4, 5]

Array.prototype.multiply = function() {
  return Object.assign(this, [...this, ...this.map(x => x * x)]);

  // 或者使用下面这样
  return Object.assign(this, this.concat(...this.map(x => x * x)));
}

a.multiply();
console.log(a);
```




## 为什么 0.2 + 0.1 === 0.3 返回 false

在展开这个问题之前，我们需要先了解计算机内部是如何表示数的

在计算机当中使用位来处理数据，每一个二进制数（二进制串）都一一对应一个十进制数

看下面两个例子

|十进制值|进制|按位格式|描述|
|-|-|-|-|
|13|	10|	13|	1x10^1 + 3x10^0 = 10 + 3|
|13|	2	|1101|	1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1|
|上面是整数，下面则是小数||||
|0.625|	10|	0.625|	6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005|
|0.625|	2|	0.101|	1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8|

简单来说

* 十进制整数转二进制方法 -- 除 `2` 取余

* 十进制小数转二进制方法 -- 乘 `2` 除整

在这里就不得不提 `0.1` 这个比较特殊的小数了，`0.1` 的二进制格式是 `0.0001100011....`

这是一个二进制无限循环小数，但是计算机内存有限，不可能存储所有的小数位数

这里就会存在一个**在某个精度点直接舍弃**的操作，当然，代价就是，`0.1` 在计算机内部根本就不是精确的 `0.1`，而是一个有舍入误差的 `0.1`

当代码被编译或解释后，`0.1` 已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了，这也就是 `0.1 + 0.2` 不等于 `0.3` 的原因

这里就会引申出另外一个问题，如下

#### 为什么 0.1 + 0.1 却等于 0.2

结果是，两个有舍入误差的值在求和时，相互抵消了，但这种 "负负得正，相互抵消" 不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消

另一个需要注意的是，二进制能精确地表示位数有限且分母是 `2` 的倍数的小数，比如 `0.5`，`0.5` 在计算机内部就没有舍入误差，所以 `0.5 + 0.5 === 1`

在现实中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在

虽然允许误差存在，但是**永远不要直接比较两个浮点的大小**

一般在进行计算的时候，尽量将浮点运算转换成整数计算，整数是完全精度的，不存在舍入误差

如果非要计算一些浮点数，可以采用第三方库，比如 [bignumber](https://github.com/MikeMcl/bignumber.js) 等库来计算，使得在一定精度内，让浮点数计算结果符合我们的期望

```js
{
  let x = new BigNumber(0.1);
  let y = new BigNumber(0.2)
  let z = new BigNumber(0.3)

  console.log(z.equals(x.add(y)))   // 0.3 === 0.1 + 0.2, true
  console.log(z.minus(x).equals(y)) // true
  console.log(z.minus(y).equals(x)) // true
}

{
  let x = 0.2
  console.log(x * x === 0.04) // false
  let y = new BigNumber(0.2)
  let r = y.mul(y)            // 0.04
  console.log(r.equals(new BigNumber(0.04))) // true
}
```


#### 小小总结

* 为什么 `0.1 + 0.2` 不等于 `0.3`，因为计算机不能精确表示 `0.1`， `0.2` 这样的浮点数，计算时使用的是带有舍入误差的数

* 并不是所有的浮点数在计算机内部都存在舍入误差，比如 `0.5` 就没有舍入误差

* 具有舍入误差的运算结可能会符合我们的期望，原因可能是 "负负得正"

* 怎么办？一是使用整型代替浮点数计算，二是不要直接比较两个浮点数，而应该使用 `bignumber.js` 这样的浮点数运算库











## JavaScript 中有哪些数据类型？

`6` 种原始类型（`Boolean`，`Null`，`Undefined`，`Number`，`String`，`Symbol`）和 `Object`



<!-- ## 普通回调，promises，observables，generator 或 async-wait -->


## 使用 Proxy 实现简单的数据绑定

关于数据双向绑定，之前也一直是在各大框架的基础上面来直接使用，并没有真正的深入了解其内部原理的实现，所以再次遇到这个问题的时候就抽了点时间来研究研究

也算是补习补习，当然并不仅限于 `Proxy`，详细见