## JavaScript 中的命名空间，变量声明提升，作用域和预编译

#### 命名空间

`JavaScript` 中没有命名空间这个概念的，只能模拟实现，命名空间的使用可以显著减少命名冲突，并很好的组织代码，如下一个简单的示例

```js
var namespace = namespace || {};

namespace.AModule = {};
namespace.AModule.name = 'abc';
namespace.BModule = {};
```


#### 变量声明提升

声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已

定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义

```js
var a;      // 这是声明
a = 1;      // 这是定义（赋值）
var a = 1;  // 合二为一：声明变量的存在并赋值给它
```

当你以为你只做了一件事情的时候（`var a = 1`），实际上解释器把这件事情分解成了两个步骤

一个是声明（`var a`），另一个是定义（`a = 1`）

#### 两个示例

```js
var a = 1;
 
function foo () {
  if (!a) {
    var a = 2;
  }
  alert(a);
};
 
foo();  // 输出 2
```

简单的调整一下

```js
var a;
a = 1;
 
function foo() {
  var a;  // 关键在这里
  if (!a) {
    a = 2;
  }
  alert(a);  // 此时的 a 并非函数体外的那个全局变量
}

foo()
```

如代码所示，在进入函数体后解释器声明了新的变量 `a`，而无论 `if` 语句的条件如何，都将为新的变量 `a` 赋值为 `2`



#### 作用域

`JavaScript` 在 `ES6` 之前是没有块级作用域的（`Block Scoping`），只有函数作用域（`Function Scoping`）

当解析器读到 `if` 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 `Hoisting`

> `JavaScript` 只有函数作用域！

若是想要 `alert(a)` 弹出那个 `1` 则可以创建有一个新的作用域，可以使用立即执行函数

```js
var a = 1;
 
function foo() {
  // 这个就是 IIFE，它会创建一个新的函数作用域
  // 并且该作用域在 foo() 的内部，所以 alert 访问不到
  // 不过这个作用域可以访问上层作用域，这就叫：闭包
  if (!a) {
    (function() {  
      var a = 2; 
    }());               
  };
  alert(a);
};
 
foo();
```

> '请始终保持作用域内所有变量的声明放置在作用域的顶部' 不是没有道理的

因为这样可以避免 `Hoisting` 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问

但是，变量声明的提升并非 `Hoisting` 的全部

在 `JavaScript` 中，有四种方式可以让命名进入到作用域中（按优先级）

* 语言定义的命名：比如 `this` 或者 `arguments`，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 `this` 之类的，这样是没有意义的

* 形式参数：函数定义时声明的形式参数会作为变量被 `hoisting` 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

* 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

* 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的




#### 预编译

`JavaScript` 引擎并不是读一句执行一句，而是读取一段、解释执行一段，而一段一段执行，`JavaScript` 会对读取的这段 `JavaScript` 代码整体有个预处理，这个预处理就是所谓的预编译

预编译阶段，`JavaScript` 引擎会进行变量提升，这里就会涉及到变量对象

`JavaScript` 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（`Variable Object`，缩写为 `VO`）是一个抽象概念中的"对象"，它用于存储执行上下文中

1. 变量

2. 函数声明

3. 函数参数

`VO` 按照如下顺序填充：

1. 函数参数（若为传入，初始化该参数值为 `undefined`）

2. 函数声明（若发生命名冲突，会覆盖）

3. 变量声明（初始化变量值为 `undefined`，若发生命名冲突，会忽略）


看以下几个实例

```js
function foo (x, y, z) {
  function x () {};
  alert(x);   // function x () {}
}

 
foo(100);
```

在初始化阶段，先初始化函数的参数，参数 `x` 即为传进来的参数，为 `100`，但是在处理函数声明的时候，发生冲突，`x` 会被覆盖，所以返回的是一个函数对象

```js
// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略
function foo (x, y, z) {
  function fn () {};
  var fn;
  console.log(fn);    // function fn () {}
}
 
foo(100);
 
// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作
function foo (x, y, z) {
  function fn () {};
  var fn = 1;
  console.log(fn);    // 1
}
 
foo(100);
 
// 在看一个容易出错的，最终会输出 100 和 0
var num = 0;
 
function a (num) {
  num = 100;
  console.log(num);
}
 
a();
console.log(num);
```

函数表达式不会影响 `VO`，比如 `var a = function foo(){}`

这里的 `foo` 是函数表达式的名称，这个是不会记录到 `AO` 中的，这也是为什么我们不能在外部通过 `foo` 来获取到这个函数对象

## JSON.parse() && JSON.stringify()

#### JSON.parse()

`JSON.parse()` 用来解析 `JSON` 字符串，构造由字符串描述的 ``JavaScript`` 值或对象，提供可选的 `reviver` 函数用以在返回之前对所得到的对象执行变换

```js
var json = '{"result":true, "count":42}';
JSON.parse(json);  // { result: true, count: 42 }
```

语法如下


```js
JSON.parse(text[, reviver])
```

如果被解析的 `JSON` 字符串是非法的（`text`），则会抛出一个语法错误异常

如果指定了 `reviver` 函数，则解析出的 ``JavaScript`` 值（解析值）会经过一次转换后才将被最终返回（返回值）

意思就是，解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 `reviver` 函数

在调用过程中，当前属性所属的对象会作为 `this` 值，当前属性名和属性值会分别作为第一个和第二个参数传入 `reviver` 中

如果 `reviver` 返回 `undefined`，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值


> 当遍历到最顶层的值（解析值）时，传入 `reviver` 函数的参数会是空字符串 `""`（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了）
> 
> 当前的 `this` 值会是 `{"": 修改过的解析值}`，在编写 `reviver` 函数时，要注意到这个特例（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历）


下面是两个示例

```js
// 如果到了最顶层，则直接返回属性值
// 否则将属性值变为原来的 2 倍
JSON.parse('{"p": 5}', function (k, v) {
  if(k === '') return v;     
  return v * 2;              
});        

// { p: 10 }


JSON.parse(' {"1": 1, "2": 2, "3": {"4": 4, "5": {"6": 6}}} ', function (k, v) {
  // 输出当前的属性名，从而得知遍历顺序是从内向外的
  console.log(k); ，

  // 最后一个属性名会是个空字符串
  // 返回原始属性值，相当于没有传递 reviver 参数
  return v;       
});

// 1
// 2
// 4
// 6
// 5
// 3 
// ""
```



#### JSON.stringify()

方法是将一个 ``JavaScript`` 值（对象或者数组）转换为一个 `JSON` 字符串，如果指定了 `replacer` 是一个函数，则可以替换值，或者如果指定了 `replacer` 是一个数组，可选的仅包括指定的属性

语法如下

```js
JSON.stringify(value[, replacer [, space]])
```

#### 关于可选参数 replacer

* 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理

* 如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 `JSON` 字符串中

* 如果该参数为 `null` 或者未提供，则对象所有的属性都会被序列化


#### 关于可选参数 space

* 指定缩进用的空白字符串，用于美化输出（`pretty-print`）

* 如果参数是个数字，它代表有多少的空格（上限为 `10`），该值若小于 `1`，则意味着没有空格

* 如果该参数为字符串（字符串的前十个字母），该字符串将被作为空格

* 如果该参数没有提供（或者为 `null`）将没有空格


#### 关于序列化，有下面五点注意事项

* 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中

* 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值

* `undefined`、任意的函数以及 `symbol` 值，如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，如果出现在数组中时将被转换成 `null`

* 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误

* 所有以 `symbol` 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们

* 不可枚举的属性会被忽略


```js
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1, "false", false]'
JSON.stringify({ x: 5 });                  // '{"x": 5}'

JSON.stringify({ x: 5, y: 6 });
// "{"x": 5, "y": 6}"

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1, "false", false]'

JSON.stringify({ x: undefined, y: Object, z: Symbol("") });
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null, null, null]' 

JSON.stringify({ [Symbol("foo")]: "foo" });
// '{}'

JSON.stringify({ [Symbol.for("foo")]: "foo" }, [Symbol.for("foo")]);
// '{}'

JSON.stringify(
  { [Symbol.for("foo")]: "foo" },
  function (k, v) {
    if (typeof k === "symbol") {
      return "a symbol";
    }
  }
);
// undefined 

JSON.stringify(
  Object.create(
    null,
    {
      x: { value: 'x', enumerable: false },
      y: { value: 'y', enumerable: true }
    }
  )
);
// 不可枚举的属性默认会被忽略
// "{"y":"y"}"
```



#### replacer 参数

`replacer` 参数可以是一个函数或者一个数组，作为函数，它有两个参数，键值都会被序列化

* 如果返回一个 `Number`, 转换成相应的字符串被添加入 `JSON` 字符串

* 如果返回一个 `String`, 该字符串作为属性值被添加入 `JSON`

* 如果返回一个 `Boolean`, `"true"` 或者 `"false"` 被作为属性值被添加入 `JSON` 字符串

* 如果返回任何其他对象，该对象递归地序列化成 `JSON` 字符串，对每个属性调用 `replacer` 方法（除非该对象是一个函数，这种情况将不会被序列化成 `JSON` 字符串）

* 如果返回 `undefined`，该属性值不会在 `JSON` 字符串中输出

> 需要注意的是，不能用 `replacer` 方法，从数组中移除值（`values`），如若返回 `undefined` 或者一个函数，将会被 `null` 取代

```js
var foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 };
var jsonString = JSON.stringify(foo, (key, value) => {
  if (typeof value === "string") {
    return undefined;
  }
  return value;
});

console.log(jsonString);  // {"week": 45, "month": 7}
```

如果 `replacer` 是一个数组，数组的值代表将被序列化成 `JSON` 字符串的属性名（即只有包含在这个数组中的属性名才会被序列化）

```js
var foo = { foundation: "Mozilla", model: "box", week: 45, transport: "car", month: 7 };
console.log(JSON.stringify(foo, ['week', 'month']));  //  只保留 week 和 month 属性值
```


#### 关于 toJSON 方法

需要注意的是，如果一个被序列化的对象拥有 `toJSON` 方法，那么该 `toJSON` 方法就会覆盖该对象默认的序列化行为（即为调用 `toJSON` 方法后的返回值会被序列化）

```js
var obj = {
  foo: 'foo',
  toJSON: function () {
    return 'bar';
  }
};

JSON.stringify(obj);         // '"bar"'
JSON.stringify({ x: obj });  // '{"x":"bar"}'
```


#### 使用 JSON.stringify 来格式化对象

在平常的开发过程中，经常会遇到一些十分复杂的对象，往往是对象当中嵌套对象，看上去十分的不直观

我们可以利用 `replacer` 和 `space` 参数来对其进行格式化

```js
// 因为函数如果出现在非数组对象的属性值中时，在序列化过程中会被忽略，所以需要特殊处理
var foo = function (key, value) {
  if (typeof (value) === 'function' || typeof(value) === 'symbol') {
    return value.toString()
  } else if (typeof (value) === 'undefined') {
    return 'undefined'
  } else {
    return value;
  }
}

var json = { bar: 'aaa', foo: { age: Symbol('23') }, baz: undefined, o: { name: 'zhangsan', userInfo: { sex: 0, getSex: function () { return this.sex; }, address: null } } };
JSON.stringify(json, foo, 2);

// {
//   "bar": "aaa",
//   "foo": {
//     "age": "Symbol(23)"
//   },
//   "baz": "undefined",
//   "o": {
//     "name": "zhangsan",
//     "userInfo": {
//       "sex": 0,
//       "getSex": "function () { return this.sex; }",
//       "address": null
//     }
//   }
// }
```

















## setTimeout 与 Promise

下面几个的输出值为多少

```js
// 一
for (var i = 0; i < 5; i++) {
  console.log(i);
}


// 二
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}


// 三
for (var i = 0; i < 5; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  })(i)
}


// 四
for (let i = 0; i < 5; i++) {
  setTimeout(function () {
    console.log(i);
  }, 1000 * i);
}


// 五
for (var i = 0; i < 5; i++) {
  (function () {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  })(i)
}


// 六
for (var i = 0; i < 5; i++) {
  setTimeout((function (i) {
    console.log(i);
  })(i), i * 1000);
}



// 七
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);



// 八
setTimeout(function () {
  console.log(1)
}, 0);

new Promise(function executor(resolve) {
  console.log(2);
  for (var i = 0; i < 10000; i++) {
    i == 9999 && resolve();
  }
  setTimeout(function() {
    console.log(6)
  }, 0)
  console.log(3);
}).then(function () {
  console.log(4);
});

console.log(5);

```

----

----

1. 最基本的，输出 `0 - 4`

2. `setTimeout` 会延迟执行，那么执行到 `console.log` 的时候，其实 `i` 已经变成 `5` 了，所以结果为 `5` 个 `5`

3. 如果要输出 `0` 到 `4`，可以使用三和四两种方式

5. 去掉 `function()` 中的 `i`，内部就没有对 `i` 保持引用，结果还是 `5` 个 `5`

6. 如果修改成六这样，立即执行函数会立即执行，所以会立即输出 `0 - 4` 而不会延迟

7. 最后两个有些复杂，但是原理是类似的

都被改写成了 `Promise`，但是首先需要明确的是，`promise` 的任务会在当前事件循环末尾中执行，而 `setTimeout` 中的任务是在下一次事件循环执行

首先是一个 `setTimeout`，所以其中的任务是会在下一次事件循环中才会执行，因此开始肯定不会输出 `1`

然后是一个 `Promise`，里面的函数是会立即执行的，所以首先输出 `2` 和 `3`

这里需要注意的是，`Promise` 的 `then` 应当会放到当前 `tick` 的最后，但是还是在当前 `tick` 中（而不是下一次事件循环），所以会先输出 `5` 然后才会输出 `4`，最后轮到下一个 `tick` 才会输出 `1`

所以结果为 `2 3 5 4 1`

至于最后一个，和第七个是一样的，结果为 `2 3 5 4 1 6`



## clientWidth, offsetWidth, scrollWidth

```js
document.body.clientWidth      // 返回对象内容的可视区的长度（不包括边框，边距或滚动条），会随对象显示大小的变化而改变
 
document.body.offsetWidth      // 对象整体的实际长度（包括边框和填充），会随对象显示大小的变化而改变
 
document.body.scrollWidth      // 对象的实际内容的长度（不包括边线宽度），会随对象中内容超过可视区后而变大
 
----
 
document.body.scrollTop        // 页面滚动条向下拉动的距离
 
document.body.scrollLeft       // 页面滚动条向左拉动的距离
 
obj.offsetTop                  // 元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的
                               // 则是获取上外边缘距离文档内壁的距离，即距离页面文档顶部距离，不会因为滚动条的改变而改变
 
obj.offsetLeft                 // 同 offsetTop 一样，只是方位不同
 
----
 
// 下面几个是用的比较少的
window.screen.width            // 屏幕分辨率的宽度
 
window.screen.availWidth       // 显示器工作区宽度（除去任务栏的距离）
```

两个兼容函数

```js
// 返回视口的大小，部分移动设备浏览器对 innerWidth 的兼容性不好
// 需要使用 document.documentElement.clientWidth 或者 document.body.clientWidth 来兼容（混杂模式下对 document.documentElement.clientWidth 不支持）
// 使用方法 getViewPort().width
function getViewPort () {
  // 浏览器嗅探，混杂模式
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.clientWidth,
      height: document.body.clientHeight
    };
  } else {
    return {
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    };
  }
}


// 获得文档的大小（区别与视口），与上面类似
function getDocumentPort () {
  if(document.compatMode == "BackCompat") {
    return {
      width: document.body.scrollWidth,
      height: document.body.scrollHeight
    };
  } else {
    return {
      width: Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth),
      height: Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight)
    }
  }
}
```


## call，apply，bind 的定义与实现

`bind` 方法的定义见 [ECMAScript5.1 - bind](http://yanhaijing.com/es5/#324)

使用方式如下

```js
fun.bind(thisArg[, arg1[, arg2[, ...]]])
```

`bind()` 方法会创建一个新函数，当这个新函数被调用时，它的 `this` 值是传递给 `bind()` 的第一个参数, 它的参数是 `bind()` 的其他参数和其原本的参数

`bind` 返回的绑定函数也能使用 `new` 操作符创建对象（这种行为就像把原函数当成构造器），提供的 `this` 值被忽略，同时调用时的参数被提供给模拟函数

`bind` 方法与 `call`、`apply` 最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数

> 还可以写成 `fn.bind(obj, arg1)(arg2)`

一句话概括就是

该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入 `bind` 方法的第一个参数作为 `this`，传入 `bind` 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数


#### 实现

初级实现

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  // 记住 this，就是需要绑定 this 的实例函数（原函数）
  var _this = this;
  var argsArray = Array.prototype.slice.call(arguments);
  return function () {
    // 剔除第一个参数，其余作为参数来传递（提供给原函数）
    return _this.apply(context, argsArray.slice(1));
  }
}
```

这里存在一些问题，在于在预置参数功能丢失的现象（因为使用了 `argsArray.slice(1)`），比较好的解决方式是下面这种

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  var _this = this;
  var args = Array.prototype.slice.call(this.arguments, 1);
  return function () {
    return _this.apply(context, args.concat(Array.prototype.slice.call(arguments)))
  }
}
```

但是 `bind` 当中还有一点比较特殊

`bind` 返回的函数如果作为构造函数，搭配 `new` 关键字出现的话，我们的绑定 `this` 就需要"被忽略"

这样一来就需要在构造函数的场景下来进行兼容

```js
Function.prototype.bind = Function.prototype.bind || function (context) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var F = function () { };
  F.prototype = this.prototype;
  var bound = function () {
    return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments)));
  }
  bound.prototype = new F();
  return bound;
}
```

如果比较严谨的话，还需要判断调用 `bind` 方法的一定要为一个函数，否则就抛出一个错误

```js
if (typeof this !== 'function') {
  throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)
}
```


#### 扩展，要求不使用 call 和 apply

简单来说，就是手动实现一个 `call` 和 `apply` 即可

`call` 和 `apply` 本质是一样的，区别就在于参数的不同

`call` 方法的定义 [call](http://yanhaijing.com/es5/#323)

简单来说就是

* `call()` 方法在使用一个指定的 `this` 值和若干个指定的参数值的前提下调用某个函数或方法

* `apply()` 方法在使用一个指定的 `this` 值和参数值必须是数组类型的前提下调用某个函数或方法


#### 原理

`call()` 和 `apply()` 的第一个参数是要调用函数的母对象，它是调用上下文，在函数体内通过 `this` 来获得它的引用，比如以对象 `o` 的方法来调用函数 `f()`

```js
f.call(o)

f.apply(o)
```

大致原理如下所示

```js
o.m = f;    // 将 f 存储为 o 的临时方法
o.m();      // 调用它，不传入参数

delete o.m; // 将临时方法删除
```

在严格模式中，`call()` 和 `apply()` 的第一个参数都会变成 `this` 的值，哪怕传入的实参是原始值甚至是 `null` 或 `undefined`

在 `ES3` 或者非严格模式中，传入的 `null` 和 `undefined` 都会被全局对象代替，而其他原始值则会被相应的包装对象（`wrapper object`）所替代

简单来说就是，`f.call(o)` 其原理就是先通过 `o.m = f` 将 `f` 作为 `o` 的某个临时属性 `m` 存储，然后执行 `m`，执行完毕后将 `m` 属性删除



#### 实现

这里以 `apply` 为例

初级实现

```js
Function.prototype.apply = function (context) {
  context.fn = this;
  context.fn();
  delete context.fn;
}
```

但是 `apply` 有一点不同，它的参数是一个数组，在执行的时候会把数组的值依次传递给函数当参数

需要实现类似 `context.fn(arg1, arg2, arg3 ...)` 的调用方式，这里采用 `evel` 来实现

```js
Function.prototype.apply = function (context) {
  var args = arguments[1];
  context.fn = this;

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1,arg2,arg3...)
  var fnStr = 'context.fn(';
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
  }
  fnStr += ')';
  eval(fnStr);

  delete context.fn;
}
```

有几个需要注意的地方

`this` 参数可以传递 `null` 或者不传，当为 `null` 的时候，则指向 `window`

函数是可以指定返回值的

```js
Function.prototype.apply = function (context) {
  var context = context || window;
  var args = arguments[1];
  context.fn = this;

  if (args === void 0) {
    return context.fn();
  }

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1, arg2, arg3 ...)
  var fnStr = 'context.fn(';
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
  }
  fnStr += ')';
  var returnVal = eval(fnStr);

  delete context.fn;
  return returnVal;
}
```

还有一个问题，即 `context.fn = this`，这里我们只是假设不存在名为 `fn` 的属性，所以这里我们需要保证 `fn` 的唯一性

这里可以采用 `ES6` 提供的 `symbol` 数据类型，直接添加即可

```js
var fn = Symbol()
context[fn] = this
```

如果不使用 `symbol`，也可以来手动模拟一个，简单来说就是随机定义一个属性名称，然后在进行赋值的时候判断一下

```js
function symbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    // 如果已经存在这个属性，则递归调用，直到没有这个属性
    arguments.callee(obj)
  } else {
    return unique_proper;
  }
}

// 使用
var fn = symbol(context);
```

而 `call` 方法，可以利用上面的 `apply` 来简单实现

```js
Function.prototype.call = function (context) {
  return this.apply(([].shift.apply(arguments), arguments));
}
```



#### 汇总

```js
function symbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    // 如果已经存在这个属性，则递归调用，直到没有这个属性
    arguments.callee(obj);
  } else {
    return unique_proper;
  }
}

Function.prototype.apply = function (context) {

  var context = context || window;

  // 获取传入的数组参数
  var args = arguments[1];
  var fn = symbol(context);

  // 保证 fn 的唯一性
  context[fn] = this

  // 如果没有传入参数则直接执行
  if (args == void 0) {
    return context[fn]()
  }

  // 使用 evel 来实现（并不是唯一的方式）
  // 来得到 context.fn(arg1, arg2, arg3 ...)
  var fnStr = 'context[fn]('
  for (var i = 0; i < args.length; i++) {
    fnStr += i == args.length - 1 ? args[i] : args[i] + ','
  }
  fnStr += ')'

  // 使用 evel 执行，完成后删除这个属性
  var returnValue = eval(fnStr)
  delete context[fn]

  return returnValue
}

Function.prototype.call = function (context) {
  return this.apply(([].shift.apply(arguments)), arguments)
}

Function.prototype.bind = Function.prototype.bind || function (context) {

  // 判断调用对象是否是函数
  if (typeof this !== 'function') {
    throw new Error(`Function.prototype.bind - what is trying to be bound is not callable`)
  }

  // 记住 this，就是需要绑定 this 的实例函数（原函数）
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);

  // 在构造函数的场景下来进行兼容（因为在搭配 new 使用的时候，绑定的 this 需要被忽略）
  var F = function () { };
  F.prototype = this.prototype;

  var bound = function () {
    return _this.apply(this instanceof F ? this : context || this, args.concat(Array.prototype.slice.call(arguments)));
  }

  bound.prototype = new F();
  
  return bound;
}
```



## Angular 中路由传递参数的几种方式

主要分为三种方式

* 在查询参数中传递

* 在路由路径中传递

* 在路由配置中传递


#### 在查询参数中传递

如下所示，只需在标签当中添加跳转的路由和需要添加的参数即可

```html
<a [routerLink]="['/pages', 'case']" [queryParams]="{ case: this.project.id }">
  <button>预览</button>
</a>
```

而在对应组件当中则可以通过 `ActivatedRoute` 来进行接收


```ts
import { ActivatedRoute } from '@amgular/router';

export class StockComponent implements OnInit {

  private projectId: number;

  constructor(private _activatedRoute: ActivatedRoute) {}

  ngOnInit() {
    this.projectId = this._activatedRoute.snapshot.queryParams['id'];
  }

}
```


#### 在路由路径中传递

```ts
// 定义路由
const routes: Routes = [
  { path: 'case/:id', component: CaseComponent },
  ...
];
```

然后在路由的时候传递数据即可

```html
<a [routerLink]="['/case', '123']">预览</a>
```

接受参数的方式和上面是一样的，同样是通过 `ActivatedRoute` 来获取，但是有一点需要注意的就是

如果使用的是 `snapshot` 的方式传递数据，因为初始化一次，路由到自身不能传递参数，需要使用订阅模式

```ts
this._activatedRoute.params.subscribe((params: Params) => this.projectId = params['id']);
```




#### 在路由配置中传递

方式如下，首先在路由当中配置

```js
const routes: Routes = [
  { path: 'case/:id', component: CaseComponent, data: { id: '123' } },
  ...
];
```

接受参数

```ts
this.projectId = this._activatedRoute.snapshot.date[0]['id'];
```


## 数组的常用方法分析及内部实现原理

#### Array.prototype.splice()

```js
Array.prototype.splice = function (start, deleteCount) {
  var max = Math.max,
    min = Math.min,
    delta,              // 偏移量
    element,
    insertCount = max(arguments.length - 2, 0),   // 排除掉 arguments 参数中 start 和 deleteCount，剩余是待插入元素
    k = 0,
    len = this.length,  // 对 array 调用时，this 指向当前数组
    new_len,
    result = [],        // 返回数组
    shift_count;        // 需移位的数量

  start = start || 0;     // start 默认值为 0
  if (start < 0) start += len;        // start < 0 时，从数组后端开始
  start = max(min(start, len), 0);    // 经过处理，0 <= start <= len
  deleteCount = typeof deleteCount === 'number' ? deleteCount : len;  // deleteCount 默认值是 len
  deleteCount = min(deleteCount, len - start);    // deleteCount <= 可删除数量
  deleteCount = max(deleteCount, 0);  // 0 <= deleteCount <= 可删除数量

  delta = insertCount - deleteCount;
  new_len = len + delta;

  // 获取删除元素
  while (k < deleteCount) {
    element = this[start + k];
    if (element != undefined) {
      result[k] = element;
    }
    k += 1;
  }

  shift_count = len - start - deleteCount;

  // 待插入数量小于删除数量，原数组后续元素依次向左偏移
  if (delta < 0) {
    k = start + insertCount;    // 从 start 至 start + insertCount 留给待插入元素
    while (shift_count) {
      this[k] = this[k - delta];
      k += 1;
      shift_count -= 1;
    }
    this.length = new_len;

  // 待插入数量大于删除数量，原数组后续元素依次向右偏移
  // delta === 0 时，待插入数量等于删除数量，无需偏移
  } else if (delta > 0) {
    k = 1;
    while (shift_count) {
      this[new_len - k] = this[len - k];
      k + 1;
      shift_count -= 1;
    }
    // 非必须，因给一开始 this[new_len - k] 赋值时，length 属性已经自动设置为数组最后元素下标值
    // this.length = new_len;
  }

  // 最后将待插入元素插入原数组
  for (k = 0; k < insertCount; k += 1) {
    // 排除掉 arguments 参数中 start 和 deleteCount
    this[start + k] = arguments[k + 2];
  }

  return result;
};
```




#### Array.prototype.push()

```js
Array.prototype.push = function () {

  // 对 arguments 对象通过 array.slice 方法转换成数组
  var args = Array.prototype.slice.apply(arguments);

  // 通过 array.concat 连接两个数组
  var params = [this.length, 0].concat(args);

  // 对数组调用 splice 方法
  // start = this.length
  // deleteCount = 0
  // insertItems = args
  this.splice.apply(this, params);

  // 返回新的数组 length
  return this.length;
};

// 上述步骤合并，简写为下面方式（简单来说就是利用 concat 拼接两个数组）
Array.prototype.push = function () {

  this.splice.apply(this, [this.length, 0].concat(Array.prototype.slice.apply(arguments)));

  return this.length;

};
```




#### Array.prototype.pop()

```js
// 删除并返回数组的最后一个元素
Array.prototype.pop = function () {
  return this.splice(this.length - 1, 1)[0];
}
```




#### Array.prototype.shift()

```js
// 和上面一样，但是删除并返回数组的第一个元素
Array.prototype.shift = function () {
  return this.splice(0, 1)[0];
}
```




#### Array.prototype.unshift()

```js
// 向数组的开头添加一个或更多元素，并返回新的长度
Array.prototype.unshift = function () {
  this.splice.apply(this, [0, 0].concat(Array.prototype.slice.apply(arguments)));
  return this.length;
};
```


----

----



#### 数组常用方法

```js
var arr = [];
 
// 删除第一项
arr.shift();
 
// 添加第一项
arr.unshift();
 
// 删除最后一项
arr.pop();
 
// 添加最后一项
arr.push();
 
// concat() 方法用于连接两个或多个字符串
stringObject.concat(stringX, stringX, ..., stringX)
 
// 利用 concat 来复制
arr.concat(arr);
 
// join() 方法 把数组中的所有元素放入一个字符串（可以指定分隔符）
arr.join();
 
// splice() 从数组中 添加/删除 项目，然后返回被删除的项目
// index              必需，整数，规定 添加/删除 项目的位置，使用负数可从数组结尾处规定位置
// howmany            必需，要删除的项目数量，如果设置为 0，则不会删除项目
// item1, ..., itemX  可选，向数组添加的新项目
arr.splice(index, howmany, item1, ..., itemX)
```





#### String常用方法

```js
var str;
 
// charAt() 方法 返回指定位置的字符
// 字符串中第一个字符的下标是 0，如果参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串
str.charAt(index);
 
// indexOf()    方法 返回某个指定的字符串值在字符串中首次出现的位置
// searchvalue  必需，规定需检索的字符串值
// fromindex    可选的整数参数，规定在字符串中开始检索的位置，它的合法取值是 0 到 str.length - 1，如省略该参数，则将从字符串的首字符开始检索
str.indexOf(searchvalue, fromindex)
 
// replace() 方法 用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串
str.replace(regexp/substr, replacement)
 
// split()    方法 把一个字符串分割成字符串数组
// howmany    可选参数 指定返回的数组的最大长度，如果设置了该参数，返回的子串不会多于这个参数指定的数组，如果没有设置该参数，整个字符串都会被分割，不考虑它的长度
str.split(separator, howmany)
 
// slice() 方法 提取字符串的某个部分，并以新的字符串返回被提取的部分
// 从 start 开始（包括 start）到 end 结束（不包括 end）
str.slice(start, end)
 
// substr() 方法 可在字符串中抽取从 start 下标开始的指定数目的字符
// start也可接受负数，也表示从字符串尾部计数，这点和 slice 相同；但 substr 的 length 则不能小于 1，否则返回空字符串
str.substr(start,length)

```






#### Math常用方法

```js
// 返回数的绝对值
Math.abs(x)
 
// 向上取舍
Math.ceil(x)
 
// 向下取舍
Math.floor(x)
 
// 四舍五入
Math.round(x)
 
// 随机数 0.0 ~ 1.0 之间的一个伪随机数
Math.random()
```




#### 全局对象

```js
// parseFloat() 函数可解析一个字符串，并返回一个浮点数
// 指定字符串中的首个字符是否是数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串
parseFloat(string)
 
// parseInt() 函数可解析一个字符串，并返回一个整数
// radix 为进制，如果省略该参数或其值为 0，则数字将以 10 为基础来解析
parseInt(string, radix)

```



#### 关于 slice，substr 和 substring 的区别

> 对于 `substr()` 方法，需要注意的是 `ECMAscript` 没有对该方法进行标准化，因此反对使用它

```js
substr(start [, length])

substring(start [, end])

slice(start [, end])
```

从定义上看 `substring` 和 `slice` 是同类的，参数都是字符串的某个（开始）位置到某个（结束）位置（但（结束）位置的字符不包括在结果中）

而 `substr` 则是字符串的某个（开始）位置起，数 `length` 个长度的字符才结束

共性为：从 `start` 开始，如果没有第 `2` 个参数，都是直到字符串末尾



#### substring 和 slice 的区别

`slice` 可以接受"负数"，表示从字符串尾部开始计数，而 `substring` 则把负数或其它无效的数，当作 `0`

```js
'hello world!'.slice(-6, -1)        // 'world'
'hello world!'.substring('abc', 5)  // 'hello' 
```

`substr` 的 `start` 也可接受负数，也表示从字符串尾部计数，这点和 `slice` 相同，但 `substr` 的 `length` 则不能小于 `1`，否则返回空字符串

```js
'hello world!'.substr(-6, 5) // 'world'
'hello world!'.substr(0, -1) // '' 
```

所以很多人认为 `substring` 是多余的：如果只知道位置，那么用 `slice`，如果知道长度则用 `substr`






#### 数组排序的两种方法

```js
// 二分排序
function oSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  var left = [];
  var right = [];
  var oNum = Math.floor(arr.length / 2);
  var oNumVode = arr.splice(oNum, 1);

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < oNumVode) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return oSort(left).concat(oNumVode, oSort(right));
}


// 冒泡排序
function mp(arr) {
  var temp;
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < arr.length; j++) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j + 1];
        arr[j + 1] = arr[i];
        arr[i] = temp;
      }
    }
  }
  return arr;
}
```

#### 数组去重的两种方法

```js
Array.prototype.uniq1 = function () {
  // 先排序，在比较
  this.sort();
  var arr = [this[0]];
  for (var i = 1; i < this.length; i++) {
    if (this[i] !== arr[arr.length - 1]) {
      arr.push(this[i]);
    }
  }
  return arr;
}


Array.prototype.uniq2 = function () {
  var arr = [];
  for (var i = 0; i < this.length; i++) {
    // 遍历当前数组
    // 检测新数组内是否重复，如果没有出现则为 -1
    // 把 arr 数组的第 i 项插入新数组
    if (arr.indexOf(this[i]) == -1) {
      arr.push(this[i]);
    }
  }
  return arr;
}

var arr = [1, 2, 3, 4, 4, 4, 4, 5, 5, 5, 6]
arr.uniq1()
```



## typeOf，hasOwnProperty，isPrototypeOf，instanceof

#### typeOf

```js
function show(x) {

  console.log(typeof (x));    // undefined
  console.log(typeof (10));   // number
  console.log(typeof ('abc')); // string
  console.log(typeof (true));  // boolean

  console.log(typeof (function () { }));  //function

  console.log(typeof ([1, 'a', true]));  //object
  console.log(typeof ({ a: 10, b: 20 }));  //object
  console.log(typeof (null));  //object
  console.log(typeof (new Number(10)));  //object

}

show();

```

* 对于数字类型的值，`typeof` 会返回 `number`（`NaN` 也是一个数字类型，因为它在 `JavaScript` 中代表的是特殊非数字值）

* 对于字符串类型的值，`typeof` 会返回 `string`

* 对于布尔类型的值，`typeof` 会返回 `boolean`

* 对于对象，数组，`null` 而言，`typeof` 会返回 `object`

* 对于函数类型而言，`typeof` 返回 `function`

* 如果运算数没有定义（不存在或未赋值），将会返回 `undefined`






#### hasOwnProperty

是用来判断一个对象是否有你给出名称的属性或对象（需要注意的是，此方法无法检查该对象的原型链中是否具有该属性）

该属性必须是对象本身的一个成员，在跨浏览器的设计中，我们不能依赖于 `for in` 来获取对象的成员名称，一般使用 `hasOwnProperty` 来判断

```js
var buz = {
  fog: '123'
};

for (var name in buz) {
  if (buz.hasOwnProperty(name)) {
    alert("this is fog (" + name + ") for sure. Value: " + buz[name]);
  }
  else {
    alert(name); // toString or something else
  }
}
```

在 `Object.prototype` 中调用 `hasOwnProperty()`

```js
// 对象
var man = {
  hands: 2,
  legs: 2,
  heads: 1
};

// 将一个方法添加到对象上
if (typeof Object.prototype.clone === "undefined") {
  Object.prototype.clone = function () {
    // ...
  }
}

// 使用 hasOwnProperty()
for (var i in man) {
  if (Object.prototype.hasOwnProperty.call(man, i)) {  // 过滤
    console.log(i, ":", man[i]);
  }
}
```

在使用 `hasOwnProperty()` 对 `man` 对象进行精炼后，可有效的避免命名冲突，也可以使用一个本地变量来缓存比较长的属性名

```js
var i, hasOwn = Object.prototype.hasOwnProperty;

for (var i in man) {
  // 过滤
  if (hasOwn.call(man, i)) {  
    console.log(i, ":", man[i]);
  }
}
```

严格来讲，不使用 `hasOwnProperty()` 并没有错，依赖具体任务和对代码的自信，可以忽略过该方法并略微加快循环的执行速度

但是当确认不了对象的内容（和原型链）的时候，最好还是加上 `hasOwnProperty()` 这样安全的检查






#### isPrototypeOf

是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回 `true`，否则返回 `false`

```js
function Fee() {
  // . . .
}



function Fi() {
  // . . .
}

Fi.prototype = new Fee();



function Fo() {
  // . . .
}

Fo.prototype = new Fi();



function Fum() {
  // . . .
}
Fum.prototype = new Fo();


// ---------------------------


var fum = new Fum();
// ...

if (Fi.prototype.isPrototypeOf(fum)) {
  // do something safe
} 
```







#### instanceof

用来测试一个对象在其原型链构造函数上是否具有 `prototype` 属性，直白的说就是，用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上

```js
// 定义构造函数
function C() { }
function D() { }

var o = new C();

// true，因为 Object.getPrototypeOf(o) === C.prototype
o instanceof C;

// false，因为 D.prototype 不在 o 的原型链上
o instanceof D;

o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
C.prototype instanceof Object // true，同上

C.prototype = {};
var o2 = new C();

o2 instanceof C; // true

o instanceof C; // false，C.prototype 指向了一个空对象，这个空对象不在 o 的原型链上

D.prototype = new C(); // 继承
var o3 = new D();
o3 instanceof D; // true
o3 instanceof C; // true
```

需要注意的是，如果表达式 `obj instanceof Foo` 返回 `true`，则并不意味着该表达式会永远返回 `ture`，因为 `Foo.prototype` 属性的值有可能会改变

改变之后的值很有可能不存在于 `obj` 的原型链上，这时原表达式的值就会成为 `false`

另外一种情况下，原表达式的值也会改变，就是改变对象 `obj` 的原型链的情况，虽然在目前的 `ES` 规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 `__proto__` 魔法属性，是可以实现的

比如执行 `obj.__proto__ = {}` 之后，`obj instanceof Foo` 就会返回 `false` 了

更多详细见： [MDN - instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)


所以，在判断一个变量是不是对象的情况下，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`

```js
var fn = function () { };

console.log(fn instanceof Object);  // true
```



## 运算符优先级

```js
var provider = {
  test: {
    $get: function () {
      return function anonymous(config) {
        console.log(this);  // window
      };
    }
  }
};

var type = "test";
var config = {};
new provider[type].$get()(config);
```

这里需要明确两点，一个是构造函数的返回，另一个是 `new` 操作符的执行顺序

#### 构造函数的返回

简单来说

* 如果返回的是一个非引用类型的值时，实际上返回的是仍然是新创建的实例对象

* 如果返回的是一个引用类型的值时，返回的是引用对象本身

比如如下示例

```js
function Person() {}

const person = new Person();
console.log(typeof person);  // object

// ----

function Person() {
  return function() {}
}

const person = new Person();
console.log(typeof person);  // function
```

#### new 操作符的执行顺序

在 `MDN` 的 `new` 操作符描述中，语法是

```js
new constructor[([arguments])]
```

可以发现，参数 `arguments` 是可缺省的，那么就意味着，对于不含参数的构造函数而言，`new Person()` 和 `new Person` 是一样的

那么又会涉及到一个问题，为什么执行的时候是执行的 `new Person()`，而不是 `(new Person)()` 呢，这里就涉及到操作符的执行顺序

这里也只列举几个这里用到的运算符，更多详细的可以参考 [运算符优先级 (JavaScript)](https://msdn.microsoft.com/zh-cn/library/z3ks45k7(v=vs.94).aspx)

|优先级|运算类型|关联性|运算符|
|-|-|-|-|
|20|	圆括号|	n/a|	( … )|
|19|成员访问|	从左到右|	… . …|
||new（带参数列表）|	n/a|	new … ( … )|
|18| 函数调用|	从左到右|	… ( … )|
||new（无参数列表）|	从右到左|	new …|
|...|
|13| 加法|	从左到右|	… + …|
||减法|	从左到右|	… - …|


了解了原理之后，我们可以很轻松的将上面的问题解析为

```js
// 因为带参数列表的 new 优先级高于函数调用，所以不会先执行函数调用
(new provider[type].$get())(config);
```

这里还有一个扩展的小问题，下面的结果是多少

```js
var str = 'Hello' + true ? 'World' : 'JavaScript';
```

结果是 `World`， 因为 `+` 运算符优先级是高于条件运算符的，其实就相当于执行了 `('Hello' + true) ? 'World' : 'JavaScript'`

在来看一个操作符相关的问题

```js
function Foo() {
  getName = function () {
    console.log('1');
  };
  return this;
}
Foo.getName = function () {
  console.log('2');
};
Foo.prototype.getName = function () {
  console.log('3');
};
var getName = function () {
  console.log('4');
};
function getName() {
  console.log(5);
}

// 输出结果依次为多少
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

// 结果为 2 4 1 1 2 3 3
```

一个一个来看，首先我们来整理一下上面的代码，有几个需要注意的地方

```js
function Foo() {
  // 注意这里是全局的
  getName = function () {
    console.log('1');
  };
  return this;
}
```

还有下面这个，两者都会提升，但是函数声明的提升级别是要比 `var` 高的，所以实际执行的是

```js
function getName() {
  console.log(5);
}

// 会覆盖上面的
var getName = function () {
  console.log('4');
};
```


#### Foo.getName();

函数 `Foo` 本身并没有执行，执行的是函数的属性 `getName`，输出的是 `2`

#### getName();

这是在全局执行 `getName()`，根据我们上面的分析可知，输出的结果是 `4`

#### Foo().getName(); 

因为 () 的优先级最高（见 [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)），所以首先运行 `Foo()`，全局的 `getName` 被覆盖成输出 `console.log('1')`，并且返回的 `this` 此时代表的是 `window`

也就是相当于执行了 `window.getName()`，所以输出的结果为 `1`

#### getName();

这个因为之前调用了 `Foo()`，所以输出的结果仍然是 `1`

#### new Foo.getName();

因为 `.` 操作符要比 `new` 优先级要高，所以执行的是 `new (Foo.getName)()`，所以输出为 `2`

#### new Foo().getName();

根据优先级可知，带参数的 `new` 操作符是优先级最高的，所以执行的就是 `(new Foo()).getName()`

而 `new Foo()` 生成的对象身上没有 `getName()` 的方法，那么就会去 `prototype` 当中寻找，所以输出的是 `3`

#### new new Foo().getName();

老规矩，按照优先级添加括号，首先带参数的 `new` 操作符优先级最高，则为 `new (new Foo().getName())`

然后就会发现和上面是类似的，可以转换为 `new ((new Foo()).getName())`，所以输出的也为 `3`





## JavaScript 中的数据绑定

关于数据双向绑定，绑定的基础就是监听属性的变化事件（`propertyChange`），现在主流的框架当中的解决方法一般有以下几种

* `Knockout` / `Backbone`（发布/订阅模式），简单来说就是另外开发一套 `API`，但使用起来却不得不使用这套 `API` 来操作 `viewModel`，导致上手复杂、代码繁琐

* `Angular`（脏检查机制），特点是直接使用原生 `JavaScript` 来操作 `viewModel`，但脏检查机制随之带来的就是性能问题

* `Vue`（数据劫持，也就是 `Object.defineProperty`），会把定义的 viewModel 对象（即 `data` 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 `JavaScript` 操作对象，又可以主动触发 `propertyChange` 事件，效率虽高，但也有一些限制，见后文

另外的几种方式

* `Object.observe`，谷歌对于简化双向绑定机制的尝试，在 `Chrome 49` 中引入，然而由于性能等问题，并没有被其他各大浏览器及 `ES` 标准所接受，所以在后续版本当中移除了该方法的实现

* `Proxy`，是 `ES6` 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 `Object.observe` 以实现双向绑定）



#### 基于数据劫持实现的双向绑定

#### 什么是数据劫持

数据劫持比较好理解，通常我们利用 `Object.defineProperty` 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作

```js
// 这是将要被劫持的对象
const data = {
  name: '',
};

// 测试函数
function test(name) {
  console.log(name);
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function (key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      console.log(`get`);
    },
    set: function (newValue) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`set`);
      test(newValue);
    },
  });
});

data.name = `new name`;
```

#### 数据劫持的优势以及实现思路

目前业界分为两个大的流派，一个是以 `React` 为首的单向数据绑定，另一个是以 `Angular`、`Vue` 为主的双向数据绑定

两者主要有两点区别

* 无需显示调用，例如 `Vue` 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 `Angular` 的脏检测或是 `react` 需要显示调用 `setState`

* 可精确得知变化数据：例如上面的例子，我们劫持了属性的 `setter`，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 `diff` 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 `diff` 来找出变化值，这是额外性能损耗

本质上，基于数据劫持的双向绑定离不开 `Proxy` 与 `Object.defineProperty` 等方法对对象/对象属性的"劫持"，我们要实现一个完整的双向绑定需要以下几个要点

* 利用 `Proxy` 或 `Object.defineProperty` 生成的 `Observer` 针对对象/对象的属性进行"劫持"，在属性发生变化后通知订阅者

* 解析器 `Compile` 解析模板中的 `Directive`（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染

* `Watcher` 属于 `Observer` 和 `Compile` 桥梁，它将接收到的 `Observer` 产生的数据变化，并根据 `Compile` 提供的指令进行视图渲染，使得数据变化促使视图变化

![IMG](双向数据绑定.png)



#### 基于 Object.defineProperty 双向绑定

完整的实现可以见 [剖析Vue原理&实现双向绑定MVVM](https://segmentfault.com/a/1190000006599500)，比如上面的示例，就是一个简单的实现

但是很快就会发现，里面存在着一堆问题，比如我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等

我们可以参考 `Vue` 的实现方式，`Vue` 的操作就是加入了发布订阅模式，结合 `Object.defineProperty` 的劫持能力，实现了可用性很高的双向绑定

下面是一个完成的例子


```html
<main>
  <p>请输入:</p>
  <input type="text" id="input">
  <p id="p"></p>
</main>
```


```js
// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它
const Vue = (function() {

  let uid = 0;

  // 用于储存订阅者并发布消息
  class Dep {

    constructor() {
      // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher
      this.id = uid++;
      // 储存订阅者的数组
      this.subs = [];
    }

    // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身
    depend() {
      Dep.target.addDep(this);
    }

    // 添加订阅者
    addSub(sub) {
      this.subs.push(sub);
    }

    notify() {
      // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理
      this.subs.forEach(sub => sub.update());
    }
  }

  // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher
  Dep.target = null;
  
  // 现在我们需要实现监听者（Observer），用于监听属性值的变化
  // 监听者，监听对象属性值的变化
  class Observer {

    constructor(value) {
      this.value = value;
      this.walk(value);
    }

    // 遍历属性值并监听
    walk(value) {
      Object.keys(value).forEach(key => this.convert(key, value[key]));
    }

    // 执行监听的具体方法
    convert(key, val) {
      defineReactive(this.value, key, val);
    }

  }

  function defineReactive(obj, key, val) {

    const dep = new Dep();

    // 给当前属性的值添加监听

    let chlidOb = observe(val);
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () => {
        // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中
        // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者
        // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法
        if (Dep.target) {
          dep.depend();
        }
        return val;
      },
      set: newVal => {
        if (val === newVal) return;
        val = newVal;
        // 对新值进行监听
        chlidOb = observe(newVal);
        // 通知所有订阅者，数值被改变了
        dep.notify();
      },
    });
  }

  function observe(value) {
    // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听
    if (!value || typeof value !== 'object') {
      return;
    }
    return new Observer(value);
  }



  // 我们还需要实现一个订阅者（Watcher）
  class Watcher {

    constructor(vm, expOrFn, cb) {
      this.depIds = {}; // hash 储存订阅者的 id，避免重复的订阅者
      this.vm = vm;     // 被订阅的数据一定来自于当前 Vue 实例
      this.cb = cb;     // 当数据更新时想要做的事情
      this.expOrFn = expOrFn; // 被订阅的数据
      this.val = this.get();  // 维护更新之前的数据
    }

    // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用
    update() {
      this.run();
    }

    addDep(dep) {
      // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存
      // 此判断是避免同 id 的 Watcher 被多次储存
      if (!this.depIds.hasOwnProperty(dep.id)) {
        dep.addSub(this);
        this.depIds[dep.id] = dep;
      }
    }

    run() {
      const val = this.get();
      console.log(val);
      if (val !== this.val) {
        this.val = val;
        this.cb.call(this.vm, val);
      }
    }

    get() {
      // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者
      Dep.target = this;
      const val = this.vm._data[this.expOrFn];
      // 置空，用于下一个 Watcher 使用
      Dep.target = null;
      console.log(Dep.target, 2);
      return val;
    }
  }

  
  // 将上述方法挂载在 Vue 上
  class Vue {

    constructor(options = {}) {
      // 简化了 $options 的处理
      this.$options = options;
      // 简化了对 data 的处理
      let data = (this._data = this.$options.data);
      // 将所有 data 最外层属性代理到 Vue 实例上
      Object.keys(data).forEach(key => this._proxy(key));
      // 监听数据
      observe(data);
    }

    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者
    $watch(expOrFn, cb) {
      new Watcher(this, expOrFn, cb);
    }

    _proxy(key) {
      Object.defineProperty(this, key, {
        configurable: true,
        enumerable: true,
        get: () => this._data[key],
        set: val => {
          this._data[key] = val;
        },
      });
    }

  }

  return Vue;
})();


// 使用
let demo = new Vue({
  data: {
    text: '',
  },
});

const p = document.getElementById('p');
const input = document.getElementById('input');

input.addEventListener('keyup', function(e) {
  demo.text = e.target.value;
});

demo.$watch('text', str => p.innerHTML = str);
```


#### Object.defineProperty 的缺陷

其实我们升级版的双向绑定依然存在漏洞,比如我们将属性值改为数组

```js
let demo = new Vue({
  data: {
    list: [1],
  },
});

const list = document.getElementById('list');
const btn = document.getElementById('btn');

btn.addEventListener('click', function () {
  demo.list.push(1);
});

const render = arr => {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < arr.length; i++) {
    const li = document.createElement('li');
    li.textContent = arr[i];
    fragment.appendChild(li);
  }
  list.appendChild(fragment);
};

// 监听数组，每次数组变化则触发渲染函数，然而却无法监听
demo.$watch('list', list => render(list));

setTimeout(
  function () {
    alert(demo.list);
  },
  5000,
);
```

是的，`Object.defineProperty` 的第一个缺陷，无法监听数组变化，然而 `Vue` 的文档提到了 `Vue` 是可以检测到数组变化的

其实简单来说，这里就是重写了原来的方法

```js
const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
const arrayAugmentations = [];

aryMethods.forEach((method) => {

  // 这里是原生 Array 的原型方法
  let original = Array.prototype[method];

  // 将 push, pop 等封装好的方法定义在对象 arrayAugmentations 的属性上
  // 注意：是属性而非原型属性
  arrayAugmentations[method] = function () {
    console.log('我被改变啦!');
    // 调用对应的原生方法并返回结果
    return original.apply(this, arguments);
  };

});

let list = ['a', 'b', 'c'];

// 将我们要监听的数组的原型指针指向上面定义的空数组对象
// 别忘了这个空数组的属性上定义了我们封装好的 push 等方法
list.__proto__ = arrayAugmentations;
list.push('d');  // 我被改变啦！ 4

// 这里的 list2 没有被重新定义原型指针，所以就正常输出
let list2 = ['a', 'b', 'c'];
list2.push('d');  // 4
```

由于只针对了八种方法进行了 `hack`，所以其他数组的属性也是检测不到的

我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 `Object.defineProperty` 的第二个缺陷，只能劫持对象的属性

因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是更好的选择

```js
Object.keys(value).forEach(key => this.convert(key, value[key]));
```



#### Proxy 实现的双向绑定

`Proxy` 在 `ES2015` 规范中被正式发布，它在目标对象之前架设一层"拦截"，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写

我们可以这样认为 `Proxy` 是 `Object.defineProperty` 的全方位加强版

`Proxy` 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 `Object.defineProperty`


#### Proxy 可以直接监听数组的变化

当我们对数组进行操作（`push`、`shift`、`splice` 等）时，会触发对应的方法名称和 `length` 的变化

下面是一个实例

```html
<main>
  <ul id="list">
  </ul>
  <button type="button" name="button" id="btn">添加列表项</button>
</main>
```

```js
const list = document.getElementById('list');
const btn = document.getElementById('btn');

// 渲染列表
const Render = {

  // 初始化
  init: function(arr) {
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < arr.length; i++) {
      const li = document.createElement('li');
      li.textContent = arr[i];
      fragment.appendChild(li);
    }
    list.appendChild(fragment);
  },

  // 我们只考虑了增加的情况，仅作为示例
  change: function(val) {
    const li = document.createElement('li');
    li.textContent = val;
    list.appendChild(li);
  },
};

// 初始数组
const arr = [1, 2, 3, 4];

// 监听数组
const newArr = new Proxy(arr, {
  get: function(target, key, receiver) {
    console.log(key);
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, value, receiver) {
    console.log(target, key, value, receiver);
    if (key !== 'length') {
      Render.change(value);
    }
    return Reflect.set(target, key, value, receiver);
  },
});

// 初始化
window.onload = function() {
  Render.init(arr);
}

// push 数字
btn.addEventListener('click', function() {
  newArr.push(6);
});
```

#### Proxy的优势

`Proxy` 有多种拦截方法，不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等，是 `Object.defineProperty` 不具备的

`Proxy` 返回的是一个新对象，我们可以只操作新的对象达到目的，而 `Object.defineProperty` 只能遍历对象属性直接修改



## 原型和闭包

主要参考 [深入理解javascript原型和闭包](http://www.cnblogs.com/wangfupeng1988/p/3977987.html)

#### 对象 - 若干属性的集合

```js
// 简单的值类型，不是对象
console.log(typeof x);                 // undefined
console.log(typeof 10);                // number
console.log(typeof 'abc');             // string
console.log(typeof true);              // boolean

// 函数其实也是对象，也是可以做为参数传递的
console.log(typeof function () { });   //function

// 引用类型
console.log(typeof [1, 'a', true]);    //object
console.log(typeof { a: 10, b: 20 });  //object
console.log(typeof null);              //object
console.log(typeof new Number(10));    //object
```

判断一个变量是不是对象，值类型的类型判断用 `typeof`，引用类型的类型判断用 `instanceof`


#### 函数和对象的关系

对象是可以通过函数来创建

```js
//var obj = { a: 10, b: 20 };
//var arr = [5, 'x', true];

var obj = new Object();
obj.a = 10;
obj.b = 20;

var arr = new Array();
arr[0] = 5;
arr[1] = 'x';
arr[2] = true;
```

#### prototype

每个函数都有一个属性叫做 `prorotype`，这个 `prototype` 的属性值是一个对象（属性的集合），默认的还有一个叫做 `constructor` 的属性，指向这个函数本身

![prototype01](http://images.cnitblog.com/blog/138012/201409/172121182841896.png)

例如 `Object` 的 `prototype` 上就挂载了一系列方法

![prototype02](http://images.cnitblog.com/blog/138012/201409/172130097842386.png)

我们也可以在自己自定义的方法的 `prototype` 中新增自己的属性

```js
function Foo () {...}

Foo.prototype.name = ..

Foo.prototype.getName = function () {..}

var bar = new Foo();
console.log(bar.name);
console.log(bar.getName());
```

`Foo` 是一个函数，`bar` 对象是通过 `Foo` 函数 `new` 出来的，这样一来，`bar` 对象就可以调用 `Foo.prototype` 上的属性和方法

因为每个对象都有一个隐藏的属性 `__proto__`（一般称为 隐式原型），这个属性引用了创建这个对象的函数的 `prototype`，即

```js
bar.__proto__ === Foo.prototype  // true
```

#### instanceof

对于值类型可以使用 `typeof` 判断，但是对于引用类型的时候，返回值只有 `object/function`，这个时候就可以使用 `instanceof`

![instanceof](http://images.cnitblog.com/blog/138012/201409/181635468939277.png)

比如判断 `f1 instanceof Object`，按照上图来说就是：

* 沿着 `f1` 的 `__proto__` 这条线来找，同时沿着 `Object` 的 `prototype` 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回 `true`，如果找到终点还未重合，则返回 `false`

这也解释了为何一下结果均返回 `true`

```js
Object instanceof Function;    // true

Function instanceof Object;    // true

Function instanceof Function;  // true
```

完整原型图如下所示：

![原型链](http://images.cnitblog.com/blog/138012/201409/181637013624694.png)

* `instanceof` 表示的就是一种继承关系，或者原型链的结构

一个小小的练习题：

```js
var a = {
  x: 1,
  y: { z: 2 }
};

var b = {};
b.__proto__ = a;

// a 和 b 都是对象（通过new Object() 生成，这里是简写）
// 所以 a.__proto__ === b.__proto__ 是相等的（都是指向 Object.prototype）
// 所以在查找 b.x 的时候先去 b 查看，发现是空对象（{}），原则上应该去 Object.prototype 上查找 
// 但是现在把 b.__proto__ 从新指回了 a，所以应该就去 a 上查找
// 所以 b.x 为 1，b.y 为 { z: 2 }
console.log(a.x);
console.log(b.x);

// 然后把 b.x 重新赋值为 22
// 因为是基本类型，所以 a.x 是不变的
b.x = 22;
console.log(a.x);
console.log(b.x);

// 这个同上面那个类似
// 但是由于是引用类型，所以 a.y 和 b.y 指向的都是同一个地址
// 其中一个变化的话自然会引起另外一个变化
b.y.z = 33;
console.log(a.y.z);
console.log(b.y.z);
```


#### 继承

访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 `__proto__` 这条链往上找，这就是原型链

可以利用 `hasOwnProperty` 来区分一个属性是不是从原型上继承得到的（特别是在 `for..in` 循环中）

`hasOwnProperty` 这个方法存在与 `Object.prototype` 上，对象的原型链是沿着 `__proto__` 这条线走的，因此在查找对象的 `hasOwnProperty` 属性的时候，就会顺着原型链一直查找到 `Object.prototype`

由于所有的对象的原型链都会找到 `Object.prototype`，因此所有的对象都会有 `Object.prototype` 的方法，这就是所谓的**继承**

同样的，每个函数都有 `call`，`apply` 方法，这也是"继承"而来的，函数由 `Function` 函数构建，因此继承的 `Function.prototype` 中的方法

至于为什么 `Function.prototype` 上也会有 `hasOwnProperty` 方法，这是因为 `Function.prototype` 同样继承自 `Object.prorotype`




#### 执行上下文环境

简单来说，函数**每被**调用一次，都会产生一个新的执行上下文环境，因为不同的调用可能就会有不同的参数

需要注意一点：函数体内部自由变量在函数在定义的时候（不是调用的时候）就已经确定了

`javascript` 在执行一个代码段之前，都会进行这些 "准备工作" 来生成执行上下文，其实分三种情况 -- 全局代码，函数体，`eval` 代码（不推荐这个）


#### 全局执行上下文环境

在产生执行全局上下文时，浏览器通常会做以下三个准备工作：

* 提取 `var` 声明的变量，并赋值（默认）为 `undefined`（变量提升）

* 提取声明式函数（`function foo () {..}`）

* 给 `this` 赋值（指向 `window` 或当前对象）


#### 函数体上下文环境（也就是所谓的局部）

会在以上三个的基础上增加以下三条：

* 给函数参数赋值

* 给 `arguments` 赋值（是一个实参副本，与实参保持一致）

* 自由变量的取值作用域，查找并赋值

所以总结来说就是，**在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用 undefined 占个空**

而在执行 `js` 代码时，会有数不清的函数调用次数，会产生许多个上下文环境，这么多上下文环境该如何管理，以及如何销毁而释放内存就主要依靠下面的**执行上下文栈**

#### 执行上下文栈

执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境，当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境

处于活动状态的执行上下文环境只有一个

其实这是一个 **压栈** ==> **出栈** 的过程，如下图所示：

* 压栈：函数未调用时只有全局上下文在执行，每次调用函数时会产生局部上下文，这就是压栈，也就是进栈

* 出栈：函数调用完成后，就会出栈，会销毁本次调用的局部上下文环境

注意：若函数里面是多层函数嵌套，也会出现多层执行上下文的嵌套（压栈和出栈也是嵌套产生的）

![执行上下文栈](http://images.cnitblog.com/blog/138012/201409/232122300768665.png)

上面这种只是较为理想的情况，有一种情况无法做到这样干净利落的说销毁就销毁，这个就是 -- 闭包


#### this

`this` 是 `Javascript` 语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用

随着函数使用场合的不同，`this` 的值会发生变化，但是有一个总的原则，那就是 `this` 指的是，调用函数的那个对象

`JavaScript` 中函数的调用有以下几种方式：

* 为对象方法调用

* 作为函数调用

* 作为构造函数调用

* 使用 `apply` 或 `call` 调用

一个小案例，在 `jQuery` 中，有下面这样一段代码：

```js
jQuery.extend = jQuery.fn.extend = function () {
  // ...
  if (i === length) {
    target = this;
    i--;
  }
  // ...
}
```

`jQuery.extend` 和 `jQuery.fn.extend` 都指向了同一个函数，但是当执行时，函数中的 `this` 是不一样的

执行 `jQuery.extend( .. )` 时，this 指向 `jQuery`

执行 `jQuery.fn.extend( .. )` 时，this 指向 `jQuery.fn`

这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则


#### 作用域

`javascript` 中没有块级作用域（`ES6` 之前），除了全局作用域以外，只有函数可以创建作用域

我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好（先声明，在使用），除了这两个地方，其他地方都不要出现变量声明

作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的

作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突

除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数**定义时**就已经确定了，而不是在函数**调用时**确定

抽象来看待的话，作用域只是一个 "地盘"，其中没有变量，要通过**作用域对应的执行上下文环境**来获取变量的值

同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了

所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值

## 自由变量 到 作用域链

所谓自由变量，指的是在当前作用域中未声明的变量，会去到**创建这个函数的作用域中去取值，而不是简简单单的上一级（注意，是创建，不是调用）**，这就是所谓的静态作用域

```js
var x = 100;

function foo() {
  console.log(x);
}

function bar(fn) {
  var x = 200;

  (function () {
    fn();  // 100
  })()
}

bar(foo);
```

如果没有找到，则继续往上找，一直到全局作用域为止，如果还没有找到，那就是不存在了，这个过程可以称之为**作用域链**


#### 上下文环境和作用域的关系

* 上下文环境：可以理解为一个抽象的东西，程序执行前，会生成全局上下文环境，函数在调用的时候会创建函数上下文环境

* 作用域：**除了全局作用域，只有函数才能创建作用域（ES6 之前）**，创建一个函数就创建了一个作用域，无论你调不调用，函数只要创建了，它就有独立的作用域

* 两者的区别在于：一个作用域可能没有（函数没被调用），也可能存在过（调用完成，上下文环境被摧毁），也有可能同时存在多个（闭包）上下文环境

一个简单的小例子：

```js
var x = 100;

function fn (x) {
    return function () {
        console.log(x);
    }
}

var f1 = fn(5);
var f2 = fn(10);

f1();  // 5
f2();  // 10
```





## 闭包

只需要记住应用的两种情况即可

#### 第一种 函数作为返回值

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

`bar` 函数作为返回值，赋值给 `f1` 变量，执行 `f1(15)` 时，用到了 `fn` 作用域下的 `max` 变量的值

#### 第二种 函数作为参数传递

```js
var max = 10,
  fn = function (x) {
    if (x > max) {
      console.log(x)
    }
  };

(function (f) {
  var max = 100;
  f(11);  // 11
})(fn)
```

`fn` 作为一个参数传递进入另一个函数，赋值给 `f` 参数，执行 `f(11)` 的时候，`max` 取值是 `10`，而不是 `100`

之前提到过，当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁，但是在有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁，这里指的就是闭包，以上面第一种代码为例

```js
function fn() {
  var max = 10;

  return function bar(x) {
    if (x < max) {
      console.log(x)
    }
  }
}

var f1 = fn();
var max = 100;
f1(5);  // 5
```

* 代码执行前的全局上下文环境，并在执行时对其中的变量进行赋值，此时全局上下文环境（活动状态）中的 `max` 为 `undefined`

* 当调用 `fn()` 时会产生 `fn()` 执行上下文环境（活动状态），此时 全局中的 `max` 仍为 `undefined`，`fn()` 上下文环境中的 `max` 为 `10`

* 当 `fn()` 调用完成，按理说应该销毁掉 `fn()` 的执行上下文环境，但是**返回的是一个函数，函数的特别之处在于可以创建一个独立的作用域**

  * 而返回的这个函数体中，还有一个自由变量 `max` 要引用 `fn` 作用域下的 `fn()` 上下文环境中的 `max`

  * 因此，这个 `max` 不能被销毁，销毁了之后 `bar` 函数中的 `max` 就找不到值了

  * 所以这里的 `fn()` 上下文环境不能被销毁，还依然存在与执行上下文栈中

* 当执行到 ```var max = 100``` 的时候，`fn()` 上下文环境依然会在执行上下文栈中，当执行完成后，全局中的 `max` 为 `100`，而 `fn()` 上下文环境中的 `max` 仍为 `10`

* 当执行最后的 `f1(5)` 的时候，即执行返回的函数 `bar(5)`，此时，`bar()` 上下文环境中的 `x` 为 `5`，而 `max` 变量是自由变量，需要向创建 `bar` 函数的作用域中查找，找到了 `max` 的值为 `10`

这里的重点就在于，创建 `bar` 函数是在执行 `fn()` 时创建的，`fn()` 早就执行结束了，但是 `fn()` 执行上下文环境还存在与栈中，因此 `bar(5)` 时，`max` 可以查找到，如果 `fn()` 上下文环境销毁了，那么 `max` 就找不到了，这也是为什么使用闭包会增加内容开销





## ES6 的一些新方法

#### let 命令

* 只要块级作用域内存在 `let` 命令，它所声明的变量就 "绑定"（`binding`）这个区域，不再受外部的影响

* `typeof` 不再是一个百分比安全的操作（如果一个变量根本没有被声明，使用 `typeof` 反而不会报错）

* `function bar(x = y, y = 2) {}` （`y` 没有声明，所以会报错）

* 不允许重复声明

* 块级作用域的出现，使得立即执行函数表达式（`IIFE`）不再必要了

* 建议避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句

* 允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错

* 在 `ES6` 浏览器中（只对 `ES6` 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 `let` 处理）

 * 允许在块级作用域内声明函数

 * 函数声明类似于 `var`，即会提升到全局作用域或函数作用域的头部

 * 同时，函数声明还会提升到所在的块级作用域的头部

```js
// 不报错
"use strict";
if (true) {
  function f() { }
}

// 报错
"use strict";
if (true)
  function f() { }
```




#### const 命令

* 声明一个只读常量，一旦声明，常量的值就不能改变，而且必须立即初始化，不能留到以后在赋值

* `const foo = {};`

 * 常量 `foo` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 `foo` 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

* 与 `let` 命令相似之处：

 * 只能在声明所在的块级作用域内有效

 * 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用

 * 不可重复声明



#### 字符串的扩展

* 添加了遍历器接口，使得字符串可以被 `for...of` 循环遍历

* 添加了三个用于查询字符串位置的函数：

 * `includes()`： 返回布尔值，表示是否找到了参数字符串

 * `startsWith()`： 返回布尔值，表示参数字符串是否在源字符串的头部

 * `endsWith()`： 返回布尔值，表示参数字符串是否在源字符串的尾部

以上三个方法都支持第二个参数，表示开始搜索的位置，不同之处在于 `endsWith` 针对前 `n` 个字符，而其他两个方法针对从第 `n` 个位置直到字符串结束。

* `repeat()` 方法返回一个新字符串，表示将原字符串重复 `n` 次

 * 如果是小数，则会被取整（`2.2 => 2`, `2.9 => 2`）

 * 如果是负数（小于-1）或者 `Infinity`，则会报错

 * 如果是 `0` 到 `-1` 之间的小数，则等同于 `0`，因为会先进行取整运算（`NaN` 也等同于 `0`）

 * 如果参数是字符串，则会先转换为数字（`"3" => 3`, `"na" => ""`）

* 新增了模版字符串

```js
$("#result").append(`
    There are <b> ${basket.count} </b> items
    in your basket, <em> ${basket.onSale} </em>
    are on sale!`
);
```

 * 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义（``\`Hello\` World!``）

 * 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中

 * 如果想去掉模版字符串开头和结尾处的换行，可以使用 `trim` 方法消除它

 * 如果大括号内部是一个字符串，将会原样输出（`Hello ${"World}` => "Hello World"）

 * 模板字符串中也可以嵌入变量以及调用函数，比如 `${user.name}`，`${fn()}`




#### 对象的扩展

* 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = "bar";
var baz = {foo};
baz;  // {foo: "bar"}
```

* 方法也可以简写 `method () {return "hello"}`

* 可以用于函数的返回值：

```js
function getPoint () {
  var x = 1;
  var y = 2;
  return {x, y};
}

getPoint();  // {x: 1, y: 2}
```

* 新增属性名表达式 `obj["a" + "bc"] = 123;`

 * 表达式也可以用于定义方法名

* 属性名表达式与简洁表示法，不能同时使用，否则会报错

* 特别注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 `[object, Object]`

```js
const myObject = {
  [keyA]: "valueA",
  [keyB]: "valueB"
};

// [keyB] 会把 [keyA] 覆盖掉，而 myObject 最后只有一个 [object Object] 属性
```



#### 数值的扩展

* `parseInt()` 和 `parseFloat()` 移植到了 `Number` 对象上面 （`Number.parseInt("1*34")  // 12`）

* `Number.isInteger()` 用来判断一个值是否为整数（在 `JavaScript` 内部，整数和浮点数是同样的储存方法，所以 `3` 和 `3.0` 被视为同一个值）

`Math` 对象扩展：

* `Math.trunc()` 方法用于去除一个数的小数部分，返回整数部分

 * 对于非数值，内部会先使用 `Number` 方法将其先转为数值

 * 对于空值和无法截取整数的值，返回 `NaN`

* `Math.sign()` 方法用来判断一个数到底是正数，负数，还是零，会返回五种值：

 * 参数为正数，返回 `+1`

 * 参数为负数，返回 `-1`

 * 参数为 `0`，返回 `0`

 * 参数为 `-0`，返回 `-0`

 * 其他值，返回 `NaN`

* `Math.cbrt()` 方法用于计算一个数的立方根

* `Math.hypot()` 返回所有参数的 平方和 的 平方根 

```js 
Math.hypot(3, 4);  // 5（3 的平方 + 4 的平方 等于 5 的平方）
```




#### 数组的扩展

* `Array.from()` 将 类似数组的对象（`array-like-object`） 和 可遍历（`iterable`）的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）转为 **真正的数组**

 * 接受的第二个参数，作用类似于数组的 `map` 方法，用来对每个元素进行处理，将处理后的结果放入返回的数组

 * 如果 `Array.from()` 没有参数，就返回一个**空数组**

* `Array.of()` 用于将一组值，转换为数组（因为在 `ES5` 中，参数个数的不同，会导致 `Array()` 的行为有差异）

* `find()` 方法，用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 `true` 的成员，并返回，如果没有找到符合条件的成员，则返回 `undefined`

 * 回调函数可以接受三个参数，依次为 当前的值、当前的位置 和 原数组

* `findIndex()` 方法的用法与 `find()` 方法非常相似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 `-1`

 * `find()` 方法和 `findIndex()` 方法都可以发现 `NaN`，弥补了数组的 `indexOf` 方法的不足

* `fill()` 方法使用给定值，填充一个数组

 * 需要注意的是，数组中已有的元素，会被全部抹去

 * 可以指定第二个和第三个参数，用于指定填充的起始位置和结束位置

* 提供了三个新的方法来用于遍历数组，它们都返回一个遍历器对象，可以用 `for...of` 循环进行遍历（如果不使用 `for...of` 循环，可以手动调用遍历器对象的 `next()` 方法，进行遍历）

 * `keys()` 是对**键名**的遍历

 * `values()` 是对**键值**的遍历

 * `entries()` 是对**键值对**的遍历

* `Array.prototype.includes` 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 `includes` 方法类似

 * 第二个参数表示搜索的起始位置，默认为 `0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 `-4`，但数组长度为 `3`），则会重置为从 `0` 开始

`Map` 和 `Set` 数据结构有一个 `has` 方法，需要注意与 `includes` 区分

* `Map` 结构的 `has` 方法，是用来查找**键名**的，比如 `Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`

* `Set` 结构的 `has` 方法，是用来查找**值**的，比如 `Set.prototype.has(value)`、`WeakSet.prototype.has(value)`





#### 解构

```js
// 属于"模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值
var [a, b, c] = [1, 2, 3]
```

* 如果解构不成功，变量的值就等于 `undefined`

* 如果等号右边不是数组（不是可遍历的解构，不具有 `Iterator` 接口），那么将会报错（`number`，`string`，`false`，`NaN`，`undefined`，`null`，`{ }` 等）

* 只要某种数据具有 `Iterator` 接口，都可以采用数组形式的解构赋值

* 解构赋值允许指定默认值（内部使用的是严格相等运算符 `===`）

* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明

* 对象的解构

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" }
```

* 对象的属性没有次序，变量必须与属性同名，才能取到正确的值

```js
let foo;
({ foo } = { foo: 1 }); // success

let baz;
({ bar: baz } = { bar: 1 }); // success
```

上例中的圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句




#### 字符串的解构

字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象



#### 数值和布尔值的解构

解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象

规则是，只要等号右边的值不是对象，就先将其转为对象，由于 `undefined` 和 `null` 无法转为对象，所以对它们进行解构赋值，都会报错



#### 函数相关

* 在 `ES6` 中，允许函数的参数设置默认值，即直接写在参数定义的后面（函数参数的默认值）

 * 参数变量是默认声明的，所以不能使用 `let` 或者 `const` 再次声明

 * 指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值以后，`length` 属性将失效（length属性的含义是，该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了）

* 如果设置了默认值的参数不是尾参数（即设置默认值的不是最后一个参数），那么 `length` 属性也不再计入后面的参数了

* 如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域

* 用于将一个数组转为用都好分隔的参数序列（`console.log(...[1, 2, 3])`）

* 在 ES5 中，如果将一个匿名函数赋值给一个变量，其 `name` 属性，会返回空字符串，而 ES6 中修正了这个问题，会返回实际的函数名

 * `Function` 构造函数返回的函数实例，`name` 属性的值为 `anonymous`

 * `bind` 返回的函数，`name` 属性会加上 `bound` 前缀

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 `return` 语句返回

```js
var sum = (num1, num2) => { return num1 + num2; }
```

* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号

```js
var getTempItem = id => ({ id: id, name: "Temp" });
```

* 箭头函数的使用注意点

 * 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象（例如在 `Vue` 的实例属性或回调函数中就不建议使用箭头函数，因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是对应方法未被定义）

 * 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误

 * 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `Rest` 参数代替

 * 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数

 * 需要特别注意的是：`this` 对象的指向是可变的，但是在箭头函数中，它是固定的

 * 箭头函数中的 `this` 指向的固定化，并不是因为箭头函数内部有绑定 `this` 的机制，实际原因是箭头函数根本没有自己的 `this`，导致内部的 `this` 就是外层代码块的 `this`（正式因为它没有 `this`，所以也就不能用作构造函数）



#### Symbol

`ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值，它是 `JavaScript` 第七种数据类型

```js
// 变量 s 就是一个独一无二的值
let s = Symbol();

// typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型
typeof s
// "symbol"
```



## 变量的赋值与深浅拷贝

#### JavaScript 中变量的赋值

在 `JavaScript` 中，变量的赋值分为 「传值」 与 「传址」

给变量赋予基本数据类型的值，也就是「传值」，而给变量赋予引用数据类型的值，实际上是「传址」

基本数据类型变量的赋值、比较，只是值的赋值与比较，即栈内存中的数据的拷贝和比较

```js
var num1 = 123;
var num2 = 123;
var num3 = num1;

num1 === num2;  // true
num1 === num3;  // true

num1 = 456;
num1 === num2;  // false
num1 === num3;  // false
```

引用数据类型变量的赋值、比较，只是存于栈内存中的堆内存地址的拷贝、比较

```js
var arr1 = [1, 2, 3];
var arr2 = [1, 2, 3];
var arr3 = arr1;

arr1 === arr2;  // false
arr1 === arr3;  // true

arr3 = [1, 2, 3];
arr1 === arr3;  // false
arr2 === arr3;  // false
```


#### JavaScript 中变量的拷贝

拷贝分为浅拷贝和深拷贝

#### 浅拷贝

浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性

对于目标对象第一层为基本类型的数据，就是直接赋值，即「传值」

而对于目标对象第一层为引用数据类型的数据，就是直接赋与内存中的堆内存地址，即「传址」



#### 深拷贝

深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性

一般来说，在 `JavaScript` 中考虑复合类型的深层复制的时候，往往就是指对于 `Date`，`Object` 和 `Array` 三个复合类型的处

一般简单的处理方式是建立一个新的空对象，然后递归遍历旧的的对象，直到发现基础类型的子节点才赋予到新对象对应的位置

不过这个方法存在一个问题，就是 `JavaScript` 中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后需要考虑原型应不应该被赋予给新对象

一般在使用过程中，我们通常会使用 `hasOwnProperty` 方法来进行判断是否过滤掉那些继承自原型链上的属性


#### 实现

```js
function _isPlainObject(target) {
  return (typeof target === 'object' && !!target && !Array.isArray(target));
}

function shallowExtend() {

  var args = Array.prototype.slice.call(arguments);
  // 第一个参数作为 target
  var target = args[0];
  var src;
  target = _isPlainObject(target) ? target : {};

  for (var i = 1; i < args.length; i++) {
    src = args[i];
    if (!_isPlainObject(src)) {
      continue;
    }
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        if (src[key] != undefined) {
          target[key] = src[key];
        }
      }
    }
  }
  return target;
}

var target = {
  key: 'value',
  num: 1,
  bool: false,
  arr: [1, 2, 3],
  obj: {
    objKey: 'objValue'
  },
};

var result = shallowExtend({}, target, {
  key: 'changeValue',
  num: 2
})

// 对原引用类型数据做修改
target.arr.push(4);

console.log(target.arr === result.arr)  // true
console.log(result)

// {
//   key: 'changeValue',
//   num: 2,
//   bool: false,
//   arr: [1, 2, 3, 4],
//   obj: {
//     objKey: 'objValue'
//   },
// }
```


#### jQuery 中的 extend 的实现

先来看看怎么使用

```js
$.extend( target [, object1 ] [, objectN ] )

// 可以添加参数来指示是否深度合并
$.extend( [deep ], target, object1 [, objectN ] )
```

> 需要注意的是，第一个参数不支持传递 `false`

取值 | 解释
---- | ----
`deep` | 可选，`Boolean` 类型 指示是否深度合并对象，默认为 `false`，如果该值为 `true`，且多个对象的某个同名属性也都是对象，则该"属性对象"的属性也将进行合并
`target` | `Object` 类型 目标对象，其他对象的成员属性将被附加到该对象上
`object1` | 可选，`Object` 类型 第一个被合并的对象
`objectN` | 可选，`Object` 类型 第N个被合并的对象

简单来说，该方法的作用是用一个或多个其他对象来扩展一个对象，返回扩展后的对象

如果不指定 `target`，则是给 `jQuery` 命名空间本身进行扩展（有利于为 `jQuery` 增加新方法）

如果第一个参数设置为 `true`，则 `jQuery` 返回一个深层次的副本，递归的复制找到的任何对象，否则的话副本会与原对象共享结构

**未定义的属性不会被复制，然而从对象的原型继承的属性将会被复制**

源码如下
```js
// 版本为 3.31
jQuery.extend = jQuery.fn.extend = function () {
  var options,
    name,
    src,
    copy,
    copyIsArray,
    clone,
    target = arguments[0] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // 如果第一个参数是布尔值，则为判断是否深拷贝的标志变量
  if (typeof target === "boolean") {
    deep = target;
    // 跳过 deep 标志变量，留意上面 i 的初始值为1
    target = arguments[i] || {};
    // i 自增1
    i++;
  }

  // 判断 target 是否为 object / array / function 以外的类型变量
  if (typeof target !== "object" && !isFunction(target)) {
    // 如果是其它类型变量，则强制重新赋值为新的空对象
    target = {};
  }

  // 如果只传入 1 个参数，或者是传入 2 个参数，第一个参数为 deep 变量，第二个为 target
  // 所以 length 的值可能为 1 或 2，但无论是 1 或 2，下段 for 循环只会运行一次
  if (i === length) {
    // 将 jQuery 本身赋值给 target
    target = this;
    // i 自减1，可能的值为 0 或 1
    i--;
  }

  for (; i < length; i++) {
    // 以下拷贝操作，只针对非 null 或 undefined 的 arguments[i] 进行
    if ((options = arguments[i]) != null) {
      // Extend the base object
      for (name in options) {
        src = target[name];
        copy = options[name];
        // 避免死循环的情况
        if (target === copy) {
          continue;
        }
        // 如果是深拷贝，且 copy 值有效，且 copy 值为纯 object 或纯 array
        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            // 数组情况
            copyIsArray = false;
            clone = src && Array.isArray(src)
              ? src
              : [];
          } else {
            // 对象情况
            clone = src && jQuery.isPlainObject(src)
              ? src
              : {};
          }
          // 克隆 copy 对象到原对象并赋值回原属性，而不是重新赋值
          // 递归调用
          target[name] = jQuery.extend(deep, clone, copy);

          // Don't bring in undefined values
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }
  // Return the modified object
  return target;
};
```




#### Object.assign()

`Object.assign()` 方法可以把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象

需要注意的是

* 对于访问器属性，该方法会执行所属访问器的 `getter` 函数，然后把得到的值拷贝给目标对象

  * 如果想拷贝访问器属性本身，可以使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperties()` 方法

* 字符串类型和 `symbol` 类型的属性都会被拷贝

* 在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 `TypeError` 异常，已经拷贝成功的属性不会受到影响，还未拷贝的属性则不会再被拷贝



#### 利用 JSON 进行忽略原型链的深拷贝

```js
var dest = JSON.parse(JSON.stringify(target));
```

同样有缺点，它会忽略掉值为 `undefuned` 的属性以及函数表达式，但不会忽略值为 `null` 的属性


#### 规避原型链属性上的拷贝

#### 使用 hasOwnProperty

```js
for (let key in targetObj) {
  if (targetObj.hasOwnProperty(key)) {
    // ...
  }
}
```

也有一些缺点，就是会遍历了原型链上所有的属性，效率不高

#### Object.keys()

```js
const keys = Object.keys(targetObj);

keys.map((key) => {
  // ...
})
```

这个需要注意的是，只会返回参数对象自身的（不含继承的）所有可遍历（`enumerable`）属性的键名所组成的数组


#### 另辟蹊径

```js
const obj = Object.create(null);
target.__proto__ = Object.create(null);

for (let key in target) {
  // 相关操作
}
```



## fileReader 接口

`FileReader` 接口主要是将文件读入内存，并提供相应的方法，来读取文件中的数据，当然就能显示本地图片不需上传了

一个简单的示例如下：

```js
var result = document.getElementById('result');
var file = document.getElementById('file');

// 判断浏览器是否支持 FileReader 接口
if (typeof FileReader == 'undefined') {
  result.InnerHTML = '<p>你的浏览器不支持 FileReader 接口！</p>';
  // 使选择控件不可操作
  file.setAttribute('disabled', 'disabled');
}

function readAsDataURL() {
  // 检验是否为图像文件
  var file = document.getElementById('file').files[0];
  if (!/image\/\w+/.test(file.type)) {
    alert('格式不正确！');
    return false;
  }
  var reader = new FileReader();
  // 将文件以 Data URL 形式读入页面
  reader.readAsDataURL(file);
  reader.onload = function (e) {
    var result = document.getElementById('result');
    // 显示文件
    result.innerHTML = '<img src='' + this.result + '' alt=' />';
  }
}

// html 部分
<p>
  <input type='file' id='file' />
  <input type='button' value='读取图像' onclick='readAsDataURL()' />
</p>

<div id='result' name='result'></div>
```

预览完成后就可以上传到服务器了：

```js
$('#submitBtn').submit(function () {
  if ($('#upload_file').val()) {
    $('#upload_btn').attr('disabled', true);
    $('.tip').html('正在上传中，请稍候...');
    $(this).ajaxSubmit({
      type: 'post',
      url: url,
      success: function (data) { // 提交成功的回调函数
        // ...
        $('#upload_btn').attr('disabled', false);
        $('.tip').html('');
      }

    });
  }
  return false; // 不刷新页面
});
```

#### FileReader 的方法和事件

```js
// 方法
abort	                          // 中断读取

readAsText(file, [encoding])	  // 将文件读取为文本该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8
                                // 这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容

readAsBinaryString(file)        // 将文件读取二进制码通常我们将它传送到后端，后端可以通过这段字符串存储文件

readAsDataURL(file)             // 将文件读取为 DataURL 将文件读取为一串Data URL字符串，
                                // 将小文件以一种特殊格式的URL地址直接读入页面，小文件指图像与html等格式的文件


// 事件
onabort	        //  数据读取中断时触发

onerror	        //  数据读取出错时触发

onloadstart     //  数据读取开始时触发

onload	        //  数据读取成功完成时触发

onloadend       //  数据读取完成时触发，无论成功失败
```


#### 分段读取文本信息（slice）

有的时候，一次性将一个大文件读入内存，并不是一个很好的选择（如果文件太大，可能直接导致浏览器崩溃），更稳健的方法是分段读取

`HTML5 File Api` 提供了一个 `slice` 方法，允许分片读取文件内容

文件一旦开始读取，无论成功或失败，实例的 `result` 属性都会被填充，如果读取失败，则 `result` 的值为 `null` ，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值

```js
function readBlob(start, end) {
  var files = document.getElementById('file').files;

  if (!files.length) {
    alert('请选择文件');
    return false;
  }

  var file = files[0],
    start = parseInt(start, 10) || 0,
    end = parseInt(end, 10) || (file.size - 1);

  var r = document.getElementById('range'),
    c = document.getElementById('content');

  var reader = new FileReader();
  reader.onloadend = function (e) {
    if (this.readyState == FileReader.DONE) {
      c.textContent = this.result;
      r.textContent = 'Read bytes: ' + (start + 1) + ' - ' + (end + 1) + ' of ' + file.size + ' bytes';
    }
  };

  // 兼容
  var blob;
  if (file.webkitSlice) {
    blob = file.webkitSlice(start, end + 1);
  } else if (file.mozSlice) {
    blob = file.mozSlice(start, end + 1);
  } else if (file.slice) {
    blob = file.slice(start, end + 1);
  }

  reader.readAsBinaryString(blob);

};

document.getElementById('file').onchange = function () {
  readBlob(10, 100);
}
```


使用了 `FileReader` 的 `onloadend` 事件来检测读取成功与否，如果用 `onloadend` 则必须检测一下 `FileReader` 的 `readyState`，因为 `read abort` 时也会触发 `onloadend` 事件，如果我们采用 `onload`，则可以不用检测 `readyState`

#### FileReader 进度条

既然 `FileReader` 是异步读取文件内容，那么就应该可以监听它的读取进度，事实上，`FileReader` 的 `onloadstart` 以及 `onprogress` 等事件，可以用来监听 `FileReader` 的读取进度

在 `onprogress` 的事件处理器中，提供了一个 `ProgressEvent` 对象，这个事件对象实际上继承了 `Event` 对象，提供了三个只读属性：`lengthComputable`、`loaded`、`total`，通过以上几个属性，即可实时显示读取进度

```js
interface ProgressEvent : Event {
  readonly attribute boolean lengthComputable;
  readonly attribute unsigned long long loaded;
  readonly attribute unsigned long long total;
};
```

`ajax` 上传并显示进度条：

```js
function upLoad() {

  var myPic = document.querySelector('myPic').files[0];
  var fd = new FormData();
  fd.append('myPic', myPic);

  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && xhr.status == 200) {
      alert(xhr.responseText);
    }
  }

  // 监听附件上传情况
  xhr.upload.onprogress = function () {
    //  evt.loaded  -- 已经上传大小
    //  evt.total   -- 附件总大小
    var loaded = evt.loaded;
    var tot = evt.total;
    var per = Math.floor(100 * loaded / tot);
    var son = document.getElementById('flag');
    flag.innerHTML = per + '%';
    flag.style.width = per + '%';
  }

  var url = ';
  xhr.open('POST', url);
  xhr.send(fd);
}
```


#### 扩展：FormData 对象

`FormData` 对象，可以把 `form` 中所有表单元素的 `name` 与 `value` 组成一个 `queryString`，提交到后台

用 `jQuery` 的方法来说，就是 `serialize` 了，但是在使用 `Ajax` 提交时，这过程就变成人工的了，因此，使用 `FormData` 对象可以减少拼接 `queryString` 的工作量

1. 可以先创建一个空的 `FormData` 对象，然后利用 `append` 方法向该对象添加字段（`key/value`）

```js
var myForm = new FormData();

myForm.append('name', 'zhangsan');
myForm.append('name', 'lisi');
myForm.append('num', 222333);  // 数字会被转换成字符串
```

2. 或者可以取得 `form` 元素对象，然后将其作为参数传入 `FormData` 对象中

```js
var myForm = document.querySelector('#myForm');
var formdata = new FormData(myForm);
```

3. 利用 `getFormData` 生成

```js
var myForm = document.querySelector('#myForm');
var formdata = myForm.getFormData();
```

4. 使用 `FormData` 提交表单：

```js
function fsubmit() {
  var data = new FormData($('#myForm')[0]);
  $.ajax({
    url: 'upLoad.html',
    type: 'POST',
    data: data,
    dataType: 'JSON',
    cahce: false,
    processData: false,
    contentType: false,
    success: function () {
      // ...
    }
  })
}
```


#### 扩展：window.URL.createObjectURL

`window.URL.createObjectURL` 的作用是创建一个新的对象 `URL`,该对象 `URL` 可以代表某一个指定的 `File` 对象或 `Blob` 对象

关于 `Bold` 对象，见 [MDN -Bold](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)

大体的意思就是

* `File` 对象,就是一个文件，比如我用 `input type='file'` 标签来上传文件,那么里面的每个文件都是一个 `File` 对象

* `Blob` 对象,就是二进制数据,比如通过 `new Blob()` 创建的对象就是 `Blob` 对象.又比如,在 `XMLHttpRequest` 里,如果指定 `responseType` 为 `blob`,那么得到的返回值也是一个 `blob` 对象

```js
objectURL = window.URL.createObjectURL(blob);
// blob 参数是一个 File 对象或者 Blob 对象
// objectURL 是生成的对象 URL 通过这个 URL，可以获取到所指定文件的完整内容

```

每次调用 `createObjectURL` 的时候，一个新的 `URL` 对象就被创建了，即使你已经为同一个文件创建过一个 `URL`

如果你不再需要这个对象，要释放它，需要使用 `URL.revokeObjectURL()` 方法

当页面被关闭，浏览器会自动释放它，但是为了最佳性能和内存使用，当确保不再用得到它的时候，就应该释放它

利用 `window.URL.createObjectURL` 显示图片：

```html
<input type= 'file' id= 'fileElem' multiple accept= 'image/*' style= 'display:none' onchange= 'handleFiles(this.files)'>
<a href='#' id='fileSelect'>Select some files</a>

<div id='fileList'>
  <p>No files selected!</p>
</div>
```

```js
window.URL = window.URL || window.webkitURL;

var fileSelect = document.getElementById('fileSelect'),
  fileElem = document.getElementById('fileElem'),
  fileList = document.getElementById('fileList');

fileSelect.addEventListener('click', function (e) {
  if (fileElem) {
    fileElem.click();
  }
  e.preventDefault(); // prevent navigation to '#'
}, false);

function handleFiles(files) {
  if (!files.length) {
    fileList.innerHTML = '<p>No files selected!</p>';
  } else {
    fileList.innerHTML = ';
    var list = document.createElement('ul');
    fileList.appendChild(list);
    for (var i = 0; i < files.length; i++) {
      var li = document.createElement('li');
      list.appendChild(li);

      var img = document.createElement('img');
      img.src = window.URL.createObjectURL(files[i]);
      img.height = 60;
      img.onload = function () {
        window.URL.revokeObjectURL(this.src);
      }
      li.appendChild(img);
      var info = document.createElement('span');
      info.innerHTML = files[i].name + ': ' + files[i].size + ' bytes';
      li.appendChild(info);
    }
  }
}
```

如果有现成的 `'img'` 标签

```js
function upLoadImg() {
  var myPic = document.getElementById('myPic').files[0];
  document.getElementsByTagName('img')[0].src = window.URL.createObjectURL(myPic);
}
```


#### 分段读取进度

```js
var bar = document.getElementById('progress-bar');
var progress = document.getElementById('progress');

var input = document.getElementById('file');
var block = 1 * 1024 * 1024; // 每次读取 1M

// 当前文件对象
var file;

// 当前已读取大小
var fileLoaded;

// 文件总大小
var fileSize;

// 每次读取一个 block
function readBlob() {
  var blob;
  if (file.webkitSlice) {
    blob = file.webkitSlice(fileLoaded, fileLoaded + block + 1);
  } else if (file.mozSlice) {
    blob = file.mozSlice(fileLoaded, fileLoaded + block + 1);
  } else if (file.slice) {
    blob = file.slice(fileLoaded, fileLoaded + block + 1);
  } else {
    alert('不支持分段读取！');
    return false;
  }
  reader.readAsBinaryString(blob);
}

// 每个 blob 读取完毕时调用
function loadHandler(e) {
  fileLoaded += e.total;
  var percent = fileLoaded / fileSize;
  if (percent < 1) {
    // 继续读取下一块
    readBlob2();
  } else {
    // 结束
    percent = 1;
  }
  percent = Math.ceil(percent * 100) + '%';
  progress.innerHTML = percent;
  progress.style.width = percent;
}

function fileSelect(e) {
  file = this.files[0];
  if (!file) {
    alert('文件不能为空！');
    return false;
  }
  fileLoaded = 0;
  fileSize = file.size;
  bar.style.display = 'block';
  // 开始读取
  readBlob2();
}

var reader = new FileReader();
// 只需监听 onload 事件

reader.onload = loadHandler;
input.onchange = fileSelect
```


参考：

[leejersey](http://www.cnblogs.com/leejersey/p/4772504.html)

[HTML5 之 FileReader 的使用](http://blog.csdn.net/jackfrued/article/details/8967667)

[JavaScript File API](http://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload/)





## promise

在学习 `Node.js` 过程中接触到了如何使用 `async` 来控制并发，`async` 的本质是一个流程控制

其实在异步编程中，还有一个更为经典的模型，叫做 `Promise/Deferred` 模型（当然还有更多相关解决方法，比如 `eventproxy`，`co` 等，到时候遇到在挖坑）

首先，我们思考一个典型的异步编程模型，考虑这样一个题目：读取一个文件，在控制台输出这个文件内容

```js
var fs = require('fs');

fs.readFile('1.txt', 'utf8', function (err, data) {
    console.log(data);
});
```

看起来很简单，再进一步: 读取两个文件，在控制台输出这两个文件内容

```js
var fs = require('fs');

fs.readFile('1.txt', 'utf8', function (err, data) {
  console.log(data);
  fs.readFile('2.txt', 'utf8', function (err, data) {
    console.log(data);
  });
});
```

要是读取更多的文件呢?

```js
var fs = require('fs');
fs.readFile('1.txt', 'utf8', function (err, data) {
  fs.readFile('2.txt', 'utf8', function (err, data) {
    fs.readFile('3.txt', 'utf8', function (err, data) {
      fs.readFile('4.txt', 'utf8', function (err, data) {
        // ...
      });
    });
  });
});
```

这就是传说中的 `callback hell`，可以使用 `async` 来改善这段代码，但是在本例中我们要用 `promise/defer` 来改善它


#### promise 基本概念

首先它是一个对象，它和 `javascript` 普通的对象没什么区别，同时，它也是一种规范，跟异步操作约定了统一的接口，表示一个异步操作的最终结果，以同步的方式来写代码，执行的操作是异步的，但又保证程序执行的顺序是同步的

1. `promise` 只有三种状态，未完成，完成 (`fulfilled`) 和失败 (`rejected`)

2. `promise` 的状态可以由未完成转换成完成，或者未完成转换成失败

3. `promise` 的状态转换只发生一次


`promise` 有一个 `then` 方法，`then` 方法可以接受 `3` 个函数作为参数。**前两个**函数对应 `promise` 的两种状态 `fulfilled`, `rejected` 的回调函数。**第三个**函数用于处理进度信息

为了理解它，一些重要原理必须记牢：`.then()` 总是返回一个新的 `promise`，如下面代码：

```js
var promise = readFile()
var promise2 = promise.then(readAnotherFile, console.error)
```

这里 `then` 的参数 `readAnotherFile`, `console.error` 是代表异步操作成功后的动作 `onFulfilled` 或失败后的动作 `OnRejected`

也就是说，读取文件成功后执行 `readAnotherFile` 函数，否则失败打印记录错误。这种实现是两个中只有一种可能

也可以理解为：

```js
promiseSomething().then(function (fulfilled) {
  // 当 promise 状态变成 fulfilled 时，调用此函数
}, function (rejected) {
  // 当 promise 状态变成 rejected 时，调用此函数
}, function (progress) {
  // 当返回进度信息时，调用此函数
});
```

`Promise` 法则有两部分必须分离：

1. `then()` 总是返回一个**新的** `promise`，每次你调用它，它不管回调做什么，因为 `.then()` 在回调被调用之前已经给了你一个承诺 `promise`，回调的行为只影响承诺 `promise` 的实施，如果回调返回一个值，那么 `promise` 将使用那个值，如果这个值是一个 `promise`，返回这个 `promise` 实施后的值给这个值，如果回调抛出错误，`promise` 将拒绝错误

2. 被 `.then()` 返回的 `promise` 是一个新的 `promise` ，它不同于那些 `.then()` 被调用的 `promise`，`promise` 长长的链条有时会好些隐藏这个事实，不管如何，每次 `.then()` 调用都会产生一个新的 `promise`，这里必须注意的是你真正需要考虑的是你最后调用 `.then()` 可能代表失败，那么如果你不捕获这种失败，那么容易导致你的错误 `exception` 消失




#### Promises/A+ 规范

`promise` 代表一个异步操作的最终结果。主要通过 `promise` 的 `then` 方法订阅其最终结果的处理回调函数，和订阅因某原因无法成功获取最终结果的处理回调函数。

更对详细见：<a href="https://promisesaplus.com/" target="_blank">Promises/A+</a>

`A` 与 `A+` 的不同点

* `-A+` 规范通过术语 `thenable` 来区分 `promise` 对象

* `-A+` 定义 `onFulfilled/onRejectd` 必须是作为函数来调用，而且调用过程必须是异步的

* `-A+` 严格定义了 `then` 方法链式调用时，`onFulfilled/onRejectd` 的调用顺序






## JavaScript 获得随机 unicode 字符

```js
String.fromCharCode(Math.floor(Math.random()*9999));
```




## call 和 apply 的第一个参数

`call` 和 `apply` 用来改变函数的执行上下文（`this`），它们的第一个参数 `thisArg` 是个对象，即作为函数内的 `this`

在多数时候你传递什么给函数，那么它就是什么

```js
function fun() {
  alert(this);
}

fun.call(1);                // 1

fun.call('a');              // a

fun.call(true);             // true

fun.call({name: 'aaa'});    // [object Object]
```

有两种情况需要注意，传递 `null` 或 `undefined` 时，执行环境会是全局的（`window/global`）

可以参考[规范 15.3.4.4](http://lzw.me/pages/ecmascript/#323)

```js
fun.call(null);       // window
fun.call(undefined);  // window
```

但是在严格模式下，给 `call` 和 `apply` 传入的任何参数不再会转换

```js
'use strict'
function fun() {
  alert(this);
}

fun.call(null);        // null
fun.call(undefined);   // undefined
```

另外一个例子

```js
function foo(x, y) {
  'use strict';
  console.log(x, y, this);
}

foo.apply(null);        // undefined undefined null
foo.apply(undefined);   // undefined undefined undefined
```







## bind 方法的简单实现

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function () {
    var self = this,                        // 保存原函数
      context = [].shift.call(arguments),   // 保存需要绑定的 this 上下文
      args = [].slice.call(arguments);      // 剩余的参数转为数组
    return function () {                    // 返回一个新函数
      self.apply(context, [].concat.call(args, [].slice.call(arguments)));
    }
  }
}
```





## getElementsByClassName 方法实现

```js
function getElementsByClassName(classname) {
  if (document.querySelectorAll) {
    return document.querySelectorAll('.' + classname);
  } else {
    var elements = document.getElementsByTagName('*');
    var reg = new RegExp('(^|\\s)' + classname + '(\\s|$)');
    var results = [];
    for (let i = 0, length = elements.length; i < length; i++) {
      if (reg.test(elements[i].className)) {
        results.push(elements[i]);
      }
    }
  }

  return results;
}
```










## 判断是否是数组 isArray

```js
var isArray = function (value) {
  return value && typeof value === "object" && value.constructor === "Array";
}
```

上面这个方法在 从不同的窗口（`window / frame`）里构造的数组的时候会失败，所以我们不得不考虑更多

```js
var isArray = function (value) {
  return value && typeof value === "object"
    && typeof value.length === "number"
    && typeof value.slice === "function"
    && !(value.propertyIsEnumerable("length"));
}
```

首先，我们要判断这个值是否为真，不接受 `null` 和其他为假的值

其次判断 `typeof` 运算的结果是否为 `object`，对于对象，数组和 `null` 来说，返回的是 `true`（但是对于对象来说并非如此）

然后判断这个值是否包含一个 `splice` 的方法，对于数组来说，又将会得到 `true`

最后判断 `length` 属性是否是可枚举的，对于数组来说，将得到 `false`





## 提取数字中的整数部分

```js
Function.prototype.method = function (name, func) {
  this.prototype[name] = func;
  return this;
}

Number.method('integer', function () {
  return Math[this < 0 ? 'ceil' : 'floor'](this);
})

console.log((-10 / 3).integer())
```





## 从请求的异步回调函数中取值的解决办法

问题如下

```js
function load_val() {
  $.get('url', function (data) {
    // 如何把这里取到的 data 通过 load_val 函数返回出去？
  });
}
```

如果通过一个全局变量来获取，自然也不是不可以，不过这里就涉及到一点：如果使用了全局变量来获取后，该怎么使用呢？

还是上面这个例子，我们稍微改造一下

```js

var obj = '';

function load_val() {
  $.get('url', function (data) {
    // 在此处将 data 赋予全局变量
    obj = data;
  });
}

// 调用函数获取数据
load_val();

function use_val() {
  obj += 1;
  console.log(obj);
}

use_val();
```

上面这个例子很好理解，我们想通过 `obj` 这个全局变量获取 `ajax` 异步过来的 `data` 数据，然后在 `use_val` 这个函数中使用 `obj` 这个变量

看似没问题，实际上问题很严重

在 `use_val()` 中的 `obj` 真的是 `data` 的值么？答案是否定的，而是 `''`

因为就这段代码而言，`obj = data` 是在 `use_val()` 执行完才在异步回调函数内实现的，在此之前，`obj`一直是 `''`

于是又有人说，那我写个延时函数，等待 `obj = data` 后再执行呗，那样就太不优雅了，那么该如何解决呢？

```js
// 定义一个回调函数
function load_val(callback) {
  $.get('url', function (data) {
    // 将返回结果当作参数通过回调函数返回
    callback(data); 
  });
}

load_val(function (data) {
  // 这里可以得到值
  obj = data; 
  use_val();
});

function use_val() {
  obj += 1;
  console.log(obj);
}
```

也就是在所需要调用的回调函数外加一个函数，这个函数包含一个参数，该参数是个函数，然而这个函数有着依赖于回调函数给出的值的参数，所以经过这两层，就能将原本回调函数里的值给取出来







## 实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制

```js
Object.prototype.clone = function () {
  var o = this.constructor === Array ? [] : {};
  for (var e in this) {
    o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];
  }
  return o;
}
```





## 深度克隆

```js
// 方式一
function extendDeepCopy01(obj, newobj) {
  var newobj = newobj || {};
  for (var i in obj) {
    if (typeof obj[1] == "object") {
      newobj[i] = (obj[i].constructor === Array) ? [] : {};
      extendDeepCopy(obj[i], newobj[i]);
    } else {
      newobj[i] = obj[i];
    }
  }
  return newobj;
}

// 方式二
function extendDeepCopy02(Obj) {
  var buf;

  if (Obj instanceof Array) {
    // 创建一个空的数组
    buf = [];
    var i = Obj.length;

    while (i--) {
      buf[i] = extendDeepCopy02(Obj[i]);
    }

    return buf;

  } else if (Obj instanceof Object) {
    // 创建一个空对象
    buf = {};

    // 为这个对象添加新的属性
    for (var k in Obj) {
      buf[k] = extendDeepCopy02(Obj[k]);
    }
    return buf;

  } else {
    return Obj;
  }
}

var user = {
  name: 'aaa',
  tag: ['tag1', 'tag2'],
  username: 'test',
  password: 'password'
}

var user1 = extendDeepCopy01(user);

user1.name = 'bbb';
user1.username = 'username1';
user1.password = 'password1';
user1.tag.push('tag3');

console.log(user1)
```










## 面向对象的五大基本原则

* 单一职责原则 SRP（`Single Responsibility Principle`）

  * 是指一个类的功能要单一，不能包罗万象，如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来

* 开放封闭原则 OCP（`Open－Close Principle`） 

  * 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的，比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能

  * 那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来

* 替换原则（`the Liskov Substitution Principle LSP`） 

  * 子类应当可以替换父类并出现在父类能够出现的任何地方，比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工

  * 也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了

* 依赖原则（`the Dependency Inversion Principle DIP`） 

  * 具体依赖抽象，上层依赖下层，假设 `B` 是较 `A` 低的模块，但 `B` 需要使用到 `A` 的功能

  * 这个时候，`B`不应当直接使用 `A` 中的具体类，而应当由 `B` 定义一抽象接口，并由 `A` 来实现这个抽象接口，`B` 只使用这个抽象接口
  
  * 这样就达到了依赖倒置的目的，`B` 也解除了对 `A` 的依赖，反过来是 `A` 依赖于 `B` 定义的抽象接口，通过上层模块难以避免依赖下层模块
  
  * 假如 `B` 也直接依赖 `A` 的实现，那么就可能造成循环依赖，一个常见的问题就是编译 `A` 模块时需要直接包含到 `B` 模块的 `cpp` 文件，而编译 `B` 时同样要直接包含到 `A` 的 `cpp` 文件

* 接口分离原则（`the Interface Segregation Principle ISP`） 

  * 模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来




## 常用设计模式的实现思路

常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等


#### 单例，任意对象都是单例，无须特别处理

```js
var obj = { name: 'michaelqin', age: 30 };
```


#### 工厂，就是同样形式参数返回不同的实例

```js
function Person() { this.name = 'Person1'; }
function Animal() { this.name = 'Animal1'; }

function Factory() { }

Factory.prototype.getInstance = function (className) {
  return eval('new ' + className + '()');
}

var factory = new Factory();

var obj1 = factory.getInstance('Person');
var obj2 = factory.getInstance('Animal');

console.log(obj1.name); // Person1
console.log(obj2.name); // Animal1
```


#### 代理，就是新建个类调用老类的接口，包一下

```js
function Person() { }

Person.prototype.sayName = function () { console.log('michaelqin'); }
Person.prototype.sayAge = function () { console.log(30); }

function PersonProxy() {
  this.person = new Person();
  var that = this;
  this.callMethod = function (functionName) {
    console.log('before proxy:', functionName);
    // 代理
    that.person[functionName]();
    console.log('after proxy:', functionName);
  }
}

var pp = new PersonProxy();

pp.callMethod('sayName'); // 代理调用 Person 的方法 sayName()
pp.callMethod('sayAge');  // 代理调用 Person 的方法 sayAge()
```


#### 观察者，就是事件模式，比如按钮的 onclick 这样的应用

```js
function Publisher() {
  this.listeners = [];
}

Publisher.prototype = {
  'addListener': function (listener) {
    this.listeners.push(listener);
  },

  'removeListener': function (listener) {
    delete this.listeners[listener];
  },

  'notify': function (obj) {
    for (var i = 0; i < this.listeners.length; i++) {
      var listener = this.listeners[i];
      if (typeof listener !== 'undefined') {
        listener.process(obj);
      }
    }
  }
}; 

// 发布者
function Subscriber() { }

// 订阅者
Subscriber.prototype = {
  'process': function (obj) {
    console.log(obj);
  }
};

var publisher = new Publisher();

publisher.addListener(new Subscriber());
publisher.addListener(new Subscriber());

publisher.notify({ name: 'michaelqin', ageo: 30 });          // 发布一个对象到所有订阅者
publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者
```







## JavaScript 异步加载方案

最常见的莫过于 `defer` 与 `async`

#### defer

`HTML4` 为 `script` 标签定义了一个扩展属性 `defer`

`defer` 指明本元素所含的脚本不会修改 `dom`，因此代码能安全地延迟执行，但是该属性并不是一个理想的跨浏览器解决方案，该属性只有 `IE4+` 和 `firefox3.5+` 的浏览器支持，用法如下

```js
<script type='text/javascript' src='test.js' defer></script>
```

带有 `defer` 属性的 `script` 标签可以放置在文档的任何位置，当一个带有 `defer` 属性 `js` 文件下载时，它不会阻塞浏览器的其他进程

因此这类文件可以与页面中的其他资源并行下载，带有 `defer` 属性的 `script` 标签在 `dom` 加载完成（`onload` 事件触发前执行）

#### async 

`HTML5` 规范引入了 `async` 属性，用于异步加载脚本

```js
<script type='text/javascript' src='test.js' async></script>
```

`async` 与 `defer` 的相同点是采用并行下载，在下载的过程中不会产生阻塞，区别在于 `async` 是加载完成后自动执行，而 `defer` 需要等待页面完成后执行

#### 动态创建 script

主要原理 `javascript` 可以动态创建 `HTML` 中几乎所有的内容，所以我们可以利用 `javascript` 动态地创建 `script` 标签并添加到 `HTML` 中

```js
var script = document.createElement('script');

script.type = 'text/javasctipt';
script.src = 'file.js';

document.getElementByTagName('head')[0].appendChild(script)
```

我们可以使用如下方法跟踪并确保脚本下载完成并准备就绪

```js
function loadScript(url, callback) {

  // 创建标签
  var script = document.createElement("script");
  script.type = "text/javasctipt";

  // 如果是 IE
  if (script.readyState) {
    script.onreadystatechange = function () {
      if (script.readyState == 'loaded' || script.readyState == 'complete') {
        script.onreadystatechange = null;
        callback()
      }
    }
  } else {
    script.onload = function () {
      callback();
    }
  }

  // 赋值
  script.src = url;
  document.getElementByTagName("head")[0].appendChild(script)
}
```

调用方法

```js
loadScript('files.js',function(){
  console.log(`file is loaded`);
})
```

#### XMLHttpRequest 脚本注入

还可以通过 `XHR` 对象获取脚本并注入到页面

```js
// 获取 XMLHttpRequest 对象（考虑兼容性）
var getXmlHttp = function () {
  var obj;
  if (window.XMLHttpRequest)
    obj = new XMLHttpRequest();
  else
    obj = new ActiveXObject('Microsoft.XMLHTTP');
  return obj;
};

// 采用 Http 请求 get 方式，open() 方法的第三个参数表示采用异步（true）还是同步（false）来进行处理
var xmlHttp = getXmlHttp();
xmlHttp.open('GET', 'file3.js', true);

xmlHttp.onreadystatechange = function () {
  if (xmlHttp.readyState == 4) {
    if (xmlHttp.status >= 200 && xmlHttp.status < 300 || xmlHttp.status == 304) {
      var script = document.createElement('script');
      script.text = xmlHttp.responseText;
      document.body.appendChild(script);
    }
  }
}

xmlHttp.send(null);
```







## 简易事件模型

简单来说就是一个定顺序触发相应的响应函数

大致实现思路就是创建一个类或是匿名函数，在 `bind` 和 `trigger` 函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表

`bind` 时，如果字典没有则创建一个，`key` 是事件名称，`value` 是数组，里面放着当前注册的响应函数

如果字段中有，那么就直接 `push` 到数组即可，`trigger` 时调出来依次触发事件响应函数即可

不过还有很多细节，比如触发响应函数时的上下文应该是什么，触发响应函数的参数列表应该是什么，如果要求把调用 `trigger` 的参数列表都传到响应函数中还要考虑到把 `arguments` 对象转化为纯数组才行等等


```js
var Emitter = function () {
  this._listeners = {};
};

// 注册事件
Emitter.prototype.on = function (eventName, callback) {
  var listeners = this._listeners[eventName] || [];
  listeners.push(callback);
  this._listeners[eventName] = listeners;
}

// 触发事件
Emitter.prototype.emit = function (eventName) {
  var args = Array.prototype.slice.apply(arguments).slice(1),
    listeners = this._listeners[eventName];

  if (!Array.isArray(listeners)) return;

  listeners.forEach(function (callback) {
    try {
      callback.apply(this, args);
    } catch (e) {
      console.error(e);
    }
  });
}

// 实例
var emitter = new Emitter();

emitter.on('event', function (arg1, arg2) {
  console.log('get event', arg1, arg2);
})

console.log('emit event');
emitter.emit('event', 'arg1', 'arg2');
```




## 关于 'use strict'

严格模式是 `ECMAScript 5` 中的一项新特征，允许你把一段程序或功能放置在 `'strict'` 工作环境中，这种严格上下文环境防止某些行为被采取并引发更多的异常

严格的模式有助于几个方面

* 它捕获了一些常见的编码错误，抛出异常

* 它阻止，或抛出错误，当相对'不安全'的行为被采用（例如获取全局对象）

* 它禁用那些混淆的或者考虑不周的特征

```js
// 非严格的代码...

(function () {
  'use strict';

  // 严格定义你的库...
})();

// 非严格的代码
```



## 检测是否有元素被隐藏

```js
// 检查 display: [none | block], 忽略 visible: [true | false]
$(element).is(":visible");

// 匹配的是隐藏的所有元素
$('element:hidden')

// 匹配所有可见的元素
$('element:visible')
```







## 鼠标长按事件

只要长按时间到达 `1000` 毫秒，无论是否弹起鼠标，都会触发，反之如果不到 `1000` 毫秒，鼠标弹起的时候会结束

```js
// 申明全局变量
var timeStart, timeEnd, time;

// 获取此刻时间
function getTimeNow() {
  var now = new Date();
  return now.getTime();
}

// 鼠标按下时触发
function holdDown() {
  // 获取鼠标按下时的时间
  timeStart = getTimeNow();

  // setInterval 会每 100 毫秒执行一次，也就是每 100 毫秒获取一次时间
  time = setInterval(function () {
    timeEnd = getTimeNow();

    // 如果此时检测到的时间与第一次获取的时间差有 1000 毫秒
    if (timeEnd - timeStart > 1000) {
      // 便不再继续重复此函数 （clearInterval 取消周期性执行）
      clearInterval(time);
      // 字体变红
      // 一些逻辑
    }
  }, 100);
}

function holdUp() {
  // 如果按下时间不到 1000 毫秒便弹起
  clearInterval(time);
}
```







## 如何判断一个对象是否为空

1. 最常见的思路，`for...in` 遍历属性，为真则为'非空数组'，否则为'空数组'

```js
// 如果不为空，则会执行到这一步，返回 true
for (var i in obj) {
  return true
}

// 如果为空，返回 false
return false 
```

2. 通过 `JSON` 自带的 `stringify()` 方法来判断

`JSON.stringify()` 方法用于将 `JavaScript` 值转换为 `JSON` 字符串

```js
if (JSON.stringify(data) === '{}') {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```

这里需要注意为什么不用 `toString()`，因为它返回的不是我们需要的

```js
var a = {}
a.toString() // "[object Object]"
```


3. `ES6` 新增的方法 `Object.keys()`

`Object.keys()` 方法会返回一个由一个给定对象的自身可枚举属性组成的数组

如果我们的对象为空，他会返回一个空数组，如下

```js
var a = {}
Object.keys(a) // []
```

我们可以依靠 `Object.keys()` 这个方法通过判断它的长度来知道它是否为空

```js
if (Object.keys(object).length === 0) {
  // 如果为空，返回 false
  return false
}

// 如果不为空，则会执行到这一步，返回 true
return true 
```





## 生成 [0, 1, 2, 3 ... N - 1] 的数组

在 ES5 当中可以使用如下方式

```js
Array.apply(null, { length: N }).map(Function.call, Number);
```

* `Array.apply(null, {length: N})` 将返回一个由 `undefined` 填充的长度为 `N` 的数组

* `.map(Function.call, Number)` 将返回一个长度为 `N` 的数组，它的索引为 `I` 的元素为 `Function.call.call(Number, undefined, I, A)` 的结果

* `Function.call.call(Number, undefined, I, A)` 可转化为 `Number(I)`，正好就是 `I`


在 ES6 当中的话则可以使用下面这种方式

```js
Array.from(new Array(N), (val, index) => index);
```

* `new Array(N)` 返回一个由 `undefined` 组成的长度为 `N` 的数组（类似于 `[, , , ...]`）

* `(val, index) => index` 即 `function F (val, index) { return index; }`

* `Array.from(A, F)` 返回一个长度为 `N` 的数组，它的索引为 `I` 的元素为 `F(A[I], I)` 的结果，也就是 `I`


如果想要生成 `[1, 2, 3, 4 ... N]` 这样的序列

针对方法一可以使用

```js
Array.apply(null, { length: N }).map(function(value, index){
  return index + 1;
});
```

针对方法二可以使用

```js
Array.from(new Array(N), (val, index) => index + 1);
```







## 找出数字数组中最大的元素

```js
Math.max.apply(null, arr);
```


## 转化一个数字数组为 function 数组（每个 function 都弹出相应的数字）

```js
var arr = [1, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
  var index = arr[i];
  (function (index) {
    arr[i] = function () {
      alert(index);
    }
  })(index)
}

arr[0]();
```


## 给 object 数组进行排序（排序条件是每个元素对象的属性个数）

```js
Object.prototype.getLength = function () {
  var num = 0;
  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      num++;
    }
  }
  return num;
}

var a = {
  name: 'a',
  age: 10,
  location: 'b'
};

var b = {
  name: 'c'
};

var c = {
  name: 'd',
  sex: 'e'
};

var arr = [a, b, c];

arr.sort(function (a, b) {
  return a.getLength() > b.getLength();
})

console.log(arr);
```


## 打印 Fibonacci 数（不使用全局变量）

```js
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
function fn(n) {
  var a = [];
  a[0] = 0, a[1] = 1;
  for (var i = 2; i < n; i++) {
    a[i] = a[i - 1] + a[i - 2];
  }
  for (var i = 0; i < n; i++) {
    console.log(a[i]);
  }
}

fn(20);
```


## 实现如下语法的功能 var a = (5).plus(3).minus(6);

```js
Number.prototype.plus = function (a) {
  return this + a;
};

Number.prototype.minus = function (a) {
  return this - a;
};

var a = (5).plus(3).minus(6);

console.log(a);
```


## 实现如下语法的功能 var a = add(2)(3)(4);

```js
function add(a) {
  var temp = function (b) {
    return add(a + b);
  }
  temp.valueOf = temp.toString = function () {
    return a;
  };
  return temp;
}
var ans = add(2)(3)(4);

console.log(ans);
```








## 如何快速判断 DOM 元素位于 viewport 以外

```js
ele.getBoundingClientRect().top > window.innerHeight  // 元素在当前屏下面

ele.getBoundingClientRect().bottom < 0                // 元素在当前屏上面
```





## 检测对象改变的几种方式

方法一，可以通过 getter 和 setter 实现

```js
var obj = {
  get foo() {
    console.log({ name: 'foo', object: obj, type: 'get' });
    return obj._foo;
  },
  set bar(val) {
    console.log({ name: 'bar', object: obj, type: 'set', oldValue: obj._bar });
    return obj._bar = val;
  }
};

obj.bar = 2;
// {name: "bar", object: {_bar: 2}, type: "set", oldValue: undefined}

obj.foo;
// {name: "foo", object: <_bar: 2>, type: 'get'}
```

方法二，在支持 Proxies（代理）的浏览器中更为通用的方法

```js
var obj = {
  foo: 1,
  bar: 2
}

var proxied = new Proxy(obj, {
  get: function (target, prop) {
    console.log({ type: 'get', target, prop });
    return Reflect.get(target, prop);
  },
  set: function (target, prop, value) {
    console.log({ type: 'set', target, prop, value });
    return Reflect.set(target, prop, value);
  }
})

proxied.bar = 2;
// {type: "set", target: { foo: 1, bar: 2 }, prop: "bar", value: 2}

proxied.foo;
// {type: "get", target: { foo: 1, bar: 2 }, prop: "foo"}
```

方法三，使用 Object.defineProperties

```js
var obj = Object.defineProperties({}, {
  'foo': {
    get: function () {
      console.log('Get Foo: ' + this.value);
    },
    set: function (val) {
      console.log('Set Foo: ' + val);
      this.value = val;
    }
  },

  'bar': {
    get: function () {
      console.log('Get Bar: ' + this.value);
    },
    set: function (val) {
      console.log('Set Bar: ' + val);
      this.value = val;
    }
  }
});

obj.foo = 2;
// Set Foo: 2

obj.bar;
// Get Bar: undefined
```








## 使用 filter 确保 Observable 当中流中的值不为空

```js
dialogRef.afterClosed()
  .take(1)
  .filter(n => n)
```




## 将数组转为字典对象

```js
// obj 为传入的值
const userEntities = obj.reduce((el, c) => ({...el, c}), {})
```




## 从列表当中删除掉指定项

```js
// 从 items 中取出 id 集合
const ids = this.items.map(item => item.id);
// 然后筛选需要删除的项在数组当中所处的位置
const i = ids.indexOf(member.id);
// 进行删除
this.items = [...this.items.slice(0, i), ...this.items.slice(i + 1)]
```




## 查找列表当中指定的项

```js
export class ItemsService {
  private items: any[];

  getItem(id: number) {
    return this.items.find((item) => item.id === id);
  }
}
```




## Property 'style' does not exist on type 'Element'

这个问题一般会在 `TS` 当中使用 `document.querySelector` 去获取元素的时候发生

根据规范可知（[MDN Element 规范](https://developer.mozilla.org/en-US/docs/Web/API/Element)），`Element` 接口确实没有 `style` 属性

如果不是用来操作 `SVG` 元素，而是仅仅使用 `TS` 的话，可以像下面这样操作

```js
(document.querySelector('xxx') as HTMLElement).style.color = 'red';
```





## table 表单中的 .rows 属性

如下

```js
var tr = cartTable.children[1].rows;
```

为表单元素特有的属性，存放节点所有的 `tr` 元素，操作的话可以使用如下方式

```js
price += tr[i].cells[4].innerHTML
```

> `cells` 也是 表单元素特有的属性，里面存放的是这个表格没一行下面的所有的单元格，也就是 `td` 元素，也就是说这一行下面所有的 `td`





## offsetLeft 与 style.left 的区别

`offsetLeft` 获取的是相对于父对象的左边距

`left` 获取或设置相对于 具有定位属性（`position` 定义为 `relative`）的父对象的左边距

如果父 `div` 的 `position` 定义为 `relative`，子 `div` 的 `position` 定义为 `absolute`

那么子 `div` 的 `style.left` 的值是相对于父 `div` 的值，这同 `offsetLeft` 是相同的，区别在于

* `style.left` 返回的是字符串，如 `28px`，`offsetLeft` 返回的是数值 `28`，如果需要对取得的值进行计算，还用 `offsetLeft` 比较方便

* `style.left` 是读写的，`offsetLeft` 是只读的，所以要改变 `div` 的位置，只能修改 `style.left`

* `style.left` 的值需要事先定义，否则取到的值为空，而且必须要定义在 `html` 里,如果定义在 `css` 里，`style.left` 的值仍然为空

`offsetLeft` 则仍然能够取到，无需事先定义 `div` 的位置



## Reflect 对象

`Reflect` 对象与 `Proxy` 对象一样，也是 `ES6` 为了操作对象而提供的新 `API`

简单来说两点，一个就是将 `Object` 对象的一些明显属于语言内部的方法（比如 `Object.defineProperty`），放到 `Reflect` 对象上

另一个就是让 `Object` 操作都变成函数行为，因为 `ES5` 很多 `Object` 操作都是命令式的（另外一个原因就是这些方法可能是全局的，或者要通过原型来调用，统一起来）

这里只简单的介绍几个常用的方法，详细的可见 [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/reflect) 和 [Reflect - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)


#### Reflect.apply(target, thisArgument, argumentsList)

与 `ES5` 的 `Function.prototype.apply` 方法是类似的

比如查找数组中最大数

```js
// ES6 
Reflect.apply(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5

// ES5
Math.max.apply(undefined, [1, 2, 3, 4, 5]);  // 5

Function.prototype.apply.call(Math.max, undefined, [1, 2, 3, 4, 5]);  // 5
```

切割字符串

```js
// ES6 
Reflect.apply(String.prototype.slice, 'hello world', [2, 8]);  // "llo wo"

// ES5 
'hello world'.slice(2, 8);  // "llo wo"

String.prototype.slice.apply('hello world', [2, 8]);  // "llo wo"
```



#### Reflect.construct(target, argumentsList[, newTarget])

与使用 ·new target(...args)· 方法类似，相当于提供了一种新的不使用 ·new· 来调用构造函数的方法

* `target` 表示被运行的目标函数

* `argumentsList` 调用构造函数传递的参数数组或者伪数组

* `newTarget` 参数为构造函数，表示使用 `Reflect.construct` 后生成的对象是谁的实例

* 如果没有传递第三个参数，默认和 `target` 一样

如果没有传递第三个参数，那么 `target` 就是唯一的构造函数，但是如果传递了第三个参数，那就表示实例将由两部分组成，实力的属性部分（constructor）由第一个参数部分生成，实例的方法部分由第三个参数生成

```js
class A1 {
  constructor(name) {
    console.log('Class A1 is invoked!');
    this.name = name;
  }
  getName() {
    console.log(this.name);
    return this.name;
  }
}

class B1 {
  constructor(age) {
    console.log('Class B1 is invoked!');
    this.age = age;
  }
  getAge() {
    console.log(this.age);
    return this.age;
  }
}

// 使用 A1 类作为构造函数
let a1 = Reflect.construct(A1, ['happy']);

// 使用 B1 类作为构造函数
let b1 = Reflect.construct(A1, ['happy'], B1);

console.log(a1);
console.log(b1);

// A1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class A1
//     getName: ƒ getName()
//     __proto__: Object

// B1 {name: "happy"}
//   name: "happy"
//   __proto__:
//     constructor: class B1
//     getAge: ƒ getAge()
//     __proto__: Object
```



#### Reflect.defineProperty(target, propertyKey, attributes)

与 `Object.defineProperty` 相似，不过如果 `Object.defineProperty` 的属性定义失败了，就会抛出一个错误，而 `Reflect.defineProperty` 如果定义属性失败的话就会返回 `false`

```js
let obj = {};

let result = Reflect.defineProperty(obj, 'name', {
  configurable: true,
  enumerable: true,
  value: 'happy'
});

console.log(result)  // true
```



#### Reflect.getPrototypeOf(target)

与 `Object.getPrototypeOf` 方法是一样的，都是返回一个对象的原型，也就是内部的 `[[Prototype]]` 属性的值

如果要获取原型的那个值不是一个对象，那么函数 `Reflect.getPrototypeOf` 会抛出一个异常

对于给定对象的原型，如果没有继承的属性，则返回 `null`



#### Reflect.ownKeys(target)

返回由目标对象自身的属性键组成的数组，包括 `symbol` 的值

```js
let a = Symbol.for('a');
let b = Symbol.for('b');

let obj = {
  [a]: 10,
  [b]: 20,
  key1: 30,
  key2: 40
};

let arr1 = Object.getOwnPropertyNames(obj);
console.log(arr1); // [ 'key1', 'key2' ]

let arr2 = Object.getOwnPropertySymbols(obj);
console.log(arr2); // [ Symbol(a), Symbol(b) ]

let arr3 = Reflect.ownKeys(obj);
console.log(arr3); // [ 'key1', 'key2', Symbol(a), Symbol(b) ]
```













## 去除所有的 html

```js
var con = content.replace(/<[^>]+>/g,'');
```

## 去除空格

```js
var con = content.replace(/\s/g,'');
```

## 判断输入的是否为数字

```js
var reg=/^\d+(\.\d+)?$/;
​
if(reg.test(title) == true){
  alert("内容不能为纯数字，请从新输入！");
  return false;
}
```

## 取括号中的数值

```js
/\(([^()]+)\)/g.exec('add(18)')
```

## 千位分隔符（整数）

```js
var a = "-1234454654645645";

a = a.replace(/(\d)(?=(\d{3})+$)/g,"$1,");

console.log(a);
```