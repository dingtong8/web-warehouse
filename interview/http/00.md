## http

* ```http``` 状态码常见有哪些

* 浏览器缓存机制

* ```cookie``` / ```csrf``` / ```xss```

* ``````http/2``````

* ```http``` 协议（三层握手/四次挥手）

* 域名发散与收敛

* ```SEO```

* ```http``` 协议头包含哪些信息


----


## http 常见状态码

```js
// 2开头 （请求成功）表示成功处理了请求的状态代码
200  // OK 服务器已成功处理了请求

// 3开头 （请求被重定向）表示要完成请求，需要进一步操作，通常这些状态代码用来重定向
301  // 永久移动，请求的网页已永久移动到新位置，服务器返回此响应时，会自动将请求者转到新位置
302  // 临时移动，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
304  // 未修改，自从上次请求后，请求的网页未修改过（服务器返回此响应时，不会返回网页内容），可以在请求时添加时间戳来处理

// 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理
400  // 错误请求，服务器不理解请求的语法
401  // 请求未经授权，这个状态代码必须和 www-Authenticate 报头域一起使用
403  // 服务器收到请求，但是拒绝提供服务，一般是服务器路径没有权限或者是其他权限相关问题
404  // 未找到，服务器找不到请求的网页

// 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误，这些错误可能是服务器本身的错误，而不是请求出错
500  // 服务器内部错误，服务器遇到错误，无法完成请求
```

----


## 浏览器缓存机制

内容很多，可以参考：

[浏览器缓存机制详解](http://mangguo.org/browser-cache-mechanism-detailed/)

[浏览器 HTTP 协议缓存机制详解](http://www.cnblogs.com/520yang/articles/4807408.html)

浏览器缓存：包括页面 ```html``` 缓存和图片 ```js```，```css``` 等资源的缓存，如下图，浏览器缓存是基于把页面信息保存到用户本地电脑硬盘里

![浏览器缓存](http://img.my.csdn.net/uploads/201303/17/1363512688_4762.png)

缓存的优点：

1. 服务器响应更快：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让服务器看上去响应更快

2. 减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗，客户可以节省带宽费用，控制带宽的需求的增长并更易于管理

#### 缓存工作原理

面缓存状态是由 ```http header``` 决定的，一个浏览器请求信息，一个是服务器响应信息，主要包括 ```Pragma: no-cache```，```Cache-Control```，```Expires```，```Last-Modified```，```If-Modified-Since```

其中 ```Pragma: no-cache``` 由 ```HTTP/1.0``` 规定，```Cache-Control``` 由 ```HTTP/1.1``` 规定，工作原理图如下

![浏览器缓存](http://img.my.csdn.net/uploads/201303/17/1363512757_1013.png)

原理主要分三步：

1. 第一次请求：浏览器通过 ```http``` 的 ```header``` 报头，附带 ```Expires```，```Cache-Control```，```Last-Modified/Etag``` 向服务器请求，此时服务器记录第一次请求的 ```Last-Modified/Etag```

2. 再次请求：当浏览器再次请求的时候，请求头附带 ```Expires```，```Cache-Control```，```If-Modified-Since/Etag``` 向服务器请求

3. 服务器根据第一次记录的 ```Last-Modified/Etag``` 和再次请求的 ```If-Modified-Since/Etag``` 做对比，判断是否需要更新，服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回 ```304``` 响应

常见流程如下图所示：

![浏览器缓存](http://img.my.csdn.net/uploads/201303/19/1363670410_3844.jpg)


----

## cookie / csrf / xss

#### Cookie 机制（客户端）

因为 ```HTTP``` 协议是无状态的协议，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接

这就意味着服务器无法从连接上跟踪会话，所以利用 ```Cookie``` 来确认用户的身份

```Cookie``` 实际上是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，就使用 ```response``` 向客户端浏览器颁发一个 ```Cookie```，客户端浏览器会把 ```Cookie``` 保存起来

当浏览器再请求该网站时，浏览器把请求的网址连同该 ```Cookie``` 一同提交给服务器，服务器检查该 ```Cookie```，以此来辨认用户状态，服务器还可以根据需要修改 ```Cookie``` 的内容

#### Session 机制（服务端）

除了使用 ```Cookie```，```Web``` 应用程序中还经常使用 ```Session``` 来记录客户端状态，```Session``` 是服务器端使用的一种记录客户端状态的机制，使用上比 ```Cookie``` 简单一些，相应的也增加了服务器的存储压力

```Session``` 是另一种记录客户状态的机制，不同的是 ```Cookie``` 保存在客户端浏览器中，而 ```Session``` 保存在服务器上

客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 ```Session```，客户端浏览器再次访问时只需要从该 ```Session``` 中查找该客户的状态就可以了

如果说 ```Cookie``` 机制是通过检查客户身上的 "通行证" 来确定客户身份的话，那么 ```Session``` 机制就是通过检查服务器上的 "客户明细表" 来确认客户身份，```Session``` 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了

> ```Session``` 对象是在客户端第一次请求服务器的时候创建的


#### XSS

全名是：```Cross-site scripting```，为了和 ```CSS``` 层叠样式表区分所以取名 ```XSS```

```XSS``` 其实就是 ```Html``` 的注入问题，攻击者的输入没有经过严格的控制进入了数据库，最终显示给来访的用户，导致可以在来访用户的浏览器里以浏览用户的身份执行 ```Html``` 代码，工作原理大致如下

```
攻击者发现 XSS 漏洞 —— 构造代码 —— 发送给受害人 —— 受害人打开 —— 攻击者获取受害人的 cookie —— 完成攻击
```

当用户的 ```cookie``` 被拿到以后，如果服务端 ```session``` 没有设置过期的话，以后甚至拿这个 ```cookie``` 而不需用户名密码，就可以以这个用户的身份登录成功了

但是 ```XSS``` 容易发现，因为攻击者需要登录后台完成攻击，管理员可以看日志发现攻击者


#### CSRF

全名是：```Cross-site request forgery```，中文名称：跨站请求伪造，与 ```XSS``` 非常不同，```XSS``` 利用站点内的信任用户，而 ```CSRF``` 则通过伪装来自受信任用户的请求来利用受信任的网站

与 ```XSS``` 攻击相比，```CSRF``` 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比 ```XSS``` 更具危险性

可以这么理解 ```CSRF``` 攻击：攻击者盗用了你的身份，以你的名义发送恶意请求

要完成一次 ```CSRF``` 攻击，受害者必须依次完成两个步骤：

* 登录受信任网站 ```A```，并在本地生成 ```Cookie```

* 在不登出 ```A``` 的情况下，访问危险网站 ```B```

```CSRF``` 攻击是源于 ```WEB``` 的隐式身份验证机制，```WEB``` 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的

#### 防御

可以从服务端和客户端两方面着手，总的思想都是一致的，就是在客户端页面增加伪随机数，让钓鱼网站无法正常伪造请求


----


## http/2

包括二进制帧，多路复用，请求优先级，流量控制，服务器端推送以及首部压缩等新改进

#### 二进制协议

```http/1.1``` 版本的头信息肯定是文本（```ASCII``` 编码），数据体可以是文本，也可以是二进制，```http/2``` 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为 "帧"(```frame```)，头信息帧 和 数据帧
在二进制分帧层中， ```HTTP/2``` 会将所有传输的信息分割为更小的消息和帧（```frame```）,并对它们采用二进制格式的编码 ，其中 ```HTTP1.x``` 的首部信息会被封装到 ```HEADER frame```，而相应的 ```Request Body``` 则封装到 ```DATA frame``` 里面

```HTTP/2``` 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流

总结：

```
单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大

由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快
```

#### 多工

```http/2``` 复用 ```TCP``` 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"

例如在一个 ```TCP``` 连接里面，服务器同时收到了 ```A``` 请求和 ```B``` 请求，于是先回应 ```A``` 请求，结果发现处理过程非常耗时，于是就发送 ```A``` 请求已经处理好的部分， 接着回应 ```B``` 请求，完成后，再发送 ```A``` 请求剩下的部分

这样双向的、实时的通信，就叫做多工（```Multiplexing```）



#### 数据流（连接共享）

因为 ```http/2``` 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应，因此，必须要对数据包做标记，指出它属于哪个回应

```http/2``` 将每个请求或回应的所有数据包，称为一个数据流（```stream```）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ```ID```，用来区分它属于哪个数据流

另外还规定，客户端发出的数据流，```ID``` 一律为奇数，服务器发出的，```ID``` 为偶数

数据流发送到一半的时候，客户端和服务器都可以发送信号（```RST_STREAM``` 帧），取消这个数据流。```1.1``` 版取消数据流的唯一方法，就是关闭 ```TCP``` 连接。这就是说，```http/2``` 可以取消某一次请求，同时保证 ```TCP``` 连接还打开着，可以被其他请求使用

```http/2``` 里的每个 ```stream``` 都可以设置又优先级（```Priority```）和依赖（```Dependency```）。优先级高的 ```stream``` 会被 ```server``` 优先处理和返回给客户端，```stream``` 还可以依赖其它的 ```sub streams```（优先级和依赖都是可以动态调整的）

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应


#### 头信息压缩

```http``` 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 ```Cookie``` 和 ```User Agent```，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度

```http/2``` 对这一点做了优化，使用了专门为首部压缩而设计的 ```HPACK``` 算法，引入了头信息压缩机制（```header compression```）。一方面，头信息使用 ```gzip``` 或 ```compress``` 压缩后再发送

另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了



#### 服务器推送

```http/2``` 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（```server push```）

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 ```html``` 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了


----


## HTTP 协议（三层握手/四次挥手）

见 [HTTP 与 TCP](http://heptaluan.com/?p=803)

----

## 域名发散与收敛

见 [域名发散与收敛](http://heptaluan.com/?p=2297)

----


## SEO

#### META 标签

```META``` 标签主要用于 ```SEO``` 优化，让搜索引擎能够发现你的页面，要让搜索引擎找到你，需要添加 ```Keywords``` 和 ```description``` 的 ```meta``` 标签

```html
<meta name="keywords" content="MP4, music, MP3"/>

<meta name="description" content="音乐,电影,视频"/>  
```

其他方法：

* 关键字隐藏在页面里，设定字体颜色跟背景一样

* 图片资源的 ```alt``` 属性里添加关键字（```<img src="..." alt="keywords">```）

* 在 ```html``` 注释中添加关键字


#### 正向代理与反向代理

**正向代理**

正向代理是位于客户端和原始服务器之间的服务器，为了能够从原始服务器获取请求的内容，客户端需要将请求发送给代理服务器，然后再由代理服务器将请求转发给原始服务器，原始服务器接受到代理服务器的请求并处理，然后将处理好的数据转发给代理服务器，之后再由代理服务器转发发给客户端，完成整个请求过程

![正向代理](http://images0.cnblogs.com/blog2015/456795/201507/051157002507977.jpg)

**反向代理**

反向代理方式是指代理原始服务器来接受来自 ```Internet``` 的链接请求，然后将请求转发给内部网络上的原始服务器，并将从原始服务器上得到的结果转发给 ```Internet``` 上请求数据的客户端

顾名思义，反向代理就是位于 ```Internet``` 和原始服务器之间的服务器，对于客户端来说就表现为一台服务器，客户端所发送的请求都是直接发送给反向代理服务器，然后由反向代理服务器统一调配

![反向代理](http://images0.cnblogs.com/blog2015/456795/201507/051215042498342.jpg)

**性能优化之反向代理**

和传统的代理服务器一样，反向代理服务器也有保护网站安全的作用，来自互联网的请求必须经过反向代理服务器，相当于在原始服务器之间增加一道屏障

除了安全功能，反向代理服务器也可以通过配置缓存功能加速 ```web``` 请求，当用户第一次访问静态内容的时候，静态内容就被缓存在反向代理服务器上，下一次用户请求静态资源时，直接从反向代理服务器返回静态内容，加速 ```web``` 请求访问速度，减轻原始服务器的压力

此外，反向代理服务器也可实现负载均衡的功能，而通过负载均衡构建应用集群可以提高系统的总处理能力，进而改善网站在高并发情况下的性能


----

## http 协议头

通常 ```HTTP``` 消息包括客户机向服务器的请求消息和服务器向客户机的响应消息，这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成

```HTTP``` 的头域包括通用头，请求头，响应头和实体头四个部分，每个头域由一个域名，冒号（:）和域值三部分组成，域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符

#### 通用头域 

通用头域包含请求和响应消息都支持的头域，通用头域包含 ```Cache-Control```、 ```Connection```、```Date```、```Pragma```、```Transfer-Encoding```、```Upgrade```、```Via```

对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理

#### 一些 HTTP 扩展消息头

```js
Expires             // 设置页面过期时间，格林威治时间 GMT

Cache-Control       // 更细致的控制缓存的内容

Last-Modified       // 请求对象最后一次的修改时间 用来判断缓存是否过期 通常由文件的时间信息产生 

ETag                // 响应中资源的校验值，在服务器上某个时段是唯一标识的，ETag 是一个可以 与 Web 资源关联的记号（token），和 Last-Modified 功能才不多，也是一个标识符，一般和 Last-Modified 一起使用，加强服务器判断的准确度

Date                // 服务器的时间

If-Modified-Since   // 客户端存取的该资源最后一次修改的时间，用来和服务器端的 Last-Modified 做比较

If-None-Match       // 客户端存取的该资源的检验值，同 ETag
```

```Cache-Control``` 的主要参数 

```js
Cache-Control: private/public Public   // 响应会被缓存，并且在多用户间共享，Private 响应只能够作为私有的缓存，不能再用户间共享

Cache-Control: no-cache                // 不进行缓存 

Cache-Control: max-age=x               // 缓存时间 以秒为单位 

Cache-Control: must-revalidate         // 如果页面是过期的 则去服务器进行获取
```