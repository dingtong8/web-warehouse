## jQuery 插件中的 return this.each()

原理是通过返回当前对象，来维护链式调用

同时也是是为了保证遍历完成后才执行下一个操作，否则迭代是延迟执行的，前面的插件并没有实际执行，而且 ```each``` 返回的也是 ```this``` 对象（还可以带 ```function``` 参数）

简单来说就是一个是先返回在执行，一个是先执行在返回

看下面代码就明白了：

```js
return this.each(function () {
  $(this).append(' - ' + $(this).data('x'));
});

// 等价于

var objs = this;

for (var i = 0; i < objs.length; i++) {
  var obj = objs[i];
  $(obj).append(' - ' + $(obj).data('x'));
};

return this;
```


----


## jQuery 中的 this 和 $(this)

其实同 ```jQuery``` 中的 ```get()``` 和 ```eq()``` 类似，```$(this)``` 返回的是一个 ```jQuery``` 对象，而 ```this``` 返回的其实就是一个 ```element```，看下面代码

```js
// 这样使用是可以的，this 返回的是一个 element，有 title 属性
$('#box').hover(function () {
  this.title = 'A'
}, function () {
  this.title = 'B'
})

// 这样就会报错，$(this) 返回的是一个 jQuery 对象，没有 title 属性
$('#box').hover(function () {
  $(this).title = 'A'
}, function () {
  $(this).title = 'B'
})

// 换成这样就可以了
// 建议如果已经使用了 jQuery，那就统一使用 $(this) 而不再用 this 应该是比较不错的选择
$('#box').hover(function () {
  $(this).attr('title', 'A')
}, function () {
  $(this).attr('title', 'B')
})
```


----


## jQuery 的链式操作是如何实现的

简单来说，仅仅是通过对象上的方法最后 `return this` 把对象再返回回来，这样一来就可以链式操作了

一个简单的模拟

```js
// 定义初始类
function Foo() { }

// 扩展它的 prototype 
Foo.prototype = {

  setName: function (name) {
    this.name = name;
    return this;
  },

  getName: function () {
    return this.name;
  },

  setAge: function (age) {
    this.age = age;
    return this;
  }

};

// 链式调用 
new Foo().setName('abc').setAge(20);  // Foo {name: 'abc', age: 20}
```



----

## $.fn.each() 和 Array.prototype.forEach()

```jQuery``` 定义在 ```$.fn``` 上的 ```each()``` 和 ```map()``` 方法与定义在 ```Array.prototype``` 上的原生方法 ```forEach()``` 和 ```map()``` 对应，它们的参数都是回调函数，但它们的回调函数定义有一些细节上的差别

```$.fn.each()``` 的回调定义如下：

```js
Function(Integer index, Element element )
```

回调的**第一个**参数是数组元素所在的位置（序号，从 ```0``` 开始），**第二个**参数是元素本身

而 ```Array.prototype.forEach()``` 的回调定义是：

```js
Function(currentValue, index, array)
```

回调的**第一个**参数是数组元素本身，**第二个**参数才是元素所有的位置（序号），而且这个回调有**第三个**参数，即整个数组的引用