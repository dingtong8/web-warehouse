`JavaScript` 中的命名空间，变量声明提升，作用域和预编译

----


## 命名空间

`JavaScript` 中没有命名空间这个概念的，只能模拟实现，命名空间的使用可以显著减少命名冲突，并很好的组织代码，如下一个简单的示例

```js
var namespace = namespace || {};

namespace.AModule = {};
namespace.AModule.name = 'abc';
namespace.BModule = {};
```


## 变量声明提升

声明：是指你声称某样东西的存在，比如一个变量或一个函数，但你没有说明这样东西到底是什么，仅仅是告诉解释器这样东西存在而已

定义：是指你指明了某样东西的具体实现，比如一个变量的值是多少，一个函数的函数体是什么，确切的表达了这样东西的意义

```js
var a;  // 这是声明
a = 1;  // 这是定义（赋值）
var a = 1;  // 合二为一：声明变量的存在并赋值给它
```

当你以为你只做了一件事情的时候（`var a = 1`），实际上解释器把这件事情分解成了两个步骤

一个是声明（`var a`），另一个是定义（`a = 1`）

#### 两个示例

```js
var a = 1;
 
function foo () {
    if (!a) {
        var a = 2;
    }
    alert(a);
};
 
foo();  // 输出 2
```

简单的调整一下

```js
var a;
a = 1;
 
function foo() {
    var a;  // 关键在这里
    if (!a) {
        a = 2;
    }
    alert(a);  // 此时的 a 并非函数体外的那个全局变量
}

foo()
```

如代码所示，在进入函数体后解释器声明了新的变量 `a`，而无论 `if` 语句的条件如何，都将为新的变量 `a` 赋值为 `2`



## 作用域

`JavaScript` 在 `ES6` 之前是没有块级作用域的（`Block Scoping`），只有函数作用域（`Function Scoping`）

当解析器读到 `if` 语句的时候，它发现此处有一个变量声明和赋值，于是解析器会将其声明提升至当前作用域的顶部（这是默认行为，并且无法更改），这个行为就叫做 `Hoisting`

> `JavaScript` 只有函数作用域！

若是想要 `alert(a)` 弹出那个 `1` 则可以创建有一个新的作用域，可以使用立即执行函数

```js
var a = 1;
 
function foo() {
 
    // 这个就是 IIFE，它会创建一个新的函数作用域
    // 并且该作用域在 foo() 的内部，所以 alert 访问不到
    // 不过这个作用域可以访问上层作用域，这就叫：闭包
    if (!a) {
        (function() {  
            var a = 2; 
        }());               
    };
 
    alert(a);
 
};
 
foo();
```

> '请始终保持作用域内所有变量的声明放置在作用域的顶部' 不是没有道理的

因为这样可以避免 `Hoisting` 特性给你带来的困扰，也可以很明确的告诉所有阅读代码的人（包括你自己）在当前作用域内有哪些变量可以访问

但是，变量声明的提升并非 `Hoisting` 的全部

在 `JavaScript` 中，有四种方式可以让命名进入到作用域中（按优先级）

* 语言定义的命名：比如 `this` 或者 `arguments`，它们在所有作用域内都有效且优先级最高，所以在任何地方你都不能把变量命名为 `this` 之类的，这样是没有意义的

* 形式参数：函数定义时声明的形式参数会作为变量被 `hoisting` 至该函数的作用域内，所以形式参数是本地的，不是外部的或者全局的，当然你可以在执行函数的时候把外部变量传进来，但是传进来之后就是本地的了

* 函数声明：函数体内部还可以声明函数，不过它们也都是本地的了

* 变量声明：这个优先级其实还是最低的，不过它们也都是最常用的




#### 预编译

`JavaScript` 引擎并不是读一句执行一句，而是读取一段、解释执行一段，而一段一段执行，`JavaScript` 会对读取的这段 `JavaScript` 代码整体有个预处理，这个预处理就是所谓的预编译

预编译阶段，`JavaScript` 引擎会进行变量提升，这里就会涉及到变量对象

`JavaScript` 解释器之所以可以找到我们定义的函数和变量，全部依靠的变量对象（`Variable Object`，缩写为 `VO`）是一个抽象概念中的"对象"，它用于存储执行上下文中

1. 变量

2. 函数声明

3. 函数参数

`VO` 按照如下顺序填充：

1. 函数参数（若为传入，初始化该参数值为 `undefined`）

2. 函数声明（若发生命名冲突，会覆盖）

3. 变量声明（初始化变量值为 `undefined`，若发生命名冲突，会忽略）


看以下几个实例

```js
function foo (x, y, z) {
  function x () {};
  alert(x);   // function x () {}
}

 
foo(100);
```

在初始化阶段，先初始化函数的参数，参数 `x` 即为传进来的参数，为 `100`，但是在处理函数声明的时候，发生冲突，`x` 会被覆盖，所以返回的是一个函数对象

```js
// var fn 的时候，发现 fn 已经在函数声明的时候定义过了，所以会忽略
function foo (x, y, z) {
    function fn () {};
    var fn;
    console.log(fn);    // function fn () {}
}
 
foo(100);
 
// 跟上例是一样的，但是在代码执行阶段，fn 会被执行赋值操作
function foo (x, y, z) {
    function fn () {};
    var fn = 1;
    console.log(fn);    // 1
}
 
foo(100);
 
// 在看一个容易出错的，最终会输出 100 和 0
var num = 0;
 
function a (num) {
    num = 100;
    console.log(num);
}
 
a();
console.log(num);
```

函数表达式不会影响 `VO`，比如 `var a = function foo(){}`

这里的 `foo` 是函数表达式的名称，这个是不会记录到 `AO` 中的，这也是为什么我们不能在外部通过 `foo` 来获取到这个函数对象
