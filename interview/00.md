













#### 隐式转换的种种规则

[`JavaScript` 中的 == 和 ===](http://hanekaoru.com/?p=1807)


#### 对象的属性可能有哪些特性(attribute)？

[`JavaScript` 中对象的属性的特性](https://www.cnblogs.com/yugege/p/4823863.html)


#### 原型链

[`JavaScript` 中的原型和原型对象](http://hanekaoru.com/?p=2272)

[constructor、__proto__ 和 prototype 区别和关系](http://hanekaoru.com/?p=1880)


#### 类型检测以及异常避免

[`JavaScript` 中的类型检测](http://hanekaoru.com/?p=1677)

#### 工厂模式

[`JavaScript` 笔记(对象)](http://hanekaoru.com/?p=699)


<!-- 数组几个API的手工实现 -->

<!-- 正则 -->


#### 事件

[`JavaScript` 中的事件处理](http://hanekaoru.com/?p=266)




#### `JavaScript` 获得随机 unicode 字符

```js
String.fromCharCode(Math.floor(Math.random()*9999));
```











#### call 和 apply 的第一个参数

`call` 和 `apply` 用来改变函数的执行上下文（`this`），它们的第一个参数 `thisArg` 是个对象，即作为函数内的 `this`

在多数时候你传递什么给函数，那么它就是什么

```js
function fun() {
  alert(this);
}

fun.call(1);                // 1

fun.call('a');              // a

fun.call(true);             // true

fun.call({name: 'aaa'});    // [object Object]
```

有两种情况需要注意，传递 `null` 或 `undefined` 时，执行环境会是全局的（`window/global`）

可以参考[规范 15.3.4.4](http://lzw.me/pages/ecmascript/#323)

```js
fun.call(null);       // window
fun.call(undefined);  // window
```

但是在严格模式下，给 `call` 和 `apply` 传入的任何参数不再会转换

```js
'use strict'
function fun() {
  alert(this);
}

fun.call(null);        // null
fun.call(undefined);   // undefined
```


#### bind 简单实现

```js
if (!Function.prototype.bind) {
  Function.prototype.bind = function () {
    var self = this,                        // 保存原函数
      context = [].shift.call(arguments),   // 保存需要绑定的 this 上下文
      args = [].slice.call(arguments);      // 剩余的参数转为数组
    return function () {                    // 返回一个新函数
      self.apply(context,[].concat.call(args, [].slice.call(arguments)));
    }
  }
}
```








## DOM 操作

#### getElementsByClassName

```js
function getElementsByClassName(classname) {
  if (document.querySelectorAll) {
    return document.querySelectorAll('.' + classname);
  } else {
    var elements = document.getElementsByTagName('*');
    var reg = new RegExp('(^|\\s)' + classname + '(\\s|$)');
    var results = [];
    for (let i = 0, length = elements.length; i < length; i++) {
      if (reg.test(elements[i].className)) {
        results.push(elements[i]);
      }
    }
  }

  return results;
}
```








## CSS 操作

## 伪类和伪元素的区别 && 如何操作 CSS 的伪类和伪元素

https://segmentfault.com/a/1190000003711146

http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/



## 如何检测改浏览器是否支持某个 CSS3 的特性

这个判断的原理是，创建一个节点，判断 `style` 属性是否含有指定的 `CSS3` 属性，有则进一步判断是否支持这个属性的某个值，比如

`text-overflow` 这个属性，`text-flow：clip` 是大部分浏览器都支持的，而 `text-flow：ellipsis` 则在 `firefox` 和 `10.6` 版本以下的 `opera` 上工作不了

判断代码如下

```js
// 创建一个节点
var element = document.createElement('div');

if('textOverflow' in element.style){
  element.style['textOverflow'] = 'ellipsis';
  return element.style['textOverflow'] === 'ellipsis';
}else{
  return false;
}
```

判断是否支持 `ellipsis` 值依靠的是浏览器对于非法 style 值的处理，当遇到不支持的属性值时，浏览器会直接把这个值抛弃

因此这里就可以先给 `textOverflow` 赋值 `'ellipsis'`，如果不支持，则其值肯定为空或者其它不等于 `'ellipsis'` 的值

因此只要判断赋值后的 `textOverflow` 是否等于 `'ellipsis'` 即可





## ajax 操作

#### GET 和 POST 的区别及使用要点 && 跨域

https://github.com/hanekaoru/WebLearningNotes/blob/master/interview/js/39.md



## http 协议（格式、状态码），cookie 操作

[cookie 的 domain 参数详解](https://blog.csdn.net/ni_hao_ya/article/details/21158887)

[Cookie 存取值和域（domain）](https://blog.csdn.net/qq_16559905/article/details/50916140)

[http 403](https://blog.csdn.net/qq_16559905/article/details/80356333)

[Referrer 还是 Referer？](https://imququ.com/post/referrer-or-referer.html)

[http](https://imququ.com/post/referrer-policy.html)





## 性能
