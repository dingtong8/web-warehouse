

#### 隐式转换的种种规则

[`JavaScript` 中的 == 和 ===](http://hanekaoru.com/?p=1807)

#### 对象的属性可能有哪些特性(attribute)？

[`JavaScript` 中对象的属性的特性](https://www.cnblogs.com/yugege/p/4823863.html)

#### 原型链

[`JavaScript` 中的原型和原型对象](http://hanekaoru.com/?p=2272)

[constructor、__proto__ 和 prototype 区别和关系](http://hanekaoru.com/?p=1880)

#### 类型检测以及异常避免

[`JavaScript` 中的类型检测](http://hanekaoru.com/?p=1677)

#### 工厂模式

[`JavaScript` 笔记(对象)](http://hanekaoru.com/?p=699)

#### 事件

[`JavaScript` 中的事件处理](http://hanekaoru.com/?p=266)

## CSS 操作

## 伪类和伪元素的区别 && 如何操作 CSS 的伪类和伪元素

https://segmentfault.com/a/1190000003711146

http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/


## ajax 操作

#### GET 和 POST 的区别及使用要点 && 跨域

https://github.com/hanekaoru/WebLearningNotes/blob/master/interview/js/39.md


## http 协议（格式、状态码），cookie 操作

[cookie 的 domain 参数详解](https://blog.csdn.net/ni_hao_ya/article/details/21158887)

[Cookie 存取值和域（domain）](https://blog.csdn.net/qq_16559905/article/details/50916140)

[http 403](https://blog.csdn.net/qq_16559905/article/details/80356333)

[Referrer 还是 Referer？](https://imququ.com/post/referrer-or-referer.html)

[http](https://imququ.com/post/referrer-policy.html)


## 性能







Javascript命名空间和模块

[Javascript命名空间和模块](https://www.kenneth-truyers.net/2013/04/27/javascript-namespaces-and-modules/)






[hasOwnProperty 和 propertyIsEnumerable 的区别？](https://www.zhihu.com/question/21907133)




----

----


## 高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度

https://segmentfault.com/q/1010000000762512/a-1020000000762933



## 正则表达式

去除所有的html

```js
var con = content.replace(/<[^>]+>/g,'');
```

去除空格

```js
var con = content.replace(/\s/g,'');
```

判断输入的是否为数字

```js
var reg=/^\d+(\.\d+)?$/;
​
if(reg.test(title) == true){
  alert("内容不能为纯数字，请从新输入！");
  return false;
}
```

取括号中的数值

```js
/\(([^()]+)\)/g.exec('add(18)')
```

千位分隔符（整数）

```js
var a = "-1234454654645645";

a = a.replace(/(\d)(?=(\d{3})+$)/g,"$1,");

console.log(a);
```

















## 实例

找出数字数组中最大的元素（使用Match.max函数）

```js
Math.max.apply(null, arr);
```


转化一个数字数组为function数组（每个function都弹出相应的数字）

```js
var arr = [3, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
  var index = arr[i];
  (function (index) {
    arr[i] = function () {
      alert(index);
    }
  })(index)
}

arr[0]();
```


给object数组进行排序（排序条件是每个元素对象的属性个数）

```js
Object.prototype.getLength = function () {
  var num = 0;
  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      num++;
    }
  }
  return num;
}

var a = {
  name: 'a',
  age: 10,
  location: 'b'
};

var b = {
  name: 'c'
};

var c = {
  name: 'd',
  sex: 'e'
};

var arr = [a, b, c];

arr.sort(function (a, b) {
  return a.getLength() > b.getLength();
})

console.log(arr);
```


利用JavaScript打印出Fibonacci数（不使用全局变量）

```js
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
function fn(n) {
  var a = [];
  a[0] = 0, a[1] = 1;
  for (var i = 2; i < n; i++) {
    a[i] = a[i - 1] + a[i - 2];
  }
  for (var i = 0; i < n; i++) {
    console.log(a[i]);
  }
}

fn(20);
```


实现如下语法的功能：var a = (5).plus(3).minus(6);    //2

```js
Number.prototype.plus = function (a) {
  return this + a;
};

Number.prototype.minus = function (a) {
  return this - a;
};

var a = (5).plus(3).minus(6);

console.log(a);
```


实现如下语法的功能：var a = add(2)(3)(4);    //9

```js
function add(a) {
  var temp = function (b) {
    return add(a + b);
  }
  temp.valueOf = temp.toString = function () {
    return a;
  };
  return temp;
}
var ans = add(2)(3)(4);

console.log(ans);
```



## IE和FireFox之间常用兼容方法

0. 鼠标坐标加上滚动条滚过的距离 
IE：event.offsetX和event.offsetY 
FF：event.layerX和event.layerY 
解决办法： 

function mouseDownHandler(event) { 
    var event = event || window.event; 
    //var event = event ? event : window.event; 
    var x = event.offsetX || event.layerX; 
    var y = event.offsetX || event.layerY; 
} 

1.window.event 
IE：有window.event对象 
FF：没有window.event对象，可以通过函数的参数传递event对象。如onclick=clickHandler(event) 
解决办法：var event = event || window.event; 

2. 鼠标当前坐标 
IE：event.x和event.y 
FF：event.pageX和event.pageY 
解决办法：采用通用属性：event.clientX和event.clientY属性; 

3. event.srcElement 
IE：event对象有srcElement属性，但是没有target属性； 
FF：event对象有target属性，但没有srcElement属性 
解决办法：
//使用
obj = event.srcElement ? event.srcElement : event.target;

//来代替IE下的
event.srcElement

//或者FF下的（注意event的兼容性）; 
event.target

4.event.toElement 
IE：event对象有toElement属性，但没有relatedTarget属性 
FF：event对象没有有toElement属性，但有relatedTarget属性 
解决办法：var target = e.relatedTarget || e.toElement; 

5. 标签的x和y的坐标位置，style.posLeft 和 style.posTop 
IE：有 
FF：没有 
解决办法：用通用属性obj.offsetLeft 和 obj.offsetTop 

6. 窗体的高度和宽度 
IE：document.body.offsetWidth 和 document.body.offsetHeight。注意，此时页面一定要有body标签。 
FF：window.innerWidth 和 window.innerHeight，以及 document.documentElement.clientWidth 和 document.documentElement.clientHeight。 
解决办法：通用属性 document.body.clientWidth 和 document.body.clientHeight； 

7. 添加事件 
IE：element.attachEvent('onclick',function) 
FF：element.addEventListener('click',function,true) 
解决办法：element.onclick = function.虽然都可以使用click事件。但onclick和上面两种方法效果是不一样的。onclick只有执行一个过程，而attachEvent 和 addEventListener执行的是一个过程列表，也就是多个过程。 
如：element.attachEvent('onclick',func1); element.attachEvent("onclick", func2)这样func1和func2都会被执行。 

8. 标签的自定义属性 
IE：如果给标签div1定义了一个属性value，可以div1.value 和 div1["value"]取得该值 
FF：不能用div1.value 和div1["value"] 
解决办法：div1.getAttribute('value') 

9. document.form.item 
IE：现有问题，document.formName.item("itemName") 这样的语句，不能在 FF 下运行 
FF：不支持 
解决办法： document.formName.elements["elementName"] 

10. 集合/数组类对象问题 
IE：有许多集合类对象取用时用() 
FF：不能这样取用 
解决办法：改用[]作为下标运算。 
如：document.forms("formName") 改为 document.forms["formName"]。document.getElementsByName("inputName")(1) 改为 document.getElementsByName("inputName")[1] 

11. HTML对象的id作为对象名的问题 
IE：HTML对象的id可以作为document的下属变量名直接使用 
FF：需要用getElementById()方法 
解决办法：用getElementById('idName')代替idName作为对象变量使用 

12. 用idName字符串取得对象的问题 
IE：利用eval(idName)可以取得 id 为 idName 的HTML对象。 
FF：不支持 
解决办法：getElementById(idName) 代替 eval(idName) 

13. 变量名与某 HTML 对象 id 相同的问题 
IE：因为HTML对象id 在IE中直接调用，所以变量名不能和id相同 
FF：可以使用变量名和id相同 
解决办法，声明变量时一律加上 var ，以避免歧义(最好id和变量名不要相同)。 

14. document.getElementsByName() 和 document.all[name] 
IE：getElementsByName()、document.all[name] 均不能用来取得 div 元素 
FF：可以兼容document.all， 但会生成一条警告。 
解决办法：可以用getElementById() 或者 getElementByTagName()来代替 

15. input.type属性问题 
IE：input.type属性为只读 
FF：input.type属性为读写 

16. window.location.href 
IE：（FF2.0以下），可以使用window.location 或 window.location.href ; FF 1.5下只能使用window.location 
解决办法：使用window.location 来代替 window.location.href 

17. 模态和非模态窗口问题 
IE：可以通过 showModalDialog 和 showModelessDialog 打开模态和非模态窗口 
FF：不支持 
解决办法：直接使用window.open(pageURL, name, parameters) 方式打开新窗口，如果需要将子窗口中的参数传递回父窗口，可以在子窗口中使用window.opener来访问父窗口。 
如：var parWin = window.opener; parWin.document.getElementById('title').value = 'My Title'; 

18. body 
IE：body必须在body标签被浏览器完全读入后才存在 
FF：body在body标签没有被浏览器完全读入之前就存在 

19. 事件委托方法 
IE：document.body.onload = init; 
FF：document.body.onload = init(); 
解决办法：统一使用 document.body.onload = new Function('init()'); 或者 docuement.body.onload = function(){/* 这里是代码 */} 

20. 父元素的区别 
IE：obj.parentElement; 
FF ：obj.parentNode 
解决办法：因为FF与IE都支持DOM，所以可以都使用obj.parentNode 

22.innerText在IE中能正常工作，但是innerText在FF中却不行. 需用textContent 

23. FF中设置HTML标签的style时，所有位置性和字体尺寸的值必须后跟px。这个IE也是支持的 

24. 父节点、子节点和删除节点 
IE：parentElement、parement.children，element.romoveNode(true)。 
FF：parentNode、parentNode.childNodes，node.parentNode.removeChild(node)。














## position & left & display & bfc 等等 tips

float也是典型的inline-block化元素，这种元素的inline-block化适用于任何水平的标签。

例如一个div标签默认宽度是100%显示的，但是一旦被absolute属性缠上，则100%默认宽度就会变成自适应内部元素的宽度。
但是，有float:left/position:absolute撑腰的情况下，display属性就是多余的，可以直接回家喝茶了。

```css
span { float:left; width:100px; }
span { position:absolute; width:100px; }
```

动画效果应用到position属性为absolute或fixed的元素上

动画效果应用到position属性为absolute或fixed的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。

百分比是相对单位，比方说translate是自身，width/height是父级，background-position需要尺寸差计算等。

圆角：border-垂直-水平-radius: 水平 垂直

vertical-align的百分比值不是相对于字体大小或者其他什么属性计算的，而是相对于line-height计算的。举个简单的例子，如下CSS代码：

```css
{
  line-height: 30px;
  vertical-align: -10%;
}
```

实际上，等同于：

```css
{
  line-height: 30px;
  vertical-align: -3px;    /* = 30px * -10% */  
}
```

vertical-align  block化就无效了

line boxes 一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。

![](1.png)

在目前的CSS的世界中，所有的高度都是有两个CSS模型产生的，一个是box盒状模型，对应CSS为”height+padding+margin”，另外一个是line box模型，对应样式为”line-height”。前者的height属性分为明显的height值和隐藏的height值，所谓隐藏的height值是指图片的高度，一旦载入一张图片，其内在的height值就会起作用，即使您看不到”height”这个词。而后者针对于文字等这类inline boxes的元素（图片也属于inline boxes，但其height比line-height作用更凶猛，故其inline boxes高度等于其自身高度，对line-height无反应），inline boxes的高度直接受line-height控制（改变line-height文字拉开或重叠就是这个原因），而真正的高度表现则是由每行众多的inline boxes组成的line boxes（等于内部最高的inline box的高度），而这些line boxes的高度垂直堆叠形成了containing box的高度，也就是我们见到的div或是p标签之类的高度了。所以，对于line box模型的元素而言，没有inline boxes，就没有高度了，而浮动却恰恰做了这么龌龊的事情，其直接将元素的inline boxes也破坏了，于是这些元素也就没有了高度。

浮动布局会让父标签高度缺失

![](2.png)

清除浮动其实就一个目的，就是解决高度塌陷的问题。为什么会高度塌陷？什么时候会高度塌陷？塌陷原因是：元素含有浮动属性 – 破坏inline box – 破坏line box高度 – 没有高度 – 塌陷。什么时候会塌陷：当标签里面的元素只要样子没有实际高度时会塌陷。所以呢，并不是只要有浮动元素就会坍塌，就要清除的


float与JavaScript
JavaScript可以改变CSS的属性，其他些属性还好，但是这个float值得一说，为何呢，因为float貌似是JavaScript中的一个关键字，不能使用obj.style.float="left";这样的句子。得使用其他写法。

IE浏览器：
```css
obj.style.styleFloat = "left";
```
其他浏览器：
```css
obj.style.cssFloat = "left";
```

CSS的margin塌陷（collapse） 

![](3.jpg)


因为CSS中存在一个margin collapse，即边界塌陷或者说边界重叠。对于上下两个并列的div块而言，上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值，所以从这个意义上说：CSS及浏览器的设计者们希望我们在布局时，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。
    但对于父块DIV内含子块DIV的情况，就会按另一条CSS惯例来解释了，那就是：对于有块级子元素的元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离。

结论：
    解决父子DIV中顶部margin cllapse的问题，需要给父div设置：
    1、边框，当然可以设置边框为透明;
    2、为父DIV添加padding，或者至少添加padding-top;
    此外，还可以通过over-flow:hidden来解决

    
----

----



