

#### 隐式转换的种种规则

[`JavaScript` 中的 == 和 ===](http://hanekaoru.com/?p=1807)

#### 对象的属性可能有哪些特性(attribute)？

[`JavaScript` 中对象的属性的特性](https://www.cnblogs.com/yugege/p/4823863.html)

#### 原型链

[`JavaScript` 中的原型和原型对象](http://hanekaoru.com/?p=2272)

[constructor、__proto__ 和 prototype 区别和关系](http://hanekaoru.com/?p=1880)

#### 类型检测以及异常避免

[`JavaScript` 中的类型检测](http://hanekaoru.com/?p=1677)

#### 工厂模式

[`JavaScript` 笔记(对象)](http://hanekaoru.com/?p=699)

#### 事件

[`JavaScript` 中的事件处理](http://hanekaoru.com/?p=266)

## CSS 操作

## 伪类和伪元素的区别 && 如何操作 CSS 的伪类和伪元素

https://segmentfault.com/a/1190000003711146

http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/


## ajax 操作

#### GET 和 POST 的区别及使用要点 && 跨域

https://github.com/hanekaoru/WebLearningNotes/blob/master/interview/js/39.md


## http 协议（格式、状态码），cookie 操作

[cookie 的 domain 参数详解](https://blog.csdn.net/ni_hao_ya/article/details/21158887)

[Cookie 存取值和域（domain）](https://blog.csdn.net/qq_16559905/article/details/50916140)

[http 403](https://blog.csdn.net/qq_16559905/article/details/80356333)

[Referrer 还是 Referer？](https://imququ.com/post/referrer-or-referer.html)

[http](https://imququ.com/post/referrer-policy.html)


## 性能









[hasOwnProperty 和 propertyIsEnumerable 的区别？](https://www.zhihu.com/question/21907133)




----

----


## 高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度

https://segmentfault.com/q/1010000000762512/a-1020000000762933



## 正则表达式

去除所有的html

```js
var con = content.replace(/<[^>]+>/g,'');
```

去除空格

```js
var con = content.replace(/\s/g,'');
```

判断输入的是否为数字

```js
var reg=/^\d+(\.\d+)?$/;
​
if(reg.test(title) == true){
  alert("内容不能为纯数字，请从新输入！");
  return false;
}
```

取括号中的数值

```js
/\(([^()]+)\)/g.exec('add(18)')
```

千位分隔符（整数）

```js
var a = "-1234454654645645";

a = a.replace(/(\d)(?=(\d{3})+$)/g,"$1,");

console.log(a);
```





## line-height:150% 和 line-height:1.5

父元素 line-height:150% -- 根据父元素的字体大小先计算出行高值然后再让子元素继承

子元素字体大小 = 父元素字体大小 * 150%

父元素 line-height:1.5 -- 根据子元素的字体大小动态计算出行高值让子元素继承

子元素字体大小 = 子元素字体大小 * 150%

## -webkit-appearance

其中-webkit-appearance: push-button;就是将按钮设置成iOS中默认原生控件的样式。

通常我们可以在相应的元素上加上

```css
-webkit-appearance : none;
```

来移除原生控件样式。

注意： 360浏览器若是添加该属性，input默认的checkbox框无法显示

兼容性 http://www.css88.com/webkit/-webkit-appearance/


## 清除选中样式

```js
// 改变默认选中的背景颜色 
::-moz-selection{background:#FF0000;color:#FFFFFF;}
::selection {background:#FF0000;color:#FFFFFF;}
code::-moz-selection {background:#FF0000;color:#FFFFFF;}
code::selection {background:#FF0000;color:#FFFFFF;}


// 设置页面禁止选中　　
/*全局*/
html,body{ 
  padding:0px; margin:0px; background:#fff; 
  moz-user-select: -moz-none;
  -moz-user-select: none;
  -o-user-select:none;
  -khtml-user-select:none; /* you could also put this in a class */
  -webkit-user-select:none;/* and add the CSS class here instead */
  -ms-user-select:none;
  user-select:none;/**禁止选中文字*/ 
}
```


## 火狐专有hack

```css
@-moz-document url-prefix(){.defaultmallsearchbt{padding:0 0 4px 16px;}} 
```


## link和@import

差别1：老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。
link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。


差别2：加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的 CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就 是闪烁），网速慢的时候还挺明显（梦之都加载CSS的方式就是使用@import，我一边下载一边浏览梦之都网页时，就会出现上述问题）。


差别3：兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。


差别4：使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。










## 实例

找出数字数组中最大的元素（使用Match.max函数）

```js
Math.max.apply(null, arr);
```


转化一个数字数组为function数组（每个function都弹出相应的数字）

```js
var arr = [3, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
  var index = arr[i];
  (function (index) {
    arr[i] = function () {
      alert(index);
    }
  })(index)
}

arr[0]();
```


给object数组进行排序（排序条件是每个元素对象的属性个数）

```js
Object.prototype.getLength = function () {
  var num = 0;
  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      num++;
    }
  }
  return num;
}

var a = {
  name: 'a',
  age: 10,
  location: 'b'
};

var b = {
  name: 'c'
};

var c = {
  name: 'd',
  sex: 'e'
};

var arr = [a, b, c];

arr.sort(function (a, b) {
  return a.getLength() > b.getLength();
})

console.log(arr);
```


利用JavaScript打印出Fibonacci数（不使用全局变量）

```js
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
function fn(n) {
  var a = [];
  a[0] = 0, a[1] = 1;
  for (var i = 2; i < n; i++) {
    a[i] = a[i - 1] + a[i - 2];
  }
  for (var i = 0; i < n; i++) {
    console.log(a[i]);
  }
}

fn(20);
```


实现如下语法的功能：var a = (5).plus(3).minus(6);    //2

```js
Number.prototype.plus = function (a) {
  return this + a;
};

Number.prototype.minus = function (a) {
  return this - a;
};

var a = (5).plus(3).minus(6);

console.log(a);
```


实现如下语法的功能：var a = add(2)(3)(4);    //9

```js
function add(a) {
  var temp = function (b) {
    return add(a + b);
  }
  temp.valueOf = temp.toString = function () {
    return a;
  };
  return temp;
}
var ans = add(2)(3)(4);

console.log(ans);
```



## IE和FireFox之间常用兼容方法

0. 鼠标坐标加上滚动条滚过的距离 
IE：event.offsetX和event.offsetY 
FF：event.layerX和event.layerY 
解决办法： 

function mouseDownHandler(event) { 
    var event = event || window.event; 
    //var event = event ? event : window.event; 
    var x = event.offsetX || event.layerX; 
    var y = event.offsetX || event.layerY; 
} 

1.window.event 
IE：有window.event对象 
FF：没有window.event对象，可以通过函数的参数传递event对象。如onclick=clickHandler(event) 
解决办法：var event = event || window.event; 

2. 鼠标当前坐标 
IE：event.x和event.y 
FF：event.pageX和event.pageY 
解决办法：采用通用属性：event.clientX和event.clientY属性; 

3. event.srcElement 
IE：event对象有srcElement属性，但是没有target属性； 
FF：event对象有target属性，但没有srcElement属性 
解决办法：
//使用
obj = event.srcElement ? event.srcElement : event.target;

//来代替IE下的
event.srcElement

//或者FF下的（注意event的兼容性）; 
event.target

4.event.toElement 
IE：event对象有toElement属性，但没有relatedTarget属性 
FF：event对象没有有toElement属性，但有relatedTarget属性 
解决办法：var target = e.relatedTarget || e.toElement; 

5. 标签的x和y的坐标位置，style.posLeft 和 style.posTop 
IE：有 
FF：没有 
解决办法：用通用属性obj.offsetLeft 和 obj.offsetTop 

6. 窗体的高度和宽度 
IE：document.body.offsetWidth 和 document.body.offsetHeight。注意，此时页面一定要有body标签。 
FF：window.innerWidth 和 window.innerHeight，以及 document.documentElement.clientWidth 和 document.documentElement.clientHeight。 
解决办法：通用属性 document.body.clientWidth 和 document.body.clientHeight； 

7. 添加事件 
IE：element.attachEvent('onclick',function) 
FF：element.addEventListener('click',function,true) 
解决办法：element.onclick = function.虽然都可以使用click事件。但onclick和上面两种方法效果是不一样的。onclick只有执行一个过程，而attachEvent 和 addEventListener执行的是一个过程列表，也就是多个过程。 
如：element.attachEvent('onclick',func1); element.attachEvent("onclick", func2)这样func1和func2都会被执行。 

8. 标签的自定义属性 
IE：如果给标签div1定义了一个属性value，可以div1.value 和 div1["value"]取得该值 
FF：不能用div1.value 和div1["value"] 
解决办法：div1.getAttribute('value') 

9. document.form.item 
IE：现有问题，document.formName.item("itemName") 这样的语句，不能在 FF 下运行 
FF：不支持 
解决办法： document.formName.elements["elementName"] 

10. 集合/数组类对象问题 
IE：有许多集合类对象取用时用() 
FF：不能这样取用 
解决办法：改用[]作为下标运算。 
如：document.forms("formName") 改为 document.forms["formName"]。document.getElementsByName("inputName")(1) 改为 document.getElementsByName("inputName")[1] 

11. HTML对象的id作为对象名的问题 
IE：HTML对象的id可以作为document的下属变量名直接使用 
FF：需要用getElementById()方法 
解决办法：用getElementById('idName')代替idName作为对象变量使用 

12. 用idName字符串取得对象的问题 
IE：利用eval(idName)可以取得 id 为 idName 的HTML对象。 
FF：不支持 
解决办法：getElementById(idName) 代替 eval(idName) 

13. 变量名与某 HTML 对象 id 相同的问题 
IE：因为HTML对象id 在IE中直接调用，所以变量名不能和id相同 
FF：可以使用变量名和id相同 
解决办法，声明变量时一律加上 var ，以避免歧义(最好id和变量名不要相同)。 

14. document.getElementsByName() 和 document.all[name] 
IE：getElementsByName()、document.all[name] 均不能用来取得 div 元素 
FF：可以兼容document.all， 但会生成一条警告。 
解决办法：可以用getElementById() 或者 getElementByTagName()来代替 

15. input.type属性问题 
IE：input.type属性为只读 
FF：input.type属性为读写 

16. window.location.href 
IE：（FF2.0以下），可以使用window.location 或 window.location.href ; FF 1.5下只能使用window.location 
解决办法：使用window.location 来代替 window.location.href 

17. 模态和非模态窗口问题 
IE：可以通过 showModalDialog 和 showModelessDialog 打开模态和非模态窗口 
FF：不支持 
解决办法：直接使用window.open(pageURL, name, parameters) 方式打开新窗口，如果需要将子窗口中的参数传递回父窗口，可以在子窗口中使用window.opener来访问父窗口。 
如：var parWin = window.opener; parWin.document.getElementById('title').value = 'My Title'; 

18. body 
IE：body必须在body标签被浏览器完全读入后才存在 
FF：body在body标签没有被浏览器完全读入之前就存在 

19. 事件委托方法 
IE：document.body.onload = init; 
FF：document.body.onload = init(); 
解决办法：统一使用 document.body.onload = new Function('init()'); 或者 docuement.body.onload = function(){/* 这里是代码 */} 

20. 父元素的区别 
IE：obj.parentElement; 
FF ：obj.parentNode 
解决办法：因为FF与IE都支持DOM，所以可以都使用obj.parentNode 

22.innerText在IE中能正常工作，但是innerText在FF中却不行. 需用textContent 

23. FF中设置HTML标签的style时，所有位置性和字体尺寸的值必须后跟px。这个IE也是支持的 

24. 父节点、子节点和删除节点 
IE：parentElement、parement.children，element.romoveNode(true)。 
FF：parentNode、parentNode.childNodes，node.parentNode.removeChild(node)。



## 如何从一个JavaScript对象中删除一个属性

```js
var myJSONObject = { "ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*" };

// ==>

var myJSONObject = { "ircEvent": "PRIVMSG", "method": "newURI" };

// 方法一
delete myJSONObject.regex;

// or,

delete myJSONObject['regex'];

// or,

var prop = "regex";
delete myJSONObject[prop];

// 方法二
var myJSONObject = { "ircEvent": "PRIVMSG", "method": "newURI", "regex": "^http://.*" };

delete myJSONObject.regex;

alert(myJSONObject.regex); // alerts: undefined
```



## 关于 "use strict"

严格模式是`ECMAScript 5`中的一项新特征，允许你把一段程序或功能放置在"strict"工作环境中。这种严格上下文环境防止某些行为被采取并引发更多的异常。


严格的模式有助于几个方面：

* 它捕获了一些常见的编码错误，抛出异常。

* 它阻止，或抛出错误，当相对“不安全”的行为被采用（例如获取全局对象）。 

* 它禁用那些混淆的或者考虑不周的特征

```js
// 非严格的代码...

(function () {
  "use strict";

  // 严格定义你的库...
})();

// 非严格的代码
```



## 检测是否有东西被隐藏

```js
// 检查 display:[none|block], 忽略 visible:[true|false]
$(element).is(":visible");

// 匹配的是隐藏的所有元素
$('element:hidden')

// 匹配所有可见的元素
$('element:visible')
```




## position & left & display & bfc 等等 tips

float也是典型的inline-block化元素，这种元素的inline-block化适用于任何水平的标签。

例如一个div标签默认宽度是100%显示的，但是一旦被absolute属性缠上，则100%默认宽度就会变成自适应内部元素的宽度。
但是，有float:left/position:absolute撑腰的情况下，display属性就是多余的，可以直接回家喝茶了。

```css
span { float:left; width:100px; }
span { position:absolute; width:100px; }
```

动画效果应用到position属性为absolute或fixed的元素上

动画效果应用到position属性为absolute或fixed的元素上，它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。

百分比是相对单位，比方说translate是自身，width/height是父级，background-position需要尺寸差计算等。

圆角：border-垂直-水平-radius: 水平 垂直

vertical-align的百分比值不是相对于字体大小或者其他什么属性计算的，而是相对于line-height计算的。举个简单的例子，如下CSS代码：

```css
{
  line-height: 30px;
  vertical-align: -10%;
}
```

实际上，等同于：

```css
{
  line-height: 30px;
  vertical-align: -3px;    /* = 30px * -10% */  
}
```

vertical-align  block化就无效了

line boxes 一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。

![](1.png)

在目前的CSS的世界中，所有的高度都是有两个CSS模型产生的，一个是box盒状模型，对应CSS为”height+padding+margin”，另外一个是line box模型，对应样式为”line-height”。前者的height属性分为明显的height值和隐藏的height值，所谓隐藏的height值是指图片的高度，一旦载入一张图片，其内在的height值就会起作用，即使您看不到”height”这个词。而后者针对于文字等这类inline boxes的元素（图片也属于inline boxes，但其height比line-height作用更凶猛，故其inline boxes高度等于其自身高度，对line-height无反应），inline boxes的高度直接受line-height控制（改变line-height文字拉开或重叠就是这个原因），而真正的高度表现则是由每行众多的inline boxes组成的line boxes（等于内部最高的inline box的高度），而这些line boxes的高度垂直堆叠形成了containing box的高度，也就是我们见到的div或是p标签之类的高度了。所以，对于line box模型的元素而言，没有inline boxes，就没有高度了，而浮动却恰恰做了这么龌龊的事情，其直接将元素的inline boxes也破坏了，于是这些元素也就没有了高度。

浮动布局会让父标签高度缺失

![](2.png)

清除浮动其实就一个目的，就是解决高度塌陷的问题。为什么会高度塌陷？什么时候会高度塌陷？塌陷原因是：元素含有浮动属性 – 破坏inline box – 破坏line box高度 – 没有高度 – 塌陷。什么时候会塌陷：当标签里面的元素只要样子没有实际高度时会塌陷。所以呢，并不是只要有浮动元素就会坍塌，就要清除的


float与JavaScript
JavaScript可以改变CSS的属性，其他些属性还好，但是这个float值得一说，为何呢，因为float貌似是JavaScript中的一个关键字，不能使用obj.style.float="left";这样的句子。得使用其他写法。

IE浏览器：
```css
obj.style.styleFloat = "left";
```
其他浏览器：
```css
obj.style.cssFloat = "left";
```

CSS的margin塌陷（collapse） 

![](3.jpg)


因为CSS中存在一个margin collapse，即边界塌陷或者说边界重叠。对于上下两个并列的div块而言，上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值，所以从这个意义上说：CSS及浏览器的设计者们希望我们在布局时，如果遇到上下两个并排内容块的安排，最好只设置其中每个块上或下margin的一处即可。
    但对于父块DIV内含子块DIV的情况，就会按另一条CSS惯例来解释了，那就是：对于有块级子元素的元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离。

结论：
    解决父子DIV中顶部margin cllapse的问题，需要给父div设置：
    1、边框，当然可以设置边框为透明;
    2、为父DIV添加padding，或者至少添加padding-top;
    此外，还可以通过over-flow:hidden来解决

    
----

----



长按事件

只要长按时间到达1000毫秒，无论是否弹起鼠标，都会触发。反之，如果不到1000毫秒，鼠标弹起的时候会结束

```js
//申明全局变量
var timeStart, timeEnd, time;

//获取此刻时间
function getTimeNow() {
  var now = new Date();
  return now.getTime();
}

//鼠标按下时触发
function holdDown() {
  //获取鼠标按下时的时间
  timeStart = getTimeNow();

  //setInterval会每100毫秒执行一次，也就是每100毫秒获取一次时间
  time = setInterval(function () {
    timeEnd = getTimeNow();

    //如果此时检测到的时间与第一次获取的时间差有1000毫秒
    if (timeEnd - timeStart > 1000) {
      //便不再继续重复此函数 （clearInterval取消周期性执行）
      clearInterval(time);
      //字体变红
      document.getElementById("p1").style.color = "red";
    }
  }, 100);
}
function holdUp() {
  //如果按下时间不到1000毫秒便弹起，
  clearInterval(time);
}
```



如何判断一个对象是否为空

1 最常见的思路，for...in 遍历属性，为真则为“非空数组”；否则为“空数组”

```js
for (var i in obj) { // 如果不为空，则会执行到这一步，返回true
    return true
}
return false // 如果为空,返回false
```

2 通过 JSON 自带的 stringify() 方法来判断

JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。

```js
if (JSON.stringify(data) === '{}') {
    return false // 如果为空,返回false
}
return true // 如果不为空，则会执行到这一步，返回true
```

这里需要注意为什么不用 toString()，因为它返回的不是我们需要的。

```js
var a = {}
a.toString() // "[object Object]"
```


3 ES6 新增的方法 Object.keys():

Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组。

如果我们的对象为空，他会返回一个空数组，如下：

```js
var a = {}
Object.keys(a) // []
```

我们可以依靠Object.keys()这个方法通过判断它的长度来知道它是否为空。

```js
if (Object.keys(object).length === 0) {
    return false // 如果为空,返回false
}
return true // 如果不为空，则会执行到这一步，返回true
```




Javascript命名空间和模块

[Javascript命名空间和模块](https://www.kenneth-truyers.net/2013/04/27/javascript-namespaces-and-modules/)